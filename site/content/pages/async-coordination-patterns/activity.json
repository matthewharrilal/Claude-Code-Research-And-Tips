{
  "items": [
    {
      "id": "inv-1",
      "type": "inversion",
      "linkedSection": "essence",
      "title": "What if agents could share memory?",
      "content": "<strong>You'd design:</strong> Shared context window, no external state, real-time sync.<br>\n          <strong>Why this fails:</strong> LLM context windows are isolated. No shared memory exists between Claude instances.<br>\n          <strong>Hidden constraint revealed:</strong> Async coordination IS the solution to isolated contexts."
    },
    {
      "id": "min-2",
      "type": "minimal",
      "linkedSection": "essence",
      "title": "The irreducible core",
      "content": "<code style=\"background: #f4f4f5; padding: 2px 6px; border-radius: 4px; font-size: 12px;\">reserve() → work() → release()</code><br>\n          <strong>Essential:</strong> Claim before edit. Release after.<br>\n          <strong>Everything else:</strong> Refinement for reliability."
    },
    {
      "id": "inv-3",
      "type": "invariant",
      "linkedSection": "essence",
      "title": "INV-003: External state beats internal memory",
      "content": "Agent Mail, Gas Town, Ralph, CC Mirror all share this invariant. Files are the memory. Context windows are ephemeral. If you understand this, you understand why all these patterns exist."
    },
    {
      "id": "ana-4",
      "type": "analogy",
      "linkedSection": "core",
      "title": "Async Coordination = Database Transactions",
      "content": "File reservations → Row-level locks<br>\n          TTL expiry → Lock timeout<br>\n          Pre-commit guards → Constraint checks<br>\n          Thread IDs → Transaction IDs<br><br>\n          <em>If you've designed database concurrency, you already understand agent coordination.</em>"
    },
    {
      "id": "con-5",
      "type": "constraint",
      "linkedSection": "core",
      "title": "One constraint → FIVE decisions",
      "content": "<strong>ROOT:</strong> Claude instances have isolated contexts<br>\n          → State must persist externally (files)<br>\n          → Multiple writers need coordination<br>\n          → Coordination needs some form of locking<br>\n          → Locks need timeout to prevent deadlock<br>\n          → TTL-based advisory leases are the pattern"
    },
    {
      "id": "grad-6",
      "type": "gradient",
      "linkedSection": "core",
      "title": "How conflicts escalate (invisibly)",
      "content": "<strong>0 conflicts:</strong> Everything works fine<br>\n          <strong>1 conflict:</strong> Human resolves in 10 minutes<br>\n          <strong>3 conflicts:</strong> Half hour of debugging<br>\n          <strong>5+ conflicts:</strong> Complete merge nightmare<br><br>\n          <em>Critical: First few conflicts are recoverable. Beyond 5, start fresh.</em>"
    },
    {
      "id": "trade-7",
      "type": "tradeoff",
      "linkedSection": "decisions",
      "title": "The Lock Strictness Dilemma",
      "content": "<strong>Advisory locks:</strong> Flexible, but rogue agents can ignore<br>\n          <strong>Pre-commit guards:</strong> Enforced, but can block legitimate work<br>\n          <strong>Hard filesystem locks:</strong> Strong, but deadlock-prone<br><br>\n          <em>Heuristic: Start advisory, add guards when agents misbehave.</em>"
    },
    {
      "id": "exp-8",
      "type": "expertise",
      "linkedSection": "decisions",
      "title": "How deep is your understanding?",
      "content": "<strong>Beginner:</strong> \"What's file reservation?\" → Lock before edit<br>\n          <strong>Intermediate:</strong> \"Why TTL?\" → Prevents deadlocks<br>\n          <strong>Advanced:</strong> \"Advisory vs enforced?\" → Trade-off is flexibility<br>\n          <strong>Staff:</strong> \"When to escalate?\" → Pre-commit guards<br>\n          <strong>Expert:</strong> \"Hybrid patterns?\" → Agent Mail + NATS layers"
    },
    {
      "id": "inv-9",
      "type": "inversion",
      "linkedSection": "decisions",
      "title": "What if TTL didn't expire?",
      "content": "<strong>You'd design:</strong> Manual lock release only, explicit handoff protocols.<br>\n          <strong>Why this fails:</strong> Crashed agents hold locks forever. System stops.<br>\n          <strong>Hidden constraint revealed:</strong> Agent failure is inevitable. TTL handles it automatically."
    },
    {
      "id": "war-10",
      "type": "warstory",
      "linkedSection": "agentmail",
      "title": "Jeffrey Emanuel: Agent Mail Creator",
      "content": "Built Agent Mail after witnessing multi-agent chaos. \"Agents need email, not chat. Polling between work steps, not constant interruption.\" The email metaphor made coordination intuitive for agents without training."
    },
    {
      "id": "comp-11",
      "type": "composition",
      "linkedSection": "agentmail",
      "title": "Agent Mail + Gas Town",
      "content": "<strong>Works:</strong> Perfectly. Agent Mail was designed for Gas Town.<br>\n          <strong>Role mapping:</strong> Mayor receives status updates. Polecats hold long TTL reservations. Crew gets short TTL.<br>\n          <strong>Recommendation:</strong> Use together for factory-scale coordination."
    },
    {
      "id": "hor-12",
      "type": "horizon",
      "linkedSection": "agentmail",
      "title": "How judgment evolves with agent count",
      "content": "<strong>2 agents:</strong> \"Coordination feels like overhead\"<br>\n          <strong>4 agents:</strong> \"Getting some conflicts...\"<br>\n          <strong>6 agents:</strong> \"Agent Mail is why we're not fighting\"<br>\n          <strong>10+ agents:</strong> \"Infrastructure is ROI positive\"<br><br>\n          <em>Don't judge coordination by 2-agent experiments.</em>"
    },
    {
      "id": "vio-13",
      "type": "violation",
      "linkedSection": "agentmail",
      "title": "If you skip register_agent()",
      "content": "<strong>IF:</strong> Skip registration before messaging<br>\n          <strong>THEN:</strong> Message fails with \"from_agent not registered\"<br>\n          <strong>THEN:</strong> Agent retries, fails again<br>\n          <strong>THEN:</strong> Agent wastes context on failed operations<br>\n          <strong>FINALLY:</strong> Context exhausted with no work done<br><br>\n          <em>The fix: Always register first. One call, done.</em>"
    },
    {
      "id": "eff-14",
      "type": "effect",
      "linkedSection": "station",
      "title": "At distributed scale, new problems emerge",
      "content": "<strong>Single machine:</strong> SQLite is fast enough<br>\n          <strong>3 machines:</strong> Network latency starts mattering<br>\n          <strong>10+ machines:</strong> Need proper pub/sub, not polling<br><br>\n          <strong>Threshold:</strong> When cross-machine coordination &gt; 20% of work, switch to NATS."
    },
    {
      "id": "ana-15",
      "type": "analogy",
      "linkedSection": "station",
      "title": "NATS Lattice = Kubernetes Networking",
      "content": "Stations → Pods<br>\n          Lattice mesh → Service mesh<br>\n          Subject hierarchy → DNS naming<br>\n          JetStream → Persistent volumes<br><br>\n          <em>If you've designed Kubernetes networking, NATS lattice will feel familiar.</em>"
    },
    {
      "id": "comp-16",
      "type": "composition",
      "linkedSection": "station",
      "title": "Station + Agent Mail (Hybrid)",
      "content": "<strong>Works:</strong> Yes, at different layers.<br>\n          <strong>Architecture:</strong> NATS between stations (cross-machine). Agent Mail within each station (local agents).<br>\n          <strong>Recommendation:</strong> Use NATS for inter-station, Agent Mail for intra-station coordination."
    },
    {
      "id": "fron-17",
      "type": "frontier",
      "linkedSection": "station",
      "title": "UNSOLVED: Optimal station sizing",
      "content": "How many agents per station? When to split into multiple stations? No clear formula exists. Varies by agent task duration, message frequency, and network topology."
    },
    {
      "id": "inf-18",
      "type": "inflection",
      "linkedSection": "gotchas",
      "title": "When TTL becomes a problem",
      "content": "<strong>1 hour TTL:</strong> Works for most feature work<br>\n          <strong>2+ hours:</strong> Blocking others too long<br>\n          <strong>30 minutes:</strong> Renewal overhead increases<br>\n          <strong>5 minutes:</strong> Constant renewal, race conditions<br><br>\n          <strong>THE INFLECTION:</strong> ~1 hour is optimal for most work<br>\n          <strong>DETECTION:</strong> Frequent conflicts? TTL too long. Frequent expiry? TTL too short."
    },
    {
      "id": "vio-19",
      "type": "violation",
      "linkedSection": "gotchas",
      "title": "If you bypass pre-commit guards",
      "content": "<strong>IF:</strong> Use <code>git commit --no-verify</code><br>\n          <strong>THEN:</strong> Conflicting changes enter git<br>\n          <strong>THEN:</strong> Other agents pull broken state<br>\n          <strong>THEN:</strong> Multiple agents now confused<br>\n          <strong>FINALLY:</strong> Cascade of broken commits<br><br>\n          <em>The fix: Never bypass. If guard blocks you, coordinate first.</em>"
    },
    {
      "id": "war-20",
      "type": "warstory",
      "linkedSection": "gotchas",
      "title": "The overnight conflict cascade",
      "content": "Team ran 8 agents overnight without coordination. Morning revealed 47 merge conflicts across 12 files. 4 hours of manual reconciliation. Next night: Agent Mail installed. Zero conflicts."
    },
    {
      "id": "trade-21",
      "type": "tradeoff",
      "linkedSection": "hard",
      "title": "Latency vs Simplicity",
      "content": "<strong>THE DILEMMA:</strong><br>\n          <strong>Agent Mail (polling):</strong> Simple, but 100ms+ latency<br>\n          <strong>NATS (push):</strong> Sub-millisecond, but deployment overhead<br>\n          <strong>Hybrid:</strong> Best of both, but two systems to maintain<br><br>\n          <em>Accept: No perfect answer. Match to your scale and latency requirements.</em>"
    },
    {
      "id": "grad-22",
      "type": "gradient",
      "linkedSection": "hard",
      "title": "How advisory locks fail (gradually)",
      "content": "<strong>100% compliance:</strong> Perfect coordination<br>\n          <strong>95% compliance:</strong> Occasional conflicts, recoverable<br>\n          <strong>80% compliance:</strong> Frequent conflicts, annoying<br>\n          <strong>50% compliance:</strong> System nearly unusable<br><br>\n          <em>Critical: One rogue agent can poison the whole system. Add guards before it's too late.</em>"
    },
    {
      "id": "exp-23",
      "type": "expertise",
      "linkedSection": "hard",
      "title": "Debugging coordination failures",
      "content": "<strong>Beginner:</strong> \"Why did my agent fail?\" → Check registration<br>\n          <strong>Intermediate:</strong> \"Why the conflict?\" → Check reservation times<br>\n          <strong>Advanced:</strong> \"Why stale data?\" → Check message threading<br>\n          <strong>Staff:</strong> \"Why cascade?\" → Check all agent states<br>\n          <strong>Expert:</strong> \"Why intermittent?\" → Distributed tracing"
    },
    {
      "id": "alt-24",
      "type": "alternative",
      "linkedSection": "when",
      "title": "If async coordination isn't right",
      "content": "<strong>Single agent?</strong> → No coordination needed<br>\n          <strong>Separate files always?</strong> → Git worktrees<br>\n          <strong>Need real-time sync?</strong> → CC Mirror task dependencies<br>\n          <strong>Sequential only?</strong> → Ralph's progress.txt"
    },
    {
      "id": "inv-25",
      "type": "inversion",
      "linkedSection": "when",
      "title": "What if you never need coordination?",
      "content": "<strong>You'd design:</strong> Each agent owns completely separate files. Git worktrees. No overlap ever.<br>\n          <strong>Why this sometimes fails:</strong> Real projects have shared files. APIs, configs, schemas.<br>\n          <strong>Hidden constraint revealed:</strong> Coordination overhead justified when files overlap."
    },
    {
      "id": "hor-26",
      "type": "horizon",
      "linkedSection": "when",
      "title": "How coordination needs evolve",
      "content": "<strong>Day 1:</strong> \"We don't need this\"<br>\n          <strong>Week 1:</strong> \"First conflict, manually fixed\"<br>\n          <strong>Month 1:</strong> \"Conflicts happening daily\"<br>\n          <strong>Quarter 1:</strong> \"Agent Mail is infrastructure\"<br><br>\n          <em>Investment in coordination pays off over months, not days.</em>"
    },
    {
      "id": "inv-27",
      "type": "invariant",
      "linkedSection": "when",
      "title": "All multi-agent patterns need coordination",
      "content": "Gas Town, CC Mirror, Parallel Ralph, Panopticon - all eventually need async coordination when agents touch shared resources. The question isn't IF, but WHEN to add it."
    }
  ]
}