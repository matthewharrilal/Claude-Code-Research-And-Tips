{
  "items": [
    {
      "id": "inv-1",
      "type": "inversion",
      "linkedSection": "essence",
      "title": "What if there was only ONE architecture?",
      "content": "<strong>You'd design:</strong> A super-flexible single agent that scales up and down.<br>\n          <strong>Why this fails:</strong> Context limits are physics. Parallelism needs multiple processes. Specialization needs separation.<br>\n          <strong>Hidden constraint:</strong> Four architectures exist because one CAN'T serve all constraints."
    },
    {
      "id": "min-2",
      "type": "minimal",
      "linkedSection": "essence",
      "title": "The irreducible decision",
      "content": "<strong>The real question:</strong> \"Do I need more than one context window?\"<br>\n          <strong>If no:</strong> Single agent.<br>\n          <strong>If yes:</strong> Everything else is about HOW to coordinate multiple contexts."
    },
    {
      "id": "ana-3",
      "type": "analogy",
      "linkedSection": "essence",
      "title": "Software team structures",
      "content": "<strong>Single</strong> = Solo developer<br>\n          <strong>Subagents</strong> = Dev + occasional contractor<br>\n          <strong>Swarm</strong> = Small cross-functional team<br>\n          <strong>Hierarchical</strong> = Engineering department<br><br>\n          <em>If you've managed teams, you understand these architectures.</em>"
    },
    {
      "id": "inv-4",
      "type": "invariant",
      "linkedSection": "core",
      "title": "INV-001: All architectures share the same goal",
      "content": "<strong>Single, Subagents, Swarm, Hierarchical</strong> all transform requirements into working code.<br><br>\n          <strong>Why this matters:</strong> The choice is about CONSTRAINTS, not CAPABILITIES. They all CAN do the work. They differ in HOW efficiently given your constraints."
    },
    {
      "id": "con-5",
      "type": "constraint",
      "linkedSection": "core",
      "title": "Context limit is the root constraint",
      "content": "<strong>ROOT:</strong> Context window is finite (128K-200K)<br>\n          -&gt; Complex work exceeds one context<br>\n          -&gt; Need multiple contexts (agents)<br>\n          -&gt; Need to coordinate multiple agents<br>\n          -&gt; Need to manage context isolation vs sharing<br>\n          -&gt; Architectures differ by coordination strategy"
    },
    {
      "id": "trade-6",
      "type": "tradeoff",
      "linkedSection": "core",
      "title": "Speed vs. Cost vs. Complexity",
      "content": "<strong>Single:</strong> Cheapest, slowest for large work, simplest<br>\n          <strong>Hierarchical:</strong> Most expensive, fastest at scale, most complex<br><br>\n          <strong>Heuristic:</strong> Pick the simplest architecture that meets your speed requirement."
    },
    {
      "id": "war-7",
      "type": "warstory",
      "linkedSection": "architectures",
      "title": "Boris Cherny: \"Single agent, vanilla\"",
      "content": "Claude Code creator uses single agent for most work. \"I don't use subagents much. Just direct prompting with good CLAUDE.md.\"<br><br>\n          <strong>Key insight:</strong> The creator of the tool uses the simplest architecture. Don't over-complicate."
    },
    {
      "id": "exp-8",
      "type": "expertise",
      "linkedSection": "architectures",
      "title": "Single Agent depth of understanding",
      "content": "<strong>Beginner:</strong> \"How do I use it?\" -&gt; <code>claude \"do X\"</code><br>\n          <strong>Intermediate:</strong> \"When does it fail?\" -&gt; Context limits, 80K+ rot<br>\n          <strong>Advanced:</strong> \"How to extend?\" -&gt; <code>/compact</code>, fresh sessions<br>\n          <strong>Staff:</strong> \"When to upgrade?\" -&gt; When research pollutes context<br>\n          <strong>Expert:</strong> \"What's the boundary?\" -&gt; Single agent + CLAUDE.md can do 80% of tasks"
    },
    {
      "id": "grad-9",
      "type": "gradient",
      "linkedSection": "architectures",
      "title": "How subagents fail as count increases",
      "content": "<strong>1-2 subagents:</strong> Clean, low overhead<br>\n          <strong>3-5 subagents:</strong> Manageable, some spawn overhead<br>\n          <strong>5-8 subagents:</strong> Main context filling with summaries<br>\n          <strong>8+ subagents:</strong> Coordination becomes the work<br><br>\n          <strong>Inflection:</strong> ~5 subagents. Beyond this, consider Swarm."
    },
    {
      "id": "vio-10",
      "type": "violation",
      "linkedSection": "architectures",
      "title": "IF: Orchestrator writes code directly",
      "content": "<strong>THEN:</strong> Orchestrator context fills with implementation details<br>\n          <strong>THEN:</strong> Loses strategic view of overall work<br>\n          <strong>THEN:</strong> Starts making local optimizations, missing global picture<br>\n          <strong>FINALLY:</strong> Workers receive confused instructions<br><br>\n          <em>The Iron Law exists because this cascade is so common.</em>"
    },
    {
      "id": "war-11",
      "type": "warstory",
      "linkedSection": "architectures",
      "title": "Steve Yegge: \"Agent Town\"",
      "content": "Gas Town architect runs \"about 50 agents on any given day.\" Uses Mayor, Deacon, Dogs, Polecat structure.<br><br>\n          <strong>Key insight:</strong> \"You just make up features, design them, file the implementation plans, and sling work around to your polecats.\""
    },
    {
      "id": "hor-12",
      "type": "horizon",
      "linkedSection": "architectures",
      "title": "How Hierarchical perception changes",
      "content": "<strong>Day 1:</strong> \"This is way too complex\"<br>\n          <strong>Week 1:</strong> \"Still setting up infrastructure\"<br>\n          <strong>Week 2:</strong> \"Starting to see the patterns\"<br>\n          <strong>Month 1:</strong> \"I can't imagine going back to single agent\"<br><br>\n          <em>Hierarchical requires commitment. The payoff is weeks out, not days.</em>"
    },
    {
      "id": "comp-13",
      "type": "composition",
      "linkedSection": "architectures",
      "title": "Swarm + Ralph Loop",
      "content": "<strong>Works?</strong> Yes, powerfully.<br>\n          <strong>Pattern:</strong> Ralph loop for overnight execution, Swarm for parallelism within each iteration.<br>\n          <strong>Danger:</strong> Complex. Only combine after mastering each separately.<br>\n          <strong>Recommendation:</strong> Start with Ralph OR Swarm. Combine only for enterprise."
    },
    {
      "id": "fron-14",
      "type": "frontier",
      "linkedSection": "architectures",
      "title": "UNSOLVED: Optimal agent count per task type",
      "content": "<strong>The question:</strong> How many workers maximize throughput for feature X?<br>\n          <strong>Why hard:</strong> Depends on task decomposability, codebase structure, model capabilities.<br>\n          <strong>Current practice:</strong> Start with 2-3, add incrementally, stop when diminishing returns."
    },
    {
      "id": "ana-15",
      "type": "analogy",
      "linkedSection": "matrix",
      "title": "Matrix = Buying a vehicle",
      "content": "<strong>Single:</strong> Bicycle (simple, slow, cheap)<br>\n          <strong>Subagents:</strong> Motorcycle (faster, some complexity)<br>\n          <strong>Swarm:</strong> Car (parallel passengers, more expensive)<br>\n          <strong>Hierarchical:</strong> Bus/Fleet (enterprise scale, dedicated infrastructure)<br><br>\n          <em>Don't buy a bus for a trip to the grocery store.</em>"
    },
    {
      "id": "inf-16",
      "type": "inflection",
      "linkedSection": "matrix",
      "title": "Setup time vs. execution time",
      "content": "<strong>0-2 hours task:</strong> Single (setup = 0, always wins)<br>\n          <strong>2-8 hours task:</strong> Subagents (minutes setup worthwhile)<br>\n          <strong>8+ hours task:</strong> Swarm (hours setup worthwhile)<br>\n          <strong>Days/weeks task:</strong> Hierarchical (days setup worthwhile)<br><br>\n          <strong>Heuristic:</strong> Setup time should be &lt;10% of execution time."
    },
    {
      "id": "eff-17",
      "type": "effect",
      "linkedSection": "matrix",
      "title": "Debugging complexity scales exponentially",
      "content": "<strong>Single:</strong> O(1) - One place to look<br>\n          <strong>Subagents:</strong> O(n) - Check each subagent<br>\n          <strong>Swarm:</strong> O(n^2) - Check interactions<br>\n          <strong>Hierarchical:</strong> O(n^3) - Multi-level interactions<br><br>\n          <em>Don't underestimate debugging cost when choosing architecture.</em>"
    },
    {
      "id": "inv-18",
      "type": "inversion",
      "linkedSection": "decisions",
      "title": "What if you ALWAYS used Hierarchical?",
      "content": "<strong>You'd get:</strong> Gas Town for a typo fix. Mayor coordinates Polecat to change one character.<br>\n          <strong>Why this fails:</strong> Coordination overhead exceeds work done. 5 minutes of setup for 5 seconds of change.<br>\n          <strong>Hidden constraint:</strong> Architecture must match SCALE of work, not importance."
    },
    {
      "id": "exp-19",
      "type": "expertise",
      "linkedSection": "decisions",
      "title": "Architecture selection mastery",
      "content": "<strong>Beginner:</strong> \"Which is best?\" -&gt; None inherently<br>\n          <strong>Intermediate:</strong> \"When each?\" -&gt; Decision tree<br>\n          <strong>Advanced:</strong> \"How to migrate?\" -&gt; Trigger signals<br>\n          <strong>Staff:</strong> \"How to combine?\" -&gt; Composition cases<br>\n          <strong>Expert:</strong> \"What's evolving?\" -&gt; Research frontiers"
    },
    {
      "id": "con-20",
      "type": "constraint",
      "linkedSection": "decisions",
      "title": "Time constraint cascades into architecture",
      "content": "<strong>ROOT:</strong> \"I need this done in 2 hours\"<br>\n          -&gt; Can't afford setup time<br>\n          -&gt; Must use existing infrastructure<br>\n          -&gt; Single agent (no setup) or existing Swarm<br>\n          -&gt; If complex, either extend timeline or accept lower quality"
    },
    {
      "id": "alt-21",
      "type": "alternative",
      "linkedSection": "decisions",
      "title": "If none of these fit",
      "content": "<strong>Need content, not code?</strong> -&gt; Ralph Wiggum Marketer<br>\n          <strong>Need overnight, not parallel?</strong> -&gt; Ralph loop<br>\n          <strong>Need human gates?</strong> -&gt; HOTL variants<br>\n          <strong>Need maximum safety?</strong> -&gt; Single + human review"
    },
    {
      "id": "vio-22",
      "type": "violation",
      "linkedSection": "gotchas",
      "title": "IF: You don't assign file boundaries",
      "content": "<strong>THEN:</strong> Worker A edits auth.py<br>\n          <strong>THEN:</strong> Worker B also edits auth.py<br>\n          <strong>THEN:</strong> Both commit, merge conflict<br>\n          <strong>FINALLY:</strong> Manual merge needed, defeating parallelism<br><br>\n          <em>File boundaries aren't optional in Swarm. They're required.</em>"
    },
    {
      "id": "grad-23",
      "type": "gradient",
      "linkedSection": "gotchas",
      "title": "Gas Town cost spiral",
      "content": "<strong>Normal:</strong> $5-20/day, steady progress<br>\n          <strong>Warning:</strong> $20-50/day, check task sizes<br>\n          <strong>Danger:</strong> $50-100/day, audit worker preambles<br>\n          <strong>Crisis:</strong> $100+/day, workers spawning sub-workers<br><br>\n          <strong>Detection:</strong> Set daily budget alerts. Never let it run unbounded."
    },
    {
      "id": "war-24",
      "type": "warstory",
      "linkedSection": "gotchas",
      "title": "The $300 overnight disaster",
      "content": "Developer set up Swarm, left overnight. Workers got stuck in retry loops. Each retry spawned new workers.<br><br>\n          <strong>Lesson:</strong> Never run unattended without max iteration limits and budget caps."
    },
    {
      "id": "trade-25",
      "type": "tradeoff",
      "linkedSection": "gotchas",
      "title": "Spawn overhead vs. context isolation",
      "content": "<strong>Fewer spawns:</strong> Lower overhead, but context pollution<br>\n          <strong>More spawns:</strong> Clean isolation, but high spawn cost<br><br>\n          <strong>Heuristic:</strong> Spawn for tasks &gt; 5 minutes. Inline tasks &lt; 5 minutes."
    },
    {
      "id": "hor-26",
      "type": "horizon",
      "linkedSection": "hard",
      "title": "Coordination cost perception",
      "content": "<strong>First project:</strong> \"Coordination is overhead\"<br>\n          <strong>Fifth project:</strong> \"Coordination is where the bugs are\"<br>\n          <strong>Twentieth project:</strong> \"Coordination IS the architecture\"<br><br>\n          <em>The more you scale, the more you realize coordination is the work.</em>"
    },
    {
      "id": "inv-27",
      "type": "invariant",
      "linkedSection": "hard",
      "title": "INV-003: External state > internal memory",
      "content": "All multi-agent architectures share this: <strong>coordination happens through files, not memory.</strong><br><br>\n          <strong>Why:</strong> Agents can't share memory. Files are the universal interface. This invariant forces external state in ALL architectures above Single."
    },
    {
      "id": "inv-28",
      "type": "inversion",
      "linkedSection": "hard",
      "title": "What if agents could share memory?",
      "content": "<strong>You'd design:</strong> One giant shared context, no files, no coordination.<br>\n          <strong>Why impossible:</strong> LLM architecture. Each call is stateless. \"Memory\" IS the context window.<br>\n          <strong>Hidden constraint:</strong> Multi-agent coordination through files is not a choice. It's physics."
    },
    {
      "id": "fron-29",
      "type": "frontier",
      "linkedSection": "hard",
      "title": "UNSOLVED: Optimal coordination protocol",
      "content": "<strong>The question:</strong> What's the minimal coordination needed for N agents?<br>\n          <strong>Why hard:</strong> Depends on task interdependency, not just agent count.<br>\n          <strong>Current practice:</strong> Over-coordinate rather than under-coordinate. Cost of coordination &lt; cost of conflicts."
    },
    {
      "id": "exp-30",
      "type": "expertise",
      "linkedSection": "migration",
      "title": "Migration mastery",
      "content": "<strong>Beginner:</strong> \"When should I migrate?\" -&gt; When current approach demonstrably fails<br>\n          <strong>Intermediate:</strong> \"How to migrate?\" -&gt; Incrementally, one level at a time<br>\n          <strong>Advanced:</strong> \"What carries over?\" -&gt; CLAUDE.md, prompts, patterns<br>\n          <strong>Staff:</strong> \"Can I skip levels?\" -&gt; Yes, with experience<br>\n          <strong>Expert:</strong> \"When to downgrade?\" -&gt; When overhead exceeds value"
    },
    {
      "id": "vio-31",
      "type": "violation",
      "linkedSection": "migration",
      "title": "IF: You skip from Single to Hierarchical",
      "content": "<strong>THEN:</strong> You don't understand subagent delegation<br>\n          <strong>THEN:</strong> You misconfigure orchestrator/worker boundaries<br>\n          <strong>THEN:</strong> Workers do orchestration, violating Iron Law<br>\n          <strong>FINALLY:</strong> System fails in ways you can't debug<br><br>\n          <em>The migration path exists because each level teaches concepts needed for the next.</em>"
    },
    {
      "id": "inf-32",
      "type": "inflection",
      "linkedSection": "migration",
      "title": "When architecture upgrade pays off",
      "content": "<strong>Single -&gt; Subagents:</strong> When you've used /compact 3+ times in one session<br>\n          <strong>Subagents -&gt; Swarm:</strong> When you're waiting for sequential subagents to finish<br>\n          <strong>Swarm -&gt; Hierarchical:</strong> When you're running Swarm daily and need persistence<br><br>\n          <strong>Detection:</strong> The pain of current level &gt; cost of next level setup."
    },
    {
      "id": "ana-33",
      "type": "analogy",
      "linkedSection": "migration",
      "title": "Migration = Moving apartments",
      "content": "<strong>Stay:</strong> Known space, but cramped (Single with context limits)<br>\n          <strong>Upgrade:</strong> More space, but moving cost (Subagents setup)<br>\n          <strong>Big move:</strong> Different city, new life (Hierarchical investment)<br><br>\n          <em>Don't move to a mansion when you need 10% more space. Upgrade incrementally.</em>"
    }
  ]
}