{
  "items": [
    {
      "id": "inv-1",
      "type": "inversion",
      "linkedSection": "essence",
      "title": "What if we didn't standardize vocabulary?",
      "content": "<strong>You'd get:</strong> Each pattern uses different terms. \"Worker\" in Ralph means something different than Gas Town. Reading multiple sources becomes translation work.<br><br>\n          <strong>Why this fails:</strong> Compound learning breaks. Knowledge from Ralph doesn't transfer to Gas Town.<br>\n          <strong>Hidden constraint revealed:</strong> Vocabulary IS the substrate of pattern composition."
    },
    {
      "id": "min-2",
      "type": "minimal",
      "linkedSection": "essence",
      "title": "The irreducible vocabulary",
      "content": "<strong>Essential terms:</strong> orchestrator, worker, fresh-context, external-state<br>\n          <strong>Everything else:</strong> Specialization of these four primitives.<br><br>\n          <em>If you understand these four, you can derive the rest.</em>"
    },
    {
      "id": "ana-3",
      "type": "analogy",
      "linkedSection": "essence",
      "title": "Vocabulary = Type System",
      "content": "<code>orchestrator</code> → Interface (defines contract)<br>\n          <code>worker</code> → Implementation (fulfills contract)<br>\n          <code>state containers</code> → Data structures<br>\n          <code>Iron Law</code> → Compiler enforcement<br><br>\n          <em>If you've designed type systems, you already understand this vocabulary's structure.</em>"
    },
    {
      "id": "inv-4",
      "type": "invariant",
      "linkedSection": "core",
      "title": "INV-001: Separation of Concerns",
      "content": "The Iron Law is INV-001 applied to agents. Ralph, Gas Town, CC Mirror, and Panopticon ALL enforce this same separation.<br><br>\n          <strong>Why it matters:</strong> Every pattern that works respects this boundary. Every failure mode traces back to violating it."
    },
    {
      "id": "con-5",
      "type": "constraint",
      "linkedSection": "core",
      "title": "Iron Law -> FIVE downstream terms",
      "content": "<strong>ROOT:</strong> Orchestrators can't execute; workers can't coordinate<br>\n          -&gt; Need separate vocabulary for each role<br>\n          -&gt; Need explicit tool permissions per role<br>\n          -&gt; Need state containers to bridge roles<br>\n          -&gt; Need model selection to match role<br>\n          -&gt; Need preambles to enforce constraints<br><br>\n          <em>One law, entire vocabulary structure.</em>"
    },
    {
      "id": "vio-6",
      "type": "violation",
      "linkedSection": "core",
      "title": "If you let orchestrator write code",
      "content": "<strong>IF:</strong> Orchestrator uses Write/Edit tools<br>\n          <strong>THEN:</strong> Context polluted with implementation details<br>\n          <strong>THEN:</strong> Strategic reasoning capacity lost<br>\n          <strong>THEN:</strong> Task decomposition becomes shallow<br>\n          <strong>FINALLY:</strong> System collapses to single over-burdened agent<br><br>\n          <em>The fix: Never mix roles. The vocabulary exists to make this enforceable.</em>"
    },
    {
      "id": "trade-7",
      "type": "tradeoff",
      "linkedSection": "loops",
      "title": "while-loop vs for-loop",
      "content": "<strong>THE DILEMMA:</strong><br>\n          * <strong>while-loop:</strong> Runs until done, but no cost bound<br>\n          * <strong>for-loop:</strong> Cost-bounded, but may not finish<br><br>\n          <strong>WHY NO PERFECT ANSWER:</strong> You can't know in advance how many iterations a feature needs.<br><br>\n          <em>Heuristic: Use for-loop (25 iterations) for production. Use while-loop only when monitoring actively.</em>"
    },
    {
      "id": "exp-8",
      "type": "expertise",
      "linkedSection": "loops",
      "title": "Understanding fresh-context",
      "content": "<strong>Beginner:</strong> \"Why start fresh each time?\"<br>\n          -&gt; Prevents context rot<br><br>\n          <strong>Intermediate:</strong> \"What's context rot?\"<br>\n          -&gt; Quality degradation at 85%+ context usage<br><br>\n          <strong>Advanced:</strong> \"How do learnings persist?\"<br>\n          -&gt; External state files (progress.txt)<br><br>\n          <strong>Staff:</strong> \"When is fresh-context wrong?\"<br>\n          -&gt; Highly interdependent tasks needing shared state<br><br>\n          <strong>Expert:</strong> \"What's the abstraction?\"<br>\n          -&gt; Stateless compute + stateful storage = scaling pattern"
    },
    {
      "id": "grad-9",
      "type": "gradient",
      "linkedSection": "loops",
      "title": "Context rot progression",
      "content": "<strong>100% -&gt; 90%</strong> (40-60K): Subtle drift, unnoticeable<br>\n          <strong>90% -&gt; 80%</strong> (60-80K): Repetition starts<br>\n          <strong>80% -&gt; 70%</strong> (80-100K): Instructions fade<br>\n          <strong>70% -&gt; CLIFF</strong> (100K+): Hallucinations begin<br><br>\n          <em>Why fresh-context exists: This gradient is invisible until the cliff.</em>"
    },
    {
      "id": "war-10",
      "type": "warstory",
      "linkedSection": "loops",
      "title": "Ryan Carson: Why for-loop won",
      "content": "\"We tried while-loop first. Ran for 47 iterations on a 6-story feature. Burned $45. Could have been 14 iterations, $12.\"<br><br>\n          <strong>Learning:</strong> for-loop (25) with restart beats while-loop without bounds."
    },
    {
      "id": "inf-11",
      "type": "inflection",
      "linkedSection": "state",
      "title": "progress.txt benefit/cost flip",
      "content": "<strong>0-10KB:</strong> Pure benefit (learnings compound)<br>\n          <strong>10-20KB:</strong> Diminishing returns<br>\n          <strong>20-30KB:</strong> Neutral (reading = thinking cost)<br>\n          <strong>30KB+:</strong> Net negative (context waste)<br><br>\n          <strong>THE INFLECTION:</strong> ~20KB<br>\n          <strong>BEFORE:</strong> \"Always append. Never delete.\"<br>\n          <strong>AFTER:</strong> \"Archive to AGENTS.md. Start fresh.\""
    },
    {
      "id": "inv-12",
      "type": "inversion",
      "linkedSection": "state",
      "title": "What if we used agent memory instead of files?",
      "content": "<strong>You'd design:</strong> Persistent agent memory, no progress.txt<br>\n          <strong>Why this fails:</strong> Context rot + no auditability + can't restart<br>\n          <strong>Hidden constraint revealed:</strong> Files are memory you can inspect, reset, and version control"
    },
    {
      "id": "comp-13",
      "type": "composition",
      "linkedSection": "state",
      "title": "prd.json + AGENTS.md",
      "content": "<strong>Works:</strong> prd.json for this session's tasks, AGENTS.md for cross-session learnings<br>\n          <strong>The pattern:</strong> Ephemeral work tracking + permanent knowledge = complete state management<br><br>\n          <em>AGENTS.md gets patterns that succeeded. prd.json resets each feature.</em>"
    },
    {
      "id": "hor-14",
      "type": "horizon",
      "linkedSection": "state",
      "title": "AGENTS.md value over time",
      "content": "<strong>Week 1:</strong> \"Why maintain another file?\"<br>\n          <strong>Month 1:</strong> \"Oh, that gotcha again...\"<br>\n          <strong>Month 3:</strong> \"AGENTS.md prevents 50% of re-learning\"<br>\n          <strong>Month 6:</strong> \"This IS the institutional memory\"<br><br>\n          <em>Don't judge AGENTS.md in week 1.</em>"
    },
    {
      "id": "ana-15",
      "type": "analogy",
      "linkedSection": "agents",
      "title": "Agent Types = Software Architecture Roles",
      "content": "<code>orchestrator</code> -&gt; Controller/Coordinator<br>\n          <code>worker</code> -&gt; Service/Worker<br>\n          <code>subagent</code> -&gt; Microservice<br>\n          <code>polecat</code> -&gt; Stateful service<br>\n          <code>crew</code> -&gt; Serverless function<br><br>\n          <em>If you've designed distributed systems, you already understand agent architecture.</em>"
    },
    {
      "id": "eff-16",
      "type": "effect",
      "linkedSection": "agents",
      "title": "At 5+ workers, coordination dominates",
      "content": "<strong>1-2 workers:</strong> Orchestrator overhead negligible<br>\n          <strong>3-4 workers:</strong> Coordination starts to matter<br>\n          <strong>5+ workers:</strong> Orchestrator becomes the bottleneck<br><br>\n          <strong>THRESHOLD:</strong> ~5 parallel workers<br>\n          <em>Past this, need hierarchical orchestration (mayor pattern).</em>"
    },
    {
      "id": "exp-17",
      "type": "expertise",
      "linkedSection": "agents",
      "title": "Model Selection Understanding",
      "content": "<strong>Beginner:</strong> \"Always use the best model\"<br>\n          -&gt; Opus for everything (expensive)<br><br>\n          <strong>Intermediate:</strong> \"Match model to task type\"<br>\n          -&gt; Opus/Sonnet/Haiku matrix<br><br>\n          <strong>Advanced:</strong> \"Why does role determine model?\"<br>\n          -&gt; Strategy needs depth; execution needs speed<br><br>\n          <strong>Staff:</strong> \"When to break the matrix?\"<br>\n          -&gt; Novel domains, debugging, architecture decisions<br><br>\n          <strong>Expert:</strong> \"What's the meta-pattern?\"<br>\n          -&gt; Model selection IS resource allocation"
    },
    {
      "id": "war-18",
      "type": "warstory",
      "linkedSection": "agents",
      "title": "Steve Yegge: Why Gas Town has so many roles",
      "content": "\"We kept hitting edge cases. Workers need supervision? Add witness. Quality slipping? Add dogs. Coordination tangling? Add deacon.\"<br><br>\n          <strong>Learning:</strong> Each Gas Town role emerged from a failure mode, not theoretical design."
    },
    {
      "id": "vio-19",
      "type": "violation",
      "linkedSection": "gotchas",
      "title": "If you confuse progress.txt with AGENTS.md",
      "content": "<strong>IF:</strong> Put permanent patterns in progress.txt<br>\n          <strong>THEN:</strong> Patterns deleted when session ends<br>\n          <strong>THEN:</strong> Next project re-discovers same gotchas<br>\n          <strong>THEN:</strong> No institutional memory builds<br>\n          <strong>FINALLY:</strong> Every feature starts from zero<br><br>\n          <em>The fix: Session learnings -&gt; progress.txt. Permanent patterns -&gt; AGENTS.md.</em>"
    },
    {
      "id": "inv-20",
      "type": "inversion",
      "linkedSection": "gotchas",
      "title": "What if acceptance criteria could be vague?",
      "content": "<strong>You'd allow:</strong> \"Works correctly\", \"Good UX\"<br>\n          <strong>Why this fails:</strong> Agent can't verify. Claims done without evidence.<br>\n          <strong>Hidden constraint revealed:</strong> Verification requires objective criteria. The vocabulary enforces this."
    },
    {
      "id": "fron-21",
      "type": "frontier",
      "linkedSection": "gotchas",
      "title": "UNSOLVED: Vocabulary versioning",
      "content": "<strong>The question:</strong> How do we track when terms change meaning across pattern versions?<br>\n          <strong>Why it's hard:</strong> No central authority. Patterns evolve independently.<br>\n          <strong>Current best practice:</strong> This document as canonical reference. Updates when conflicts emerge."
    },
    {
      "id": "trade-22",
      "type": "tradeoff",
      "linkedSection": "hard",
      "title": "Precision vs Accessibility",
      "content": "<strong>THE DILEMMA:</strong><br>\n          * <strong>Precise terms:</strong> Clear but intimidating for newcomers<br>\n          * <strong>Casual terms:</strong> Accessible but ambiguous<br><br>\n          <strong>WHY NO PERFECT ANSWER:</strong> Different audiences need different things.<br><br>\n          <em>Heuristic: Use precise terms in docs. Accept casual terms in conversation. Gently redirect.</em>"
    },
    {
      "id": "con-23",
      "type": "constraint",
      "linkedSection": "hard",
      "title": "Multiple sources -> vocabulary debt",
      "content": "<strong>ROOT:</strong> Ralph, Gas Town, Panopticon developed independently<br>\n          -&gt; Each chose terms that made sense locally<br>\n          -&gt; Terms overlap but don't align perfectly<br>\n          -&gt; Readers must translate between sources<br>\n          -&gt; Translation errors cause bugs<br>\n          -&gt; This dictionary exists to pay down that debt"
    },
    {
      "id": "grad-24",
      "type": "gradient",
      "linkedSection": "hard",
      "title": "Term confusion severity",
      "content": "<strong>Minor:</strong> Using \"worker\" when you mean \"subagent\" (structural vs behavioral)<br>\n          <strong>Medium:</strong> Confusing progress.txt scope with AGENTS.md<br>\n          <strong>Severe:</strong> Letting orchestrator write code (Iron Law violation)<br>\n          <strong>Critical:</strong> No shared vocabulary on team (no composability)<br><br>\n          <em>Most confusion is minor. Iron Law violations are critical.</em>"
    },
    {
      "id": "alt-25",
      "type": "alternative",
      "linkedSection": "when",
      "title": "If this vocabulary doesn't fit",
      "content": "<strong>Need simpler terms?</strong><br>\n          -&gt; Use casual conversation, redirect to precise when debugging<br><br>\n          <strong>Need domain-specific terms?</strong><br>\n          -&gt; Layer domain vocab on top, map to base vocabulary<br><br>\n          <strong>Team using different terms?</strong><br>\n          -&gt; Create team glossary mapping to this canonical reference"
    },
    {
      "id": "inv-26",
      "type": "invariant",
      "linkedSection": "when",
      "title": "This vocabulary enables pattern composition",
      "content": "<strong>Ralph + Gas Town + Panopticon</strong> all use these same terms.<br><br>\n          <strong>Why it matters:</strong> You can combine patterns because they share vocabulary. \"Spawn a polecat\" works whether you're in Ralph or Gas Town.<br><br>\n          <em>Shared vocabulary = composable patterns.</em>"
    },
    {
      "id": "hor-27",
      "type": "horizon",
      "linkedSection": "when",
      "title": "Vocabulary investment payoff",
      "content": "<strong>Day 1:</strong> \"Why learn all these terms?\"<br>\n          <strong>Week 1:</strong> \"These definitions are useful\"<br>\n          <strong>Month 1:</strong> \"I can read any pattern doc now\"<br>\n          <strong>Month 3:</strong> \"I can compose patterns myself\"<br>\n          <strong>Month 6:</strong> \"I teach others the vocabulary\"<br><br>\n          <em>Vocabulary is infrastructure. Investment pays off exponentially.</em>"
    },
    {
      "id": "min-28",
      "type": "minimal",
      "linkedSection": "when",
      "title": "The 10 terms you must know",
      "content": "1. <code>orchestrator</code><br>\n          2. <code>worker</code><br>\n          3. <code>fresh-context</code><br>\n          4. <code>external-state</code><br>\n          5. <code>iteration</code><br>\n          6. <code>stop-condition</code><br>\n          7. <code>progress.txt</code><br>\n          8. <code>prd.json</code><br>\n          9. <code>context-rot</code><br>\n          10. <code>Iron Law</code><br><br>\n          <em>Everything else is specialization of these ten.</em>"
    }
  ]
}