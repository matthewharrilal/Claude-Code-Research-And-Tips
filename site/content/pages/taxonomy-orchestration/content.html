<!--
═══════════════════════════════════════════════════════════════════════════════
INLINE THREADING HEADER — Phase 2B
File: docs-spa/content/pages/taxonomy-orchestration/content.html
Tier: C | Batch: 13 | Generated: 2026-02-06

1. WHY THIS EXISTS
Rendered HTML content page for the taxonomy-orchestration synthesis document.

3. STATUS
ACTIVE

5. BUILT ON
Extracted from synthesis/taxonomy-orchestration.md by content extraction scripts.

8. CONSUMED BY
docs-spa/app/(docs)/synthesis/taxonomy-orchestration/page.tsx renders this content via dangerouslySetInnerHTML.

═══════════════════════════════════════════════════════════════════════════════
END INLINE THREADING HEADER
═══════════════════════════════════════════════════════════════════════════════
-->

      <!-- Section 1: ESSENCE -->
      <section id="essence" data-activity="essence">
        <div class="essence-box">
          <div class="essence-label">Essence (15 words)</div>
          <div class="essence-text">Ten pattern categories enable AI orchestration from single loops to factory-scale autonomous systems.</div>
        </div>
      </section>

      <!-- Section 2: CORE TAXONOMY -->
      <section id="core-abstraction" data-activity="core">
        <h2 class="section-title">
          <span class="section-number">2</span>
          The 10-Category Orchestration Taxonomy
        </h2>

        <div class="core-abstraction">
          <div class="core-philosophy">"Every orchestration pattern is a bet on where to put state and who coordinates work."</div>

          <table class="taxonomy-table" style="margin-top: 20px;">
            <thead>
              <tr>
                <th>Category</th>
                <th>Patterns</th>
                <th>Core Concern</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><span class="pattern-badge loop">Loop</span></td>
                <td>Ralph, Compounding Ralph, Dr. Ralph, Lisa, Zeroshot, Kanban</td>
                <td>Fresh context iteration</td>
              </tr>
              <tr>
                <td><span class="pattern-badge multi">Multi-Agent</span></td>
                <td>Panopticon, CC Mirror, Gas Town, Orchestra, AI-Maestro</td>
                <td>Parallel coordination</td>
              </tr>
              <tr>
                <td><span class="pattern-badge isolation">Isolation</span></td>
                <td>Domain isolation, Branch-based, Git worktree, Directory ownership</td>
                <td>Conflict prevention</td>
              </tr>
              <tr>
                <td><span class="pattern-badge communication">Communication</span></td>
                <td>File handoffs, Git handoffs, Docker volumes, MCP Agent Mail, FIFO pipes</td>
                <td>Agent messaging</td>
              </tr>
              <tr>
                <td><span class="pattern-badge architecture">Architecture</span></td>
                <td>Hub-and-Spoke, Peer-to-Peer, Factory</td>
                <td>Structural topology</td>
              </tr>
              <tr>
                <td><span class="pattern-badge memory">Memory</span></td>
                <td>Hierarchical, Dynamic imports, Artifact-based, Agent-specific context</td>
                <td>State persistence</td>
              </tr>
              <tr>
                <td><span class="pattern-badge verification">Verification</span></td>
                <td>CI Green, Browser automation, Multi-phase, Cross-agent</td>
                <td>Quality gates</td>
              </tr>
              <tr>
                <td><span class="pattern-badge monitoring">Monitoring</span></td>
                <td>Claude HUD, rpai, Health metrics, Distributed tracing, Anomaly detection</td>
                <td>Observability</td>
              </tr>
              <tr>
                <td><span class="pattern-badge recovery">Recovery</span></td>
                <td>Checkpointing, Graceful degradation, Dead letter queue, Circuit breaker</td>
                <td>Failure handling</td>
              </tr>
              <tr>
                <td><span class="pattern-badge resource">Resource</span></td>
                <td>Model selection, Task queues, Auto-scaling, Caching, Token tracking</td>
                <td>Cost optimization</td>
              </tr>
            </tbody>
          </table>

          <div class="core-anchor">10 categories. 50+ patterns. One cohesive system for AI orchestration.</div>
        </div>

        <p class="text-text-secondary mb-6">
          This taxonomy organizes every known orchestration pattern into 10 categories based on the problem they solve. Most production systems combine patterns from 3-5 categories. The key insight: patterns in one category often require supporting patterns from others.
        </p>
      </section>

      <!-- Section 3: LOOP-BASED PATTERNS -->
      <section id="ralph-core" data-activity="loops">
        <h2 class="section-title">
          <span class="section-number">3</span>
          Loop-Based Patterns
        </h2>

        <p class="text-text-secondary mb-6">
          Loop patterns run Claude repeatedly with fresh context until a completion condition is met. This is the foundational category—most autonomous systems are loops at their core.
        </p>

        <div class="pattern-card">
          <div class="pattern-card-title">
            <span class="pattern-badge loop">Loop</span>
            Ralph Wiggum (Core Pattern)
          </div>
          <div class="pattern-card-source">Source: Geoffrey Huntley (ghuntley.com/ralph) | Popularized by: @mattpocockuk, @ryancarson</div>
          <div class="pattern-card-description">
            A bash loop that runs Claude Code repeatedly with fresh context until a completion condition is met. Each iteration gets a clean slate but has access to git history and file-based memory.
          </div>

          <div class="code-block">
            <button class="copy-btn" onclick="copyCodeBlock(this)">
              <i data-lucide="copy" class="w-3 h-3"></i>
              Copy
            </button>
            <pre><span class="keyword">for</span> (( i=1; i&lt;=$MAX_ITERATIONS; i++ )); <span class="keyword">do</span>
  claude <span class="string">"Review prd.json... If complete, output PROMISE COMPLETE HERE"</span>
  <span class="keyword">if</span> grep -q <span class="string">"PROMISE COMPLETE HERE"</span> output.txt; <span class="keyword">then</span> <span class="keyword">break</span>; <span class="keyword">fi</span>
<span class="keyword">done</span></pre>
          </div>

          <div class="pattern-card-best-for">
            <strong>Best For:</strong> Overnight feature shipping, autonomous development pipelines, tasks with verifiable completion criteria
          </div>
        </div>

        <h3 class="subsection-title" id="ralph-variants">The 6 Ralph Variants</h3>

        <table class="taxonomy-table">
          <thead>
            <tr>
              <th>Variant</th>
              <th>Source</th>
              <th>Key Enhancement</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>Compounding Ralph</strong></td>
              <td>@ryancarson</td>
              <td>References archived PRDs and learnings for cross-session compounding</td>
            </tr>
            <tr>
              <td><strong>Marathon Ralph</strong></td>
              <td>@stephen_rayner</td>
              <td>Extended Ralph for building entire apps with full SDLC methodology</td>
            </tr>
            <tr>
              <td><strong>Dr. Ralph</strong></td>
              <td>@MikeEndale</td>
              <td>Multi-phase with 80%+ confidence thresholds before advancing</td>
            </tr>
            <tr>
              <td><strong>Lisa</strong></td>
              <td>@petruarakiss</td>
              <td>Enhanced logging and progress tracking capabilities</td>
            </tr>
            <tr>
              <td><strong>Zeroshot</strong></td>
              <td>@Eivind1384955</td>
              <td>Streamlined "next gen" execution</td>
            </tr>
            <tr>
              <td><strong>Kanban Loop</strong></td>
              <td>Derived</td>
              <td>Single agent picks from task board until empty</td>
            </tr>
          </tbody>
        </table>

        <div class="decision-box">
          <div class="decision-why">WHY FRESH CONTEXT PER ITERATION?</div>
          <div class="decision-reasoning">
            At 80K tokens, Claude's quality degrades—instructions get lost, contradictions appear. This "context rot" is transformer physics, not a bug. Fresh context beats accumulated context because you get peak quality every iteration.
          </div>
          <div class="decision-implication">
            <div class="decision-implication-label">What this means for you</div>
            <div class="text-text-secondary text-sm">
              Accept that each iteration "forgets" the previous. If you need memory, persist it in files (progress.txt, prd.json). If quality drops in late iterations, restart—don't debug.
            </div>
          </div>
        </div>

        <div class="decision-box">
          <div class="decision-why">WHY EXTERNAL STATE (FILES)?</div>
          <div class="decision-reasoning">
            If each iteration is a fresh Claude with no memory, progress must persist externally. Git commits, prd.json (task tracking), and progress.txt (learnings) form the "database" that survives restarts.
          </div>
          <div class="decision-implication">
            <div class="decision-implication-label">What this means for you</div>
            <div class="text-text-secondary text-sm">
              If it's not in a file, it doesn't exist. Every learning must be written to progress.txt. Every status change must update prd.json. Git history is your audit trail.
            </div>
          </div>
        </div>
      </section>

      <!-- Section 4: MULTI-AGENT PATTERNS -->
      <section id="panopticon" data-activity="multiagent">
        <h2 class="section-title">
          <span class="section-number">4</span>
          Multi-Agent Patterns
        </h2>

        <p class="text-text-secondary mb-6">
          Multi-agent patterns coordinate multiple Claude instances working in parallel. This is where orchestration gets interesting—and complex.
        </p>

        <div class="pattern-card">
          <div class="pattern-card-title">
            <span class="pattern-badge multi">Multi</span>
            Personal Panopticon
          </div>
          <div class="pattern-card-source">Source: @mollycantillon</div>
          <div class="pattern-card-description">
            Run 8+ parallel isolated Claude Code instances, each owning a life/work domain. Achieve "self-legibility" across all personal data through domain specialization.
          </div>

          <div class="code-block">
            <button class="copy-btn" onclick="copyCodeBlock(this)">
              <i data-lucide="copy" class="w-3 h-3"></i>
              Copy
            </button>
            <pre><span class="comment"># Each terminal is an isolated domain</span>
~/nox        <span class="comment"># Company/product</span>
~/metrics    <span class="comment"># Analytics/data</span>
~/email      <span class="comment"># Communications</span>
~/growth     <span class="comment"># Marketing/acquisition</span>
~/trades     <span class="comment"># Personal finance</span>
~/health     <span class="comment"># Fitness/wellness</span>
~/writing    <span class="comment"># Content creation</span>
~/personal   <span class="comment"># Life admin</span></pre>
          </div>

          <div class="pattern-card-best-for">
            <strong>Best For:</strong> Managing multiple life domains, founders/solopreneurs, "personal surveillance reversal"
          </div>
        </div>

        <div class="pattern-card" id="cc-mirror">
          <div class="pattern-card-title">
            <span class="pattern-badge multi">Multi</span>
            CC Mirror (Hub-and-Spoke Orchestration)
          </div>
          <div class="pattern-card-source">Source: @nummanali | Repo: github.com/numman-ali/cc-mirror</div>
          <div class="pattern-card-description">
            Central orchestrator that delegates to specialized worker agents, never touching code directly. The orchestrator is the CONDUCTOR—agents play the instruments.
          </div>

          <div class="architecture-diagram">
            <pre>╔═══════════════════════════════════════════════════════════════╗
║  YOU DO NOT WRITE CODE. YOU DO NOT RUN COMMANDS.              ║
║  YOU DO NOT EXPLORE CODEBASES.                                ║
║  You are the CONDUCTOR. Your agents play the instruments.     ║
╚═══════════════════════════════════════════════════════════════╝

Tool Ownership:
┌─────────────┬─────────────────────────────────────────────────┐
│ Orchestrator│ Read (1-2 files), Task*, AskUserQuestion        │
├─────────────┼─────────────────────────────────────────────────┤
│ Workers     │ Read, Write, Edit, Bash, Glob, Grep, WebFetch   │
└─────────────┴─────────────────────────────────────────────────┘</pre>
          </div>

          <div class="pattern-card-best-for">
            <strong>Best For:</strong> Production apps with dependencies, task dependency management, clear separation of concerns
          </div>
        </div>

        <div class="pattern-card" id="gas-town">
          <div class="pattern-card-title">
            <span class="pattern-badge multi">Multi</span>
            Gas Town (Agent Factory)
          </div>
          <div class="pattern-card-source">Source: @steve_yegge | Repo: github.com/steveyegge/gastown</div>
          <div class="pattern-card-description">
            Not just agents, but an agent FACTORY with specialized roles and town-level coordination. "You just make up features, design them, file the implementation plans, and sling work around to your polecats and crew."
          </div>

          <div class="architecture-diagram">
            <pre>Gas Town (~/.gt)
├── HQ (town-level management)
├── Rigs (project repos)
│   └── Witness (per-rig observer)
├── Workers
│   ├── Mayor (town coordination)
│   ├── Deacon (monitoring/handshakes)
│   ├── Dogs (quality gates)
│   ├── Refinery (task decomposition)
│   ├── Polecat (named persistent workers)
│   └── Crew (ephemeral workers)
└── Overseer (YOU - human with inbox)</pre>
          </div>

          <table class="taxonomy-table">
            <thead>
              <tr>
                <th>Role</th>
                <th>Purpose</th>
              </tr>
            </thead>
            <tbody>
              <tr><td><strong>Mayor</strong></td><td>Town-wide coordination</td></tr>
              <tr><td><strong>Deacon</strong></td><td>Monitoring and handshakes between agents</td></tr>
              <tr><td><strong>Dogs</strong></td><td>Quality gates and watchdogs</td></tr>
              <tr><td><strong>Refinery</strong></td><td>Task decomposition</td></tr>
              <tr><td><strong>Polecat</strong></td><td>Named persistent workers</td></tr>
              <tr><td><strong>Crew</strong></td><td>Ephemeral workers</td></tr>
            </tbody>
          </table>

          <div class="pattern-card-best-for">
            <strong>Best For:</strong> Massive scale (10+ agents), Stage 7+ dev evolution, significant budget, tmux proficiency
          </div>
        </div>

        <h3 class="subsection-title">Other Multi-Agent Patterns</h3>

        <table class="taxonomy-table">
          <thead>
            <tr>
              <th>Pattern</th>
              <th>Source</th>
              <th>Core Mechanism</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>Infinite Orchestra</strong></td>
              <td>@0xSero</td>
              <td>Self-improving orchestrator in Docker with worker profiles</td>
            </tr>
            <tr>
              <td><strong>Parallel Task Executor</strong></td>
              <td>@LLMJunky</td>
              <td>Parse plan, extract tasks, execute in parallel subagents</td>
            </tr>
            <tr>
              <td><strong>AI-Maestro</strong></td>
              <td>Community</td>
              <td>Container-isolated parallelism with shared Docker volumes</td>
            </tr>
            <tr>
              <td><strong>Adversarial Speccing</strong></td>
              <td>CC Mirror derived</td>
              <td>Two subagents debate: Architect proposes, Critic challenges</td>
            </tr>
            <tr>
              <td><strong>AutoGen-Style Group Chat</strong></td>
              <td>Microsoft adapted</td>
              <td>Multiple agents share conversation, taking turns</td>
            </tr>
            <tr>
              <td><strong>LangGraph State Machine</strong></td>
              <td>LangGraph adapted</td>
              <td>Multi-agent workflows as explicit state machines</td>
            </tr>
          </tbody>
        </table>
      </section>

      <!-- Section 5: ARCHITECTURE PATTERNS -->
      <section id="hub-spoke" data-activity="architecture">
        <h2 class="section-title">
          <span class="section-number">5</span>
          Architecture Patterns
        </h2>

        <p class="text-text-secondary mb-6">
          Architecture patterns define the structural topology of multi-agent systems. Your choice here determines coordination overhead, failure modes, and scalability limits.
        </p>

        <div class="pattern-card">
          <div class="pattern-card-title">
            <span class="pattern-badge architecture">Architecture</span>
            Hub-and-Spoke
          </div>
          <div class="pattern-card-description">
            Central orchestrator delegates to specialized workers. Clear hierarchy, predictable workflow, centralized monitoring.
          </div>

          <div class="architecture-diagram">
            <pre>         ┌─────────────────┐
         │   Orchestrator  │
         └────────┬────────┘
                  │
    ┌─────────────┼─────────────┐
    │             │             │
    ▼             ▼             ▼
┌───────┐   ┌───────┐   ┌───────┐
│ Coder │   │ Tester│   │ Docs  │
└───────┘   └───────┘   └───────┘</pre>
          </div>

          <div class="pattern-card-best-for">
            <strong>Best For:</strong> Clear task decomposition, predictable workflow, centralized monitoring<br>
            <strong>Examples:</strong> CC Mirror, Gas Town (Deacon role)
          </div>
        </div>

        <div class="pattern-card" id="peer-to-peer">
          <div class="pattern-card-title">
            <span class="pattern-badge architecture">Architecture</span>
            Peer-to-Peer
          </div>
          <div class="pattern-card-description">
            Agents communicate directly without central coordinator. Emergent collaboration, flexible workflows, resilient to single points of failure.
          </div>

          <div class="architecture-diagram">
            <pre>┌───────┐     ┌───────┐
│Agent 1│◀───►│Agent 2│
└───────┘     └───────┘
    ▲             ▲
    └──────┬──────┘
           ▼
      ┌───────┐
      │Agent 3│
      └───────┘</pre>
          </div>

          <div class="pattern-card-best-for">
            <strong>Best For:</strong> Emergent collaboration, flexible workflows, resilience<br>
            <strong>Challenges:</strong> Harder to monitor, potential for deadlocks
          </div>
        </div>

        <div class="pattern-card" id="factory">
          <div class="pattern-card-title">
            <span class="pattern-badge architecture">Architecture</span>
            Factory Pattern
          </div>
          <div class="pattern-card-description">
            Not just agents, but an agent FACTORY that produces specialized workers on demand. Named persistent workers (Polecats) + ephemeral workers (Crew) + role-based specialization.
          </div>

          <div class="pattern-card-best-for">
            <strong>Best For:</strong> Massive scale, dynamic workloads, teams that need to spawn agents programmatically<br>
            <strong>Example:</strong> Gas Town
          </div>
        </div>
      </section>

      <!-- Section 6: SUPPORT PATTERNS -->
      <section id="communication" data-activity="support">
        <h2 class="section-title">
          <span class="section-number">6</span>
          Support Patterns
        </h2>

        <p class="text-text-secondary mb-6">
          Support patterns provide the infrastructure for orchestration: how agents communicate, remember, verify, and recover.
        </p>

        <h3 class="subsection-title">Communication Patterns</h3>

        <table class="taxonomy-table">
          <thead>
            <tr>
              <th>Pattern</th>
              <th>Mechanism</th>
              <th>Best For</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>File-Based Handoffs</strong></td>
              <td><code>handoff-agent1-to-agent2.json</code> with context</td>
              <td>Simple async coordination</td>
            </tr>
            <tr>
              <td><strong>Git-Based Handoffs</strong></td>
              <td>progress.txt, prd.json, git commits</td>
              <td>Ralph pattern, audit trail</td>
            </tr>
            <tr>
              <td><strong>Docker Volume Handoffs</strong></td>
              <td>Shared volume for message passing</td>
              <td>Container-isolated agents</td>
            </tr>
            <tr>
              <td><strong>MCP Agent Mail</strong></td>
              <td>Email-like interface for agent collaboration</td>
              <td>Natural "agent village" behavior</td>
            </tr>
            <tr>
              <td><strong>FIFO Pipes</strong></td>
              <td><code>mkfifo</code> for real-time messaging</td>
              <td>Low-latency coordination</td>
            </tr>
            <tr>
              <td><strong>Event Bus</strong></td>
              <td>File-based events: <code>task-complete-*.json</code></td>
              <td>Event-driven architecture</td>
            </tr>
            <tr>
              <td><strong>Consensus Protocol</strong></td>
              <td>Proposals, voting, 66% threshold</td>
              <td>Multi-agent decisions</td>
            </tr>
          </tbody>
        </table>

        <h3 class="subsection-title" id="memory">Memory Patterns</h3>

        <div class="pattern-card">
          <div class="pattern-card-title">
            <span class="pattern-badge memory">Memory</span>
            Hierarchical Memory Architecture
          </div>
          <div class="pattern-card-description">
            4-layer memory hierarchy from enterprise policy down to agent-specific context.
          </div>

          <div class="code-block">
            <button class="copy-btn" onclick="copyCodeBlock(this)">
              <i data-lucide="copy" class="w-3 h-3"></i>
              Copy
            </button>
            <pre><span class="comment"># Layer 1: Enterprise Policy</span>
/Library/Application Support/ClaudeCode/CLAUDE.md
<span class="comment"># Organization-wide security policies, compliance</span>

<span class="comment"># Layer 2: Project Memory</span>
./CLAUDE.md <span class="keyword">or</span> ./.claude/CLAUDE.md
<span class="comment"># Architecture decisions, coding standards</span>

<span class="comment"># Layer 3: Modular Rules</span>
./.claude/rules/*.md
<span class="comment"># Path-specific rules with frontmatter targeting</span>

<span class="comment"># Layer 4: Personal + Local</span>
~/.claude/CLAUDE.md    <span class="comment"># User global</span>
./CLAUDE.local.md      <span class="comment"># Project local, gitignored</span></pre>
          </div>
        </div>

        <h3 class="subsection-title" id="verification">Verification Patterns</h3>

        <table class="taxonomy-table">
          <thead>
            <tr>
              <th>Pattern</th>
              <th>Mechanism</th>
              <th>When to Use</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>CI Green Enforcement</strong></td>
              <td>Tests + types must pass every commit</td>
              <td>Every Ralph iteration</td>
            </tr>
            <tr>
              <td><strong>Browser Automation</strong></td>
              <td>Playwright MCP for UI verification</td>
              <td>UI stories</td>
            </tr>
            <tr>
              <td><strong>Multi-Phase Protocol</strong></td>
              <td>80%+ confidence before advancing phases</td>
              <td>Dr. Ralph variant</td>
            </tr>
            <tr>
              <td><strong>Cross-Agent Verification</strong></td>
              <td>Integration tests after multi-agent merge</td>
              <td>Parallel development</td>
            </tr>
          </tbody>
        </table>

        <h3 class="subsection-title">Monitoring Patterns</h3>

        <table class="taxonomy-table">
          <thead>
            <tr>
              <th>Tool</th>
              <th>Features</th>
              <th>Source</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>Claude HUD</strong></td>
              <td>Context remaining, tool execution, subagent status, todo progress</td>
              <td>@jarrodwatts</td>
            </tr>
            <tr>
              <td><strong>rpai</strong></td>
              <td>tmux multi-agent manager with TUI</td>
              <td>@radoslav11</td>
            </tr>
            <tr>
              <td><strong>Agent Health Metrics</strong></td>
              <td>Heartbeat, context usage, tokens, errors, git state</td>
              <td>Advanced patterns</td>
            </tr>
            <tr>
              <td><strong>Distributed Tracing</strong></td>
              <td>Trace context propagation with span tracking</td>
              <td>Advanced patterns</td>
            </tr>
            <tr>
              <td><strong>Anomaly Detection</strong></td>
              <td>Resource, behavioral, coordination anomalies</td>
              <td>Advanced patterns</td>
            </tr>
          </tbody>
        </table>

        <h3 class="subsection-title">Failure Recovery Patterns</h3>

        <table class="taxonomy-table">
          <thead>
            <tr>
              <th>Pattern</th>
              <th>Mechanism</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>Checkpointing</strong></td>
              <td>Periodic save of agent state (git state, progress files)</td>
            </tr>
            <tr>
              <td><strong>Graceful Degradation</strong></td>
              <td>Retry → Fallback model → Requeue → Human escalation → Safe shutdown</td>
            </tr>
            <tr>
              <td><strong>Dead Letter Queue</strong></td>
              <td>Tasks failing 3+ times move to human review</td>
            </tr>
            <tr>
              <td><strong>Circuit Breaker</strong></td>
              <td>CLOSED → OPEN (failing fast) → HALF_OPEN (testing recovery)</td>
            </tr>
            <tr>
              <td><strong>Semantic Merge</strong></td>
              <td>Use Claude to resolve conflicts by understanding intent</td>
            </tr>
            <tr>
              <td><strong>Optimistic Locking</strong></td>
              <td>Record expected file version, validate before commit</td>
            </tr>
          </tbody>
        </table>
      </section>

      <!-- Section 7: GOTCHAS -->
      <section id="gotchas" data-activity="gotchas">
        <h2 class="section-title">
          <span class="section-number">7</span>
          Gotchas
        </h2>

        <p class="text-text-secondary mb-6">
          Common pitfalls when implementing orchestration patterns, with concrete symptoms and fixes.
        </p>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Ralph Loop Never Completes
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Loop runs to max iterations without outputting "PROMISE COMPLETE"</div>
          <div class="gotcha-detail"><strong>Cause:</strong> Tasks too large, missing completion condition, or stuck on failing tests</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Check <code>prd.json</code> for incomplete tasks. Check <code>progress.txt</code> for repeated failure patterns. Verify tests actually pass. Split oversized tasks.</div>
        </div>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Orchestrator Context Exhaustion
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> CC Mirror orchestrator loses track of tasks, quality degrades</div>
          <div class="gotcha-detail"><strong>Cause:</strong> Orchestrator doing too much, not delegating properly</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Enable auto-compact. Orchestrator should ONLY use: Read (1-2 files), Task*, AskUserQuestion. Never write code or run commands.</div>
        </div>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Git Worktree Conflicts
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Cannot create worktree, or worktrees have stale branches</div>
          <div class="gotcha-detail"><strong>Cause:</strong> Branch already checked out elsewhere, or cleanup incomplete</div>
          <div class="gotcha-detail"><strong>Fix:</strong> <code>git worktree list</code> → <code>git worktree prune</code> → <code>git worktree remove</code> → Create with new branch</div>
        </div>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Handoff Files Not Being Read
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Agent doesn't see context from other agents</div>
          <div class="gotcha-detail"><strong>Cause:</strong> Wrong file path, timing issue, or JSON format error</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Verify location (<code>ls ~/shared/handoff-*.json</code>). Validate JSON (<code>cat handoff.json | jq .</code>). Add explicit read instruction in prompt.</div>
        </div>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Anomaly Detection False Positives
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> System flags normal behavior as anomalous</div>
          <div class="gotcha-detail"><strong>Cause:</strong> Thresholds too aggressive, normal patterns not baselined</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Adjust context threshold 90%→95% for complex tasks. Increase circular edit detection window. Baseline normal token consumption. Add task-specific exemptions.</div>
        </div>
      </section>

      <!-- Section 8: WHAT'S HARD -->
      <section id="hard" data-activity="hard">
        <h2 class="section-title">
          <span class="section-number">8</span>
          What's Hard
        </h2>

        <p class="text-text-secondary mb-6">
          Fundamental tensions in orchestration that require judgment, not formulas.
        </p>

        <div class="hard-box">
          <div class="hard-title">
            <i data-lucide="flame" class="w-4 h-4"></i>
            Hub-and-Spoke vs. Peer-to-Peer
          </div>
          <div class="hard-detail"><strong>The tension:</strong> Hub-and-spoke provides clear coordination but creates a single point of failure and bottleneck. Peer-to-peer is resilient but hard to monitor and prone to deadlocks.</div>
          <div class="hard-detail"><strong>Symptoms:</strong> Hub overloaded with coordination overhead. OR peer agents stepping on each other, no one knowing global state.</div>
          <div class="hard-detail"><strong>Mitigation:</strong> Start with hub-and-spoke until you understand your workflow. Add peer-to-peer elements only for specific, well-bounded interactions. Never go full peer-to-peer without extensive monitoring.</div>
        </div>

        <div class="hard-box">
          <div class="hard-title">
            <i data-lucide="flame" class="w-4 h-4"></i>
            Parallel Efficiency vs. Conflict Risk
          </div>
          <div class="hard-detail"><strong>The tension:</strong> More parallel agents = faster throughput. But more agents = more potential for conflicts, merge hell, and coordination overhead.</div>
          <div class="hard-detail"><strong>Symptoms:</strong> Merge conflicts consuming more time than parallelism saves. OR serial execution bottleneck when work is clearly parallelizable.</div>
          <div class="hard-detail"><strong>Mitigation:</strong> Use isolation patterns (git worktrees, directory ownership) to prevent conflicts. Start with 2-3 parallel agents, not 10. Measure conflict rate before adding more.</div>
        </div>

        <div class="hard-box">
          <div class="hard-title">
            <i data-lucide="flame" class="w-4 h-4"></i>
            Fresh Context vs. Accumulated Knowledge
          </div>
          <div class="hard-detail"><strong>The tension:</strong> Fresh context avoids rot but loses learnings. Accumulated context has richer memory but degrades over time. There is no solution that gets both.</div>
          <div class="hard-detail"><strong>Symptoms:</strong> Late iterations repeat mistakes (memory loss). OR late iterations produce garbage (context rot).</div>
          <div class="hard-detail"><strong>Mitigation:</strong> Fresh context + progress.txt is the best known tradeoff. Keep progress.txt under 20KB. Accept that some re-learning is the cost of fresh context.</div>
        </div>

        <div class="hard-box">
          <div class="hard-title">
            <i data-lucide="flame" class="w-4 h-4"></i>
            Autonomous Operation vs. Human Oversight
          </div>
          <div class="hard-detail"><strong>The tension:</strong> The whole point is autonomous operation. But fully autonomous systems can compound errors, ship bad code, or run up costs overnight.</div>
          <div class="hard-detail"><strong>Symptoms:</strong> Morning reveals 20 bad commits. OR you're intervening so often it's not really autonomous.</div>
          <div class="hard-detail"><strong>Mitigation:</strong> Start with HOTL (Human On The Loop) variants. Add verification layers (CI, browser automation). Graduate to full autonomy only for well-understood, repeatable tasks.</div>
        </div>
      </section>

      <!-- Section 9: PATTERN SELECTION -->
      <section id="selection" data-activity="selection">
        <h2 class="section-title">
          <span class="section-number">9</span>
          Pattern Selection Guide
        </h2>

        <p class="text-text-secondary mb-6">
          Match your scenario to the right pattern. Most production systems combine 3-5 patterns.
        </p>

        <table class="taxonomy-table">
          <thead>
            <tr>
              <th>Scenario</th>
              <th>Recommended Pattern</th>
              <th>Why</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Single feature, overnight</td>
              <td><strong>Ralph Loop</strong></td>
              <td>Fresh context, verifiable completion</td>
            </tr>
            <tr>
              <td>Multiple life domains</td>
              <td><strong>Panopticon</strong></td>
              <td>Isolated directories, no cross-contamination</td>
            </tr>
            <tr>
              <td>Team project, parallel features</td>
              <td><strong>Git worktrees + branch discipline</strong></td>
              <td>Isolation + shared codebase</td>
            </tr>
            <tr>
              <td>Complex architecture work</td>
              <td><strong>Hub-and-spoke with specialized workers</strong></td>
              <td>Clear coordination, expert specialization</td>
            </tr>
            <tr>
              <td>Production app with dependencies</td>
              <td><strong>CC Mirror</strong></td>
              <td>Task dependency management, orchestrator discipline</td>
            </tr>
            <tr>
              <td>Massive scale (10+ agents)</td>
              <td><strong>Gas Town factory</strong></td>
              <td>Named workers, role specialization, town coordination</td>
            </tr>
            <tr>
              <td>High-stakes decisions</td>
              <td><strong>Adversarial Speccing</strong></td>
              <td>Architect + Critic debate improves quality</td>
            </tr>
            <tr>
              <td>Self-improving system</td>
              <td><strong>Infinite Orchestra</strong></td>
              <td>24/7 Docker, self-improvement loop</td>
            </tr>
          </tbody>
        </table>

        <div class="when-grid">
          <div class="when-use">
            <div class="when-title">
              <i data-lucide="check" class="w-5 h-5"></i>
              START WITH ORCHESTRATION WHEN
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>Work is clearly parallelizable (multiple independent features)</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>You have verification layers (tests, CI, browser automation)</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>Tasks have clear completion criteria</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>You're comfortable with tmux/terminal multiplexing</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>You have budget for higher token usage</span>
            </div>
          </div>

          <div class="when-not">
            <div class="when-title">
              <i data-lucide="x" class="w-5 h-5"></i>
              AVOID ORCHESTRATION WHEN
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>Single session can complete the work (don't over-engineer)</span>
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>Tight coupling between components (conflicts inevitable)</span>
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>No automated verification (garbage will compound)</span>
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>Exploratory work with undefined end (use single session)</span>
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>Cost-constrained environment (orchestration burns tokens)</span>
            </div>
          </div>
        </div>

        <h3 class="subsection-title">Task Sizing Guidelines</h3>

        <table class="taxonomy-table">
          <thead>
            <tr>
              <th>Size</th>
              <th>Characteristics</th>
              <th>Example</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>Too Small</strong></td>
              <td>Overhead exceeds value</td>
              <td>"Add a comment to line 42"</td>
            </tr>
            <tr>
              <td><strong>Just Right</strong></td>
              <td>One context window, verifiable</td>
              <td>"Implement User model with these fields"</td>
            </tr>
            <tr>
              <td><strong>Too Large</strong></td>
              <td>Context collapse risk</td>
              <td>"Build the entire backend"</td>
            </tr>
          </tbody>
        </table>

        <div class="decision-box">
          <div class="decision-why">TASK SIZE SWEET SPOT</div>
          <div class="decision-reasoning">
            ~100-500 lines of code change. ~1-3 files modified. ~30-60 minutes equivalent human time. Clear success criteria. If the task description is longer than the expected code change, you've decomposed too far.
          </div>
        </div>

        <h3 class="subsection-title">Quick Reference Commands</h3>

        <div class="code-block">
          <button class="copy-btn" onclick="copyCodeBlock(this)">
            <i data-lucide="copy" class="w-3 h-3"></i>
            Copy
          </button>
          <pre><span class="comment"># Ralph Loop</span>
./ralph.sh 25

<span class="comment"># Git Worktree</span>
git worktree add ../feature-branch feature-branch

<span class="comment"># CC Mirror</span>
npx cc-mirror quick --provider mirror --name mclaude

<span class="comment"># Claude HUD</span>
/plugin install claude-hud

<span class="comment"># rpai (tmux manager)</span>
cargo install rpai &amp;&amp; rpai

<span class="comment"># Gas Town</span>
go install github.com/steveyegge/gastown/cmd/gt@latest</pre>
        </div>
      </section>

    