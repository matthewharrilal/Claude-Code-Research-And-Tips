{
  "items": [
    {
      "id": "min-1",
      "type": "minimal",
      "linkedSection": "essence",
      "title": "The irreducible spawning decision",
      "content": "<strong>Essential:</strong> \"Would 50 failed tool calls ruin my main conversation?\"<br>\n          <strong>If YES:</strong> Spawn.<br>\n          <strong>If NO:</strong> Main agent handles it.<br><br>\n          <em>Everything else is refinement for efficiency.</em>"
    },
    {
      "id": "inv-2",
      "type": "inversion",
      "linkedSection": "essence",
      "title": "What if subagents had ZERO overhead?",
      "content": "<strong>You'd design:</strong> Spawn for everything. Maximum parallelism.<br>\n          <strong>Why this fails:</strong> 5-10K token overhead is transformer physics, not a bug. Context initialization is irreducible.<br>\n          <strong>Hidden constraint:</strong> Spawning IS the overhead made explicit."
    },
    {
      "id": "war-3",
      "type": "warstory",
      "linkedSection": "essence",
      "title": "Dan Shipper: 4-Terminal Workflow",
      "content": "Frontend, Backend, Test, Docs - all running in parallel. \"Compound engineering is spawning specialists for what they're good at.\""
    },
    {
      "id": "con-4",
      "type": "constraint",
      "linkedSection": "core",
      "title": "One constraint -> FIVE decisions",
      "content": "<strong>ROOT:</strong> Context windows are finite (200K max)<br>\n          -&gt; Main context is precious (can't waste it)<br>\n          -&gt; Isolation requires separate instances (subagents)<br>\n          -&gt; Each instance has initialization overhead (5-10K)<br>\n          -&gt; Overhead must be justified (&gt;15K work)<br>\n          -&gt; Simple tasks stay in main agent"
    },
    {
      "id": "inf-5",
      "type": "inflection",
      "linkedSection": "core",
      "title": "When spawning flips from cost to benefit",
      "content": "<strong>0-5K tokens:</strong> Pure waste (overhead dominates)<br>\n          <strong>5-15K tokens:</strong> Marginal (depends on context pollution risk)<br>\n          <strong>15-20K tokens:</strong> Break-even point<br>\n          <strong>20K+ tokens:</strong> Net benefit (isolation value exceeds overhead)<br><br>\n          <strong>THE INFLECTION:</strong> ~15-20K tokens of focused work"
    },
    {
      "id": "ana-6",
      "type": "analogy",
      "linkedSection": "core",
      "title": "Subagents = Microservices",
      "content": "Network call overhead -&gt; Token overhead<br>\n          Service isolation -&gt; Context isolation<br>\n          API contracts -&gt; Task prompts<br>\n          Service mesh -&gt; Coordination files<br><br>\n          <em>If you've designed microservices, you understand spawn trade-offs.</em>"
    },
    {
      "id": "inv-7",
      "type": "invariant",
      "linkedSection": "core",
      "title": "INV-003: External state > internal memory",
      "content": "Ralph, Gas Town, CC Mirror, Subagent Spawning all share this. Coordination files ARE the memory. If it's not in a file, it doesn't exist for the next agent."
    },
    {
      "id": "vio-8",
      "type": "violation",
      "linkedSection": "decisions",
      "title": "If you skip the worker preamble",
      "content": "<strong>IF:</strong> You skip \"Do NOT spawn sub-agents\"<br>\n          <strong>THEN:</strong> Subagent might spawn its own subagent<br>\n          <strong>THEN:</strong> Sub-subagent might spawn another<br>\n          <strong>THEN:</strong> Recursive depth, control lost<br>\n          <strong>FINALLY:</strong> $50+ bill from one \"simple\" task<br><br>\n          <em>The fix: Worker preamble is non-negotiable.</em>"
    },
    {
      "id": "trade-9",
      "type": "tradeoff",
      "linkedSection": "decisions",
      "title": "The Model Selection Dilemma",
      "content": "<strong>Haiku:</strong> Cheap ($0.01-0.05), but weak for complex reasoning<br>\n          <strong>Sonnet:</strong> Balanced ($0.10-0.50), good for most tasks<br>\n          <strong>Opus:</strong> Powerful ($0.50-2.00), but 60x more expensive<br><br>\n          <strong>Heuristic:</strong> If retrying with Sonnet is cheaper than one Opus call, start with Sonnet."
    },
    {
      "id": "exp-10",
      "type": "expertise",
      "linkedSection": "decisions",
      "title": "Spawning decision understanding",
      "content": "<strong>Beginner:</strong> \"When do I spawn?\" -&gt; Context pollution test<br>\n          <strong>Intermediate:</strong> \"Which model?\" -&gt; Match to task complexity<br>\n          <strong>Advanced:</strong> \"Parallel or sequential?\" -&gt; Dependency analysis<br>\n          <strong>Staff:</strong> \"What's minimal overhead?\" -&gt; Only pass what's needed<br>\n          <strong>Expert:</strong> \"Cross-pattern coordination?\" -&gt; File-based state machines"
    },
    {
      "id": "hor-11",
      "type": "horizon",
      "linkedSection": "decisions",
      "title": "How spawning perception evolves",
      "content": "<strong>Task 1:</strong> \"Spawning feels like overhead\"<br>\n          <strong>Task 5:</strong> \"My main context is getting messy\"<br>\n          <strong>Task 10:</strong> \"Spawning keeps my main conversation clean\"<br>\n          <strong>Task 20:</strong> \"Spawn early, spawn often for complex work\"<br><br>\n          <em>Don't judge spawning value from a single task.</em>"
    },
    {
      "id": "comp-12",
      "type": "composition",
      "linkedSection": "patterns",
      "title": "Sequential + Parallel Hybrid",
      "content": "<strong>Works:</strong> Research (seq) -&gt; Plan (seq) -&gt; (Frontend || Backend || Tests) parallel<br>\n          <strong>Danger:</strong> Parallel agents must have clear file ownership<br>\n          <strong>Recommendation:</strong> Parallelize only after dependencies resolved"
    },
    {
      "id": "war-13",
      "type": "warstory",
      "linkedSection": "patterns",
      "title": "Boris Cherny: Multiple Reviewers Pattern",
      "content": "Security reviewer, performance reviewer, maintainability reviewer, correctness reviewer - all parallel. Different perspectives from context isolation. \"Adversarial review benefits from separate contexts.\""
    },
    {
      "id": "ana-14",
      "type": "analogy",
      "linkedSection": "patterns",
      "title": "Coordination files = Gas Town components",
      "content": "<strong>Main Agent</strong> = The Mayor (orchestrator)<br>\n          <strong>status.json</strong> = The Inbox (work queue)<br>\n          <strong>handoff-notes.md</strong> = The Refinery (persistent memory)<br>\n          <strong>Each Subagent</strong> = A Polecat (stateless worker)"
    },
    {
      "id": "grad-15",
      "type": "gradient",
      "linkedSection": "patterns",
      "title": "How parallel coordination fails",
      "content": "<strong>100%:</strong> Agents working on truly independent files<br>\n          <strong>80%:</strong> Minor overlaps in shared utilities<br>\n          <strong>60%:</strong> Same file, different sections (risky)<br>\n          <strong>40%:</strong> Same file, overlapping lines (conflict)<br>\n          <strong>CLIFF:</strong> Git conflicts, lost work, merge nightmares<br><br>\n          <em>The gradient is invisible until the merge.</em>"
    },
    {
      "id": "eff-16",
      "type": "effect",
      "linkedSection": "patterns",
      "title": "At 5+ parallel agents, coordination cost dominates",
      "content": "<strong>Implication:</strong> File-based coordination works for 2-4 agents. Beyond 5, you need real orchestration (CC Mirror, Gas Town).<br><br>\n          <strong>Threshold:</strong> ~4-5 parallel agents before coordination overhead exceeds parallelism benefit"
    },
    {
      "id": "vio-17",
      "type": "violation",
      "linkedSection": "path",
      "title": "If you skip structured completion (Step 9)",
      "content": "<strong>IF:</strong> Subagent doesn't output structured completion<br>\n          <strong>THEN:</strong> Main agent can't tell if it finished<br>\n          <strong>THEN:</strong> Waits indefinitely or checks too early<br>\n          <strong>THEN:</strong> Timeout, incomplete work, confusion<br>\n          <strong>FINALLY:</strong> Manual intervention required<br><br>\n          <em>The fix: Require <code>{\"status\": \"complete\", \"files_modified\": [...]}</code></em>"
    },
    {
      "id": "hor-18",
      "type": "horizon",
      "linkedSection": "path",
      "title": "Status files seem like overhead... until they save you",
      "content": "<strong>First spawn:</strong> \"Why write status.json?\"<br>\n          <strong>Third spawn:</strong> \"Which agent is doing what?\"<br>\n          <strong>Fifth spawn:</strong> \"Thank god for status.json\"<br>\n          <strong>Tenth spawn:</strong> \"Status files are the orchestration\""
    },
    {
      "id": "exp-19",
      "type": "expertise",
      "linkedSection": "path",
      "title": "Path understanding depth",
      "content": "<strong>Beginner:</strong> \"What's the flow?\" -&gt; Steps 1-11<br>\n          <strong>Intermediate:</strong> \"Where are the failure points?\" -&gt; Steps 7, 9<br>\n          <strong>Advanced:</strong> \"How to detect stuck agents?\" -&gt; 3+ attempts without progress<br>\n          <strong>Staff:</strong> \"How to scale?\" -&gt; File-based state machines<br>\n          <strong>Expert:</strong> \"What's minimal?\" -&gt; Skip status files for simple cases"
    },
    {
      "id": "inv-20",
      "type": "inversion",
      "linkedSection": "gotchas",
      "title": "What if over-spawning had no cost?",
      "content": "<strong>You'd design:</strong> Spawn for every tool call. Maximum isolation.<br>\n          <strong>Why this fails:</strong> Tokens cost money. At $15/1M output for Opus, a 10K spawn costs $0.15.<br>\n          <strong>Hidden constraint:</strong> Cost IS the forcing function for spawn decisions."
    },
    {
      "id": "inf-21",
      "type": "inflection",
      "linkedSection": "gotchas",
      "title": "When context pollution flips from manageable to crisis",
      "content": "<strong>0-30K context:</strong> Everything fits, no problem<br>\n          <strong>30-60K context:</strong> Getting crowded, quality stable<br>\n          <strong>60-100K context:</strong> Early instructions fading<br>\n          <strong>100K+ context:</strong> Context rot, quality collapse<br><br>\n          <strong>THE INFLECTION:</strong> ~60K tokens before spawn becomes critical"
    },
    {
      "id": "fron-22",
      "type": "frontier",
      "linkedSection": "gotchas",
      "title": "UNSOLVED: Automatic spawn decision",
      "content": "<strong>The question:</strong> Can we automatically decide when to spawn based on task complexity prediction?<br>\n          <strong>Why hard:</strong> Task complexity isn't known until execution.<br>\n          <strong>Current:</strong> Human judgment + heuristics. No automation yet."
    },
    {
      "id": "trade-23",
      "type": "tradeoff",
      "linkedSection": "gotchas",
      "title": "Context Pollution vs. Overhead",
      "content": "<strong>Don't spawn:</strong> Risk main context pollution (long-term cost)<br>\n          <strong>Always spawn:</strong> Pay overhead for everything (immediate cost)<br>\n          <strong>The dilemma:</strong> Pollution cost is invisible until it compounds<br><br>\n          <strong>Heuristic:</strong> When in doubt about pollution, spawn. Overhead is visible and bounded."
    },
    {
      "id": "con-24",
      "type": "constraint",
      "linkedSection": "hard",
      "title": "Why perfect parallelism is impossible",
      "content": "<strong>ROOT:</strong> Real codebases have dependencies<br>\n          -&gt; Dependencies create ordering requirements<br>\n          -&gt; Ordering limits parallelism<br>\n          -&gt; Parallel agents need coordination<br>\n          -&gt; Coordination has overhead<br>\n          -&gt; Maximum useful parallelism is ~4-5 agents"
    },
    {
      "id": "grad-25",
      "type": "gradient",
      "linkedSection": "hard",
      "title": "How spawn decision quality degrades",
      "content": "<strong>Fresh engineer:</strong> Clear judgment, follows heuristics<br>\n          <strong>Tired engineer:</strong> Shortcuts, \"just spawn everything\"<br>\n          <strong>Rushed engineer:</strong> \"I'll handle it in main\" -&gt; pollution<br>\n          <strong>Burned engineer:</strong> Random decisions, inconsistent<br><br>\n          <em>Spawn decisions degrade with fatigue. Automate where possible.</em>"
    },
    {
      "id": "war-26",
      "type": "warstory",
      "linkedSection": "hard",
      "title": "Kaushik Gopal: Planning-First Methodology",
      "content": "\"Always plan before spawning implementation workers. Research subagent -&gt; Architect subagent -&gt; Human approval -&gt; Worker subagents. The planning phase catches 80% of coordination issues.\""
    },
    {
      "id": "alt-27",
      "type": "alternative",
      "linkedSection": "when",
      "title": "If spawning isn't right",
      "content": "<strong>Need stateful coordination?</strong> -&gt; Ralph (file-based loops)<br>\n          <strong>Need factory-scale parallel?</strong> -&gt; CC Mirror (multi-agent orchestration)<br>\n          <strong>Need human review gates?</strong> -&gt; HOTL patterns<br>\n          <strong>Simple task?</strong> -&gt; Main agent directly"
    },
    {
      "id": "ana-28",
      "type": "analogy",
      "linkedSection": "when",
      "title": "Spawning level = Thread pool sizing",
      "content": "<strong>No spawning</strong> = Single-threaded (simple, limited)<br>\n          <strong>Occasional spawn</strong> = Thread pool (managed parallelism)<br>\n          <strong>Aggressive spawn</strong> = Unlimited threads (chaos, expensive)<br><br>\n          <em>If you've tuned thread pools, you understand spawn decisions.</em>"
    },
    {
      "id": "inv-29",
      "type": "inversion",
      "linkedSection": "when",
      "title": "What if you never spawned?",
      "content": "<strong>You'd get:</strong> One agent doing everything sequentially<br>\n          <strong>Why this fails:</strong> Context pollution accumulates. At 100K tokens, quality collapses.<br>\n          <strong>Hidden insight:</strong> Spawning IS context management. Not spawning is implicit decision to pollute."
    },
    {
      "id": "inv-30",
      "type": "invariant",
      "linkedSection": "when",
      "title": "INV-001: Fresh context > extended sessions",
      "content": "Subagent spawning is this principle applied at task level. Ralph applies it at iteration level. Both recognize: context quality degrades, fresh starts restore it."
    }
  ]
}