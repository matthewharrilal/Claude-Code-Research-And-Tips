{
  "items": [
    {
      "id": "inv-1",
      "type": "inversion",
      "linkedSection": "essence",
      "title": "What if there were no grammar rules?",
      "content": "<strong>You'd design:</strong> Ad-hoc compositions, patterns invented per-project.<br>\n          <strong>Why this fails:</strong> Same failure modes rediscovered repeatedly. No shared vocabulary.<br>\n          <strong>Hidden constraint revealed:</strong> Grammar is accumulated debugging wisdom."
    },
    {
      "id": "min-2",
      "type": "minimal",
      "linkedSection": "essence",
      "title": "The irreducible core",
      "content": "<code style=\"background: #f4f4f5; padding: 2px 6px; border-radius: 4px; font-size: 12px;\">pattern ::= primitive | composition</code><br>\n          <strong>Essential:</strong> Everything is either atomic or composed.<br>\n          <strong>Everything else:</strong> Rules for valid composition."
    },
    {
      "id": "ana-3",
      "type": "analogy",
      "linkedSection": "essence",
      "title": "Grammar = Type System for Patterns",
      "content": "Type errors → Syntax errors<br>\n          Compile time → Design time<br>\n          Runtime crash → Pattern failure<br>\n          Type inference → Pattern recognition<br><br>\n          <em>If you understand type systems, you understand this grammar.</em>"
    },
    {
      "id": "con-4",
      "type": "constraint",
      "linkedSection": "core",
      "title": "One constraint → ALL operators",
      "content": "<strong>ROOT:</strong> Patterns must compose reliably<br>\n          → Need explicit composition rules<br>\n          → Need operator semantics (what each means)<br>\n          → Need validity constraints (what's allowed)<br>\n          → Need error taxonomy (what goes wrong)<br>\n          → Need templates (known-good compositions)"
    },
    {
      "id": "inv-5",
      "type": "invariant",
      "linkedSection": "core",
      "title": "Cross-Pattern DNA",
      "content": "<strong>Ralph:</strong> Loop + State + Quality (Template 1)<br>\n          <strong>CC Mirror:</strong> Fork-Join + Workers (Template 2)<br>\n          <strong>Gas Town:</strong> Nested + Hierarchical (Template 5)<br><br>\n          <em>All major patterns are compositions in this grammar.</em>"
    },
    {
      "id": "grad-6",
      "type": "gradient",
      "linkedSection": "core",
      "title": "How syntax errors manifest",
      "content": "<strong>Obvious:</strong> Pattern doesn't start (immediate crash)<br>\n          <strong>Subtle:</strong> Pattern runs but produces garbage<br>\n          <strong>Hidden:</strong> Pattern works until edge case<br>\n          <strong>Catastrophic:</strong> Pattern corrupts state silently<br><br>\n          <em>Most grammar violations are subtle or hidden.</em>"
    },
    {
      "id": "war-7",
      "type": "warstory",
      "linkedSection": "core",
      "title": "The God Worker Incident",
      "content": "Team built a \"smart worker\" that could spawn sub-workers. Context grew unbounded. By iteration 20, the worker had forgotten its original task. <strong>Fix:</strong> Split into orchestrator (spawns) + workers (execute). Grammar violation: Worker ⊃ TaskCreate."
    },
    {
      "id": "trade-8",
      "type": "tradeoff",
      "linkedSection": "decisions",
      "title": "Expressiveness vs. Safety",
      "content": "• <strong>More operators:</strong> Express more patterns, but more ways to compose wrongly<br>\n          • <strong>Fewer operators:</strong> Safer, but can't express some valid patterns<br><br>\n          <em>This grammar chose: 6 operators that cover 95% of use cases.</em>"
    },
    {
      "id": "vio-9",
      "type": "violation",
      "linkedSection": "decisions",
      "title": "If orchestrator uses tools directly",
      "content": "<strong>IF:</strong> Orchestrator writes code instead of delegating<br>\n          <strong>THEN:</strong> Orchestrator context fills with implementation details<br>\n          <strong>THEN:</strong> Orchestrator loses track of overall plan<br>\n          <strong>THEN:</strong> Coordination degrades into ad-hoc execution<br>\n          <strong>FINALLY:</strong> System becomes single-threaded God Worker"
    },
    {
      "id": "exp-10",
      "type": "expertise",
      "linkedSection": "decisions",
      "title": "Understanding role separation",
      "content": "<strong>Beginner:</strong> \"Why can't workers spawn sub-workers?\"<br>\n          <strong>Intermediate:</strong> \"Because coordination belongs to orchestrators\"<br>\n          <strong>Advanced:</strong> \"Because role mixing creates unbounded context\"<br>\n          <strong>Staff:</strong> \"Because the same entity can't optimize for coordination AND execution\""
    },
    {
      "id": "comp-11",
      "type": "composition",
      "linkedSection": "files",
      "title": "Template 1 + Template 2",
      "content": "<strong>Works:</strong> Ralph loop spawning CC Mirror workers for parallel subtasks.<br>\n          <strong>Semantics:</strong> Outer loop (Ralph) nested contains parallel (CC Mirror).<br>\n          <strong>Danger:</strong> Merge conflicts if workers touch overlapping files."
    },
    {
      "id": "ana-12",
      "type": "analogy",
      "linkedSection": "files",
      "title": "Templates = Design Patterns",
      "content": "<strong>Template 1 (Ralph):</strong> Iterator pattern<br>\n          <strong>Template 2 (CC Mirror):</strong> Worker pool pattern<br>\n          <strong>Template 3 (Retry):</strong> Circuit breaker pattern<br>\n          <strong>Template 4 (State Machine):</strong> State pattern<br>\n          <strong>Template 5 (Hierarchical):</strong> Composite pattern"
    },
    {
      "id": "hor-13",
      "type": "horizon",
      "linkedSection": "files",
      "title": "When each template becomes right",
      "content": "<strong>Day 1:</strong> \"Template 1 seems like overkill\"<br>\n          <strong>Week 1:</strong> \"Template 1 saved me from infinite loops\"<br>\n          <strong>Month 1:</strong> \"Template 2 unlocked 3x parallelism\"<br>\n          <strong>Quarter 1:</strong> \"Template 4 state machine prevented 10 edge case bugs\""
    },
    {
      "id": "fron-14",
      "type": "frontier",
      "linkedSection": "files",
      "title": "UNSOLVED: Dynamic composition",
      "content": "Templates are static. What if patterns need to adapt at runtime? No good theory for dynamic recomposition yet. Current approach: restart with different template."
    },
    {
      "id": "inf-15",
      "type": "inflection",
      "linkedSection": "path",
      "title": "When validation saves vs. costs time",
      "content": "<strong>Simple pattern:</strong> Validation overhead &gt; benefit<br>\n          <strong>3+ operators:</strong> Validation starts paying off<br>\n          <strong>Nested composition:</strong> Validation essential<br>\n          <strong>Production system:</strong> Skip validation = guaranteed debugging later<br><br>\n          <strong>THE INFLECTION:</strong> ~3 operators composed"
    },
    {
      "id": "inv-16",
      "type": "inversion",
      "linkedSection": "path",
      "title": "Why checklist format?",
      "content": "<strong>What if prose instead of checklist?</strong><br>\n          You'd read it once, forget most of it, miss violations.<br><br>\n          <strong>Why checklist works:</strong> Forces systematic review. Can be automated. Nothing skipped.<br>\n          <em>Aviation learned this: checklists save lives. Patterns too.</em>"
    },
    {
      "id": "min-17",
      "type": "minimal",
      "linkedSection": "path",
      "title": "The formal grammar distilled",
      "content": "<strong>3 key rules:</strong><br>\n          1. Everything is pattern or composition<br>\n          2. Compositions have specific operators<br>\n          3. Operators have constraints<br><br>\n          <em>The EBNF is just these 3 rules made precise.</em>"
    },
    {
      "id": "vio-18",
      "type": "violation",
      "linkedSection": "gotchas",
      "title": "If you skip isolation (Error 3)",
      "content": "<strong>IF:</strong> Parallel workers share mutable state<br>\n          <strong>THEN:</strong> Race conditions (non-deterministic)<br>\n          <strong>THEN:</strong> Sometimes works, sometimes corrupts<br>\n          <strong>THEN:</strong> Debugging is impossible (non-reproducible)<br>\n          <strong>FINALLY:</strong> \"Works on my machine\" becomes permanent state"
    },
    {
      "id": "grad-19",
      "type": "gradient",
      "linkedSection": "gotchas",
      "title": "Loop Without Termination (Error 4)",
      "content": "<strong>Iteration 1-10:</strong> \"It's working, just slow\"<br>\n          <strong>Iteration 10-50:</strong> \"Still going, must be a big task\"<br>\n          <strong>Iteration 50-100:</strong> \"Something might be wrong...\"<br>\n          <strong>Iteration 100+:</strong> \"$500 API bill, no progress<br><br>\n          <em>The gradient is invisible because each iteration looks like progress.</em>"
    },
    {
      "id": "trade-20",
      "type": "tradeoff",
      "linkedSection": "gotchas",
      "title": "Error 7: Quality Gate Timing",
      "content": "• <strong>Gate before commit:</strong> Safe, but blocks pipeline on failures<br>\n          • <strong>Gate after commit:</strong> Fast, but requires revert capability<br><br>\n          <em>Grammar says: Gate before irreversible actions. \"Irreversible\" depends on your rollback capability.</em>"
    },
    {
      "id": "war-21",
      "type": "warstory",
      "linkedSection": "gotchas",
      "title": "The Late Gate Disaster",
      "content": "Team ran Ralph overnight. Morning: 45 commits, all passing tests. But... tests didn't cover edge cases. Half the commits had subtle bugs. <strong>Cost:</strong> 3 days of manual debugging. <strong>Fix:</strong> Better quality gates (property tests, not just unit tests)."
    },
    {
      "id": "trade-22",
      "type": "tradeoff",
      "linkedSection": "hard",
      "title": "The Expressibility Dilemma",
      "content": "<strong>THE DILEMMA:</strong><br>\n          • Extend grammar: More patterns expressible, but more complexity<br>\n          • Keep grammar small: Simpler, but some patterns can't be expressed<br><br>\n          <strong>WHY NO PERFECT ANSWER:</strong><br>\n          Every new operator multiplies composition possibilities, including invalid ones."
    },
    {
      "id": "exp-23",
      "type": "expertise",
      "linkedSection": "hard",
      "title": "Understanding state explosion",
      "content": "<strong>Beginner:</strong> \"Why limit nesting depth?\"<br>\n          <strong>Intermediate:</strong> \"Because state combinations grow exponentially\"<br>\n          <strong>Advanced:</strong> \"Because testing coverage becomes impossible\"<br>\n          <strong>Staff:</strong> \"Because the system becomes unprovable\"<br>\n          <strong>Expert:</strong> \"Flatten aggressively, accept some inexpressibility\""
    },
    {
      "id": "inf-24",
      "type": "inflection",
      "linkedSection": "hard",
      "title": "When nesting depth becomes unmanageable",
      "content": "<strong>Depth 1:</strong> Sequential or parallel (trivial)<br>\n          <strong>Depth 2:</strong> Loop containing sequence (manageable)<br>\n          <strong>Depth 3:</strong> Conditional within loop within fork (challenging)<br>\n          <strong>Depth 4+:</strong> State space explodes (unmanageable)<br><br>\n          <strong>THE INFLECTION:</strong> Depth 3 is usually the maximum."
    },
    {
      "id": "fron-25",
      "type": "frontier",
      "linkedSection": "hard",
      "title": "UNSOLVED: Termination verification",
      "content": "Halting problem means we can't prove termination in general. Current approach: bounded iteration + timeout + human escalation. Better theoretical foundations needed."
    },
    {
      "id": "inv-26",
      "type": "inversion",
      "linkedSection": "when",
      "title": "What if you used grammar for simple tasks?",
      "content": "• Single-agent task: Grammar adds design overhead<br>\n          • Time spent on composition rules &gt; time saved<br>\n          • Feels like \"architecture astronautics\"<br><br>\n          <strong>Why this fails:</strong> Grammar is for composition. No composition = no grammar needed."
    },
    {
      "id": "alt-27",
      "type": "alternative",
      "linkedSection": "when",
      "title": "If grammar doesn't fit",
      "content": "<strong>Simple task?</strong> → Single Claude session, no composition<br>\n          <strong>Exploratory work?</strong> → Interactive session, iterate on design<br>\n          <strong>Novel pattern?</strong> → Build it first, extract grammar later<br>\n          <strong>Real-time?</strong> → Different paradigm (event-driven, not batch)"
    },
    {
      "id": "ana-28",
      "type": "analogy",
      "linkedSection": "when",
      "title": "When to Use = When to Use Types",
      "content": "<strong>Prototype:</strong> Skip types (skip grammar)<br>\n          <strong>Library code:</strong> Strong types (use grammar)<br>\n          <strong>Production system:</strong> Types essential (grammar essential)<br>\n          <strong>One-off script:</strong> Types overhead (grammar overhead)<br><br>\n          <em>Match rigor to stakes.</em>"
    },
    {
      "id": "hor-29",
      "type": "horizon",
      "linkedSection": "when",
      "title": "How judgment evolves",
      "content": "<strong>Week 1:</strong> \"This grammar is overkill for my use case\"<br>\n          <strong>Month 1:</strong> \"I hit Error 3, wish I'd used the checklist\"<br>\n          <strong>Quarter 1:</strong> \"Grammar is now my default for anything non-trivial\"<br>\n          <strong>Year 1:</strong> \"I think in composition operators now\""
    }
  ]
}