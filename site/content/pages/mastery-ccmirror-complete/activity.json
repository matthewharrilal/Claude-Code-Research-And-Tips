{
  "items": [
    {
      "id": "inv-1",
      "type": "inversion",
      "linkedSection": "essence",
      "title": "What if Anthropic HADN'T built this?",
      "content": "<strong>You'd design:</strong> Custom task queue, custom state machine, custom dependency resolver. Weeks of infrastructure.<br>\n          <strong>Why this fails:</strong> Reinventing what already exists in the binary.<br>\n          <strong>Hidden constraint revealed:</strong> The tools exist. They're just disabled."
    },
    {
      "id": "min-2",
      "type": "minimal",
      "linkedSection": "essence",
      "title": "The irreducible core",
      "content": "<code style=\"background: #f4f4f5; padding: 2px 6px; border-radius: 4px; font-size: 12px;\">npx cc-mirror quick --provider mirror --name mclaude</code><br>\n          <strong>Essential:</strong> The patch. The variant isolation.<br>\n          <strong>Everything else:</strong> Skill refinements, model selection, team configuration."
    },
    {
      "id": "war-3",
      "type": "warstory",
      "linkedSection": "essence",
      "title": "Numman Ali: \"80% of use cases, zero effort\"",
      "content": "\"Simplicity covers 80% with zero effort - mass-market ease. Gas Town is for the 20% complex cases.\""
    },
    {
      "id": "con-4",
      "type": "constraint",
      "linkedSection": "core",
      "title": "One constraint -> FIVE decisions",
      "content": "<strong>ROOT:</strong> Multi-agent coordination is complex<br>\n          -&gt; Must have central orchestrator (prevents chaos)<br>\n          -&gt; Workers must be isolated (prevents pollution)<br>\n          -&gt; Dependencies must be explicit (prevents deadlock)<br>\n          -&gt; Task state must persist (enables recovery)<br>\n          -&gt; Ownership must be tracked (prevents conflicts)"
    },
    {
      "id": "ana-5",
      "type": "analogy",
      "linkedSection": "core",
      "title": "CC Mirror = Kubernetes for Agents",
      "content": "Orchestrator -&gt; Control plane<br>\n          Workers -&gt; Pods<br>\n          Task queue -&gt; Work queue<br>\n          Dependencies -&gt; Resource dependencies<br>\n          Auto-unblock -&gt; Reconciliation loop<br><br>\n          <em>If you've used K8s, you understand CC Mirror's architecture.</em>"
    },
    {
      "id": "vio-6",
      "type": "violation",
      "linkedSection": "core",
      "title": "If you violate the Iron Law",
      "content": "<strong>IF:</strong> Orchestrator writes code directly<br>\n          <strong>THEN:</strong> Implementation details pollute strategic context<br>\n          <strong>THEN:</strong> Orchestrator loses track of task graph<br>\n          <strong>THEN:</strong> Workers get inconsistent instructions<br>\n          <strong>FINALLY:</strong> Entire coordination degrades<br><br>\n          <em>The fix: Conductor conducts. Workers play.</em>"
    },
    {
      "id": "trade-7",
      "type": "tradeoff",
      "linkedSection": "decisions",
      "title": "The Worker Count Dilemma",
      "content": "<strong>Few workers (2-3):</strong> Safe, but slow. Serial bottleneck.<br>\n          <strong>Medium (5-7):</strong> Balanced, but coordination overhead grows.<br>\n          <strong>Many (10+):</strong> Fast, but conflict risk. Context collapse risk.<br><br>\n          <em>Heuristic: Start with 3-5. Add more only if tasks are truly independent.</em>"
    },
    {
      "id": "exp-8",
      "type": "expertise",
      "linkedSection": "decisions",
      "title": "How deep is your understanding?",
      "content": "<strong>Beginner:</strong> \"How do I install CC Mirror?\" -&gt; 3 commands<br>\n          <strong>Intermediate:</strong> \"Why hub-and-spoke?\" -&gt; Prevents chaos<br>\n          <strong>Advanced:</strong> \"When to use which pattern?\" -&gt; Fan-out vs pipeline<br>\n          <strong>Staff:</strong> \"When NOT to use CC Mirror?\" -&gt; Gas Town use cases<br>\n          <strong>Expert:</strong> \"How to combine with Ralph?\" -&gt; Orthogonal patterns"
    },
    {
      "id": "inv-9",
      "type": "inversion",
      "linkedSection": "decisions",
      "title": "What if workers shared memory?",
      "content": "<strong>You'd get:</strong> Worker A's debugging context pollutes Worker B. Worker B hallucinates based on A's partial state.<br>\n          <strong>Why isolation:</strong> Each worker gets clean context. No cross-contamination.<br>\n          <strong>Hidden constraint:</strong> Isolation IS the coordination mechanism."
    },
    {
      "id": "eff-10",
      "type": "effect",
      "linkedSection": "architecture",
      "title": "At scale, task graph becomes the bottleneck",
      "content": "<strong>IMPLICATION:</strong> With 20+ tasks, orchestrator spends more time managing the graph than spawning workers.<br>\n          <strong>THRESHOLD:</strong> ~20 tasks, ~15 workers<br>\n          <strong>MITIGATION:</strong> Batch related tasks. Use map-reduce to aggregate before branching."
    },
    {
      "id": "comp-11",
      "type": "composition",
      "linkedSection": "architecture",
      "title": "CC Mirror + Git Worktrees",
      "content": "<strong>Works:</strong> True parallel isolation. No merge conflicts during execution.<br>\n          <strong>Setup:</strong> <code>git worktree add ../agent-1 task-1-branch</code><br>\n          <strong>Danger:</strong> Merge complexity at the end. Human must resolve.<br>\n          <strong>Recommendation:</strong> Use for tasks that modify overlapping files."
    },
    {
      "id": "grad-12",
      "type": "gradient",
      "linkedSection": "architecture",
      "title": "How orchestrator context degrades",
      "content": "<strong>100% -&gt; 80%</strong> (fresh): Clear task graph awareness<br>\n          <strong>80% -&gt; 60%</strong> (10 workers): Slight drift in priorities<br>\n          <strong>60% -&gt; 40%</strong> (15 workers): Forgets early task decisions<br>\n          <strong>40% -&gt; CLIFF</strong> (20+ workers): Contradictory instructions<br><br>\n          <em>Critical: Use /compact before reaching 70%.</em>"
    },
    {
      "id": "inv-13",
      "type": "invariant",
      "linkedSection": "implementation",
      "title": "CC Mirror, Gas Town, Ralph share INV-003",
      "content": "<strong>External state &gt; internal memory.</strong><br>\n          CC Mirror: Task queue in files. Gas Town: Inbox-based. Ralph: prd.json + progress.txt.<br>\n          All three persist state to filesystem, never rely on agent memory."
    },
    {
      "id": "hor-14",
      "type": "horizon",
      "linkedSection": "implementation",
      "title": "How judgment evolves with experience",
      "content": "<strong>Day 1:</strong> \"Why can't workers share state? That's inefficient!\"<br>\n          <strong>Week 1:</strong> \"Oh, isolation prevents debugging nightmares\"<br>\n          <strong>Month 1:</strong> \"Isolation IS the feature, not a limitation\"<br>\n          <strong>Month 3:</strong> \"I design for isolation by default now\"<br><br>\n          <em>Don't judge isolation by day 1 intuition.</em>"
    },
    {
      "id": "war-15",
      "type": "warstory",
      "linkedSection": "implementation",
      "title": "Demo output: 6 agents, 2 hours",
      "content": "<code>Agent #1 completed! It chose FastAPI (Python)</code><br>\n          Tasks: #1 done, #2-6 in progress or blocked.<br>\n          \"Async agents (6): 1 running, 5 completed\""
    },
    {
      "id": "vio-16",
      "type": "violation",
      "linkedSection": "path",
      "title": "If you skip acceptance criteria",
      "content": "<strong>IF:</strong> Task has vague criteria (\"works correctly\")<br>\n          <strong>THEN:</strong> Worker marks done without verification<br>\n          <strong>THEN:</strong> Dependent tasks start on broken foundation<br>\n          <strong>THEN:</strong> Errors compound through dependency chain<br>\n          <strong>FINALLY:</strong> Entire task graph produces garbage<br><br>\n          <em>Acceptance criteria MUST be verifiable by the agent itself.</em>"
    },
    {
      "id": "ana-17",
      "type": "analogy",
      "linkedSection": "path",
      "title": "Task Path = CI/CD Pipeline",
      "content": "TaskCreate -&gt; Job definition<br>\n          blockedBy -&gt; Stage dependencies<br>\n          Worker execution -&gt; Job runner<br>\n          Acceptance criteria -&gt; Job success criteria<br>\n          Auto-unblock -&gt; Pipeline progression<br><br>\n          <em>If you've built CI/CD, you understand task paths.</em>"
    },
    {
      "id": "inf-18",
      "type": "inflection",
      "linkedSection": "gotchas",
      "title": "When parallel workers flip from help to hurt",
      "content": "<strong>2-5 workers:</strong> Pure benefit (parallel speedup)<br>\n          <strong>5-10 workers:</strong> Diminishing returns (coordination overhead)<br>\n          <strong>10-15 workers:</strong> Neutral (gains = overhead)<br>\n          <strong>15+ workers:</strong> Net negative (context collapse)<br><br>\n          <strong>THE INFLECTION:</strong> ~10 workers<br>\n          <em>Detection: Orchestrator quality degrading? Check worker count.</em>"
    },
    {
      "id": "fron-19",
      "type": "frontier",
      "linkedSection": "gotchas",
      "title": "UNSOLVED: Optimal file locking",
      "content": "<strong>THE QUESTION:</strong> How to prevent file conflicts without serializing all workers?<br>\n          <strong>WHY IT'S HARD:</strong> LLMs can't acquire locks. No atomic operations.<br>\n          <strong>CURRENT BEST PRACTICE:</strong> File ownership in task descriptions. Git worktrees for overlap."
    },
    {
      "id": "inv-20",
      "type": "inversion",
      "linkedSection": "gotchas",
      "title": "What if CC Mirror was officially supported?",
      "content": "<strong>You'd get:</strong> Stable API. Documentation. No breakage on updates.<br>\n          <strong>Why it isn't:</strong> Anthropic disabled it for a reason (unknown). Maybe safety? Maybe not ready?<br>\n          <strong>Hidden constraint:</strong> Using CC Mirror means accepting beta risk. Plan accordingly."
    },
    {
      "id": "trade-21",
      "type": "tradeoff",
      "linkedSection": "hard",
      "title": "CC Mirror vs Gas Town",
      "content": "<strong>CC Mirror:</strong> Simple (80% cases), but limited customization<br>\n          <strong>Gas Town:</strong> Powerful (20% cases), but complex setup<br><br>\n          <strong>WHY NO PERFECT ANSWER:</strong> Simplicity trades off against flexibility. CC Mirror chose simplicity.<br><br>\n          <em>Heuristic: Start with CC Mirror. Escalate to Gas Town when you hit limits.</em>"
    },
    {
      "id": "exp-22",
      "type": "expertise",
      "linkedSection": "hard",
      "title": "Understanding production gaps",
      "content": "<strong>Beginner:</strong> \"CC Mirror does everything!\" -&gt; For demos, yes<br>\n          <strong>Intermediate:</strong> \"Why no cost tracking?\" -&gt; Not built in<br>\n          <strong>Advanced:</strong> \"Can I add observability?\" -&gt; Yes, but custom<br>\n          <strong>Staff:</strong> \"When is custom better?\" -&gt; When you need evals<br>\n          <strong>Expert:</strong> \"CC Mirror OR custom?\" -&gt; CC Mirror + custom layer"
    },
    {
      "id": "con-23",
      "type": "constraint",
      "linkedSection": "hard",
      "title": "Why production gaps exist",
      "content": "<strong>ROOT:</strong> CC Mirror enables disabled features, doesn't add new ones<br>\n          -&gt; No cost tracking (wasn't built)<br>\n          -&gt; No custom observability (wasn't built)<br>\n          -&gt; No evaluation framework (wasn't built)<br>\n          -&gt; No checkpointing (wasn't built)<br>\n          -&gt; What you get: What Anthropic built internally"
    },
    {
      "id": "alt-24",
      "type": "alternative",
      "linkedSection": "when",
      "title": "If CC Mirror isn't right for you",
      "content": "<strong>Need sequential overnight?</strong> -&gt; Ralph Loop<br>\n          <strong>Need 10+ named agents?</strong> -&gt; Gas Town<br>\n          <strong>Need custom observability?</strong> -&gt; Build custom or Gas Town<br>\n          <strong>Need official support?</strong> -&gt; Standard Task() tool<br>\n          <strong>Need domain isolation?</strong> -&gt; Personal Panopticon"
    },
    {
      "id": "comp-25",
      "type": "composition",
      "linkedSection": "when",
      "title": "CC Mirror + Ralph Loop",
      "content": "<strong>Works:</strong> Orthogonal patterns. Ralph for overnight, CC Mirror for parallel within iteration.<br>\n          <strong>How:</strong> Ralph iteration spawns CC Mirror workers for parallel subtasks.<br>\n          <strong>Danger:</strong> Complexity. Only use if both patterns are genuinely needed.<br>\n          <strong>Recommendation:</strong> Master each separately first."
    },
    {
      "id": "war-26",
      "type": "warstory",
      "linkedSection": "when",
      "title": "@nelsonpadil_: Production needs",
      "content": "\"Fine for demos/generic... Production needs: state control, business logic, custom observability, evals.\"<br><br>\n          <em>Know your production requirements before choosing.</em>"
    },
    {
      "id": "hor-27",
      "type": "horizon",
      "linkedSection": "when",
      "title": "How CC Mirror perception evolves",
      "content": "<strong>Week 1:</strong> \"This is magic! Multi-agent in 3 commands!\"<br>\n          <strong>Month 1:</strong> \"I hit some limits but it's still great\"<br>\n          <strong>Month 3:</strong> \"I know exactly when to use it vs alternatives\"<br>\n          <strong>Month 6:</strong> \"CC Mirror is my default for 80% of parallel work\"<br><br>\n          <em>The 80/20 rule becomes clear over time.</em>"
    }
  ]
}