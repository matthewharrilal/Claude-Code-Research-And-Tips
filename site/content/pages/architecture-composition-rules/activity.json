{
  "items": [
    {
      "id": "inv-1",
      "type": "inversion",
      "linkedSection": "essence",
      "title": "What if patterns WERE monoliths?",
      "content": "<strong>You'd design:</strong> One pattern per use case. No shared primitives. No composition.<br>\n          <strong>Why this fails:</strong> You'd reinvent loops, state files, and isolation in every pattern.<br>\n          <strong>Hidden constraint revealed:</strong> Patterns share 80% of their machinery. Composition is inevitable."
    },
    {
      "id": "min-2",
      "type": "minimal",
      "linkedSection": "essence",
      "title": "The irreducible core",
      "content": "<code style=\"background: #f4f4f5; padding: 2px 6px; border-radius: 4px; font-size: 12px;\">Primitive + Operator + Termination</code><br>\n          <strong>Essential:</strong> Something that does work. Something that combines. Something that stops.<br>\n          <strong>Everything else:</strong> Reliability, observability, scale."
    },
    {
      "id": "inv-3",
      "type": "invariant",
      "linkedSection": "essence",
      "title": "INV-001: All patterns share the same primitives",
      "content": "Ralph, CC Mirror, Gas Town, Panopticon all use loops, state files, and isolation.<br>\n          <strong>Why this matters:</strong> Learn primitives once, understand all patterns. The \"pattern\" is just how you wire them."
    },
    {
      "id": "ana-4",
      "type": "analogy",
      "linkedSection": "core",
      "title": "Composition = Programming Language Grammar",
      "content": "Primitives -&gt; Keywords<br>\n          Operators -&gt; Syntax rules<br>\n          Valid compositions -&gt; Legal programs<br>\n          Anti-patterns -&gt; Syntax errors<br><br>\n          <em>If you've learned a programming language, you can learn pattern composition.</em>"
    },
    {
      "id": "exp-5",
      "type": "expertise",
      "linkedSection": "core",
      "title": "How deep is your understanding?",
      "content": "<strong>Beginner:</strong> \"What are the primitives?\" -&gt; The inventory<br>\n          <strong>Intermediate:</strong> \"How do I combine them?\" -&gt; Operators<br>\n          <strong>Advanced:</strong> \"What compositions work?\" -&gt; Compatibility matrix<br>\n          <strong>Staff:</strong> \"Why does this break?\" -&gt; Anti-pattern diagnosis<br>\n          <strong>Expert:</strong> \"Can I invent new patterns?\" -&gt; Yes, from primitives"
    },
    {
      "id": "con-6",
      "type": "constraint",
      "linkedSection": "core",
      "title": "One constraint -> FIVE compositions",
      "content": "<strong>ROOT:</strong> Context window is finite (200K)<br>\n          -&gt; Fresh context needed (Loop primitive)<br>\n          -&gt; State must persist externally (File State primitive)<br>\n          -&gt; Expensive ops need isolation (Subagent primitive)<br>\n          -&gt; Parallel work needs isolation (Worktree primitive)<br>\n          -&gt; Coordination needs separation (Orchestrator/Worker split)"
    },
    {
      "id": "war-7",
      "type": "warstory",
      "linkedSection": "core",
      "title": "Steve Yegge: \"Once you see the primitives...\"",
      "content": "Gas Town looks complex from outside (7 roles, Beads, AgentMail). But it's just primitives + operators. Yegge built it by understanding composition, not by inventing new magic."
    },
    {
      "id": "inv-8",
      "type": "inversion",
      "linkedSection": "equations",
      "title": "What if Ralph didn't use fresh context?",
      "content": "<strong>You'd design:</strong> One long session. No loop. No external state files.<br>\n          <strong>Why this fails:</strong> Context rot at 80K tokens. Quality degrades with accumulated context.<br>\n          <strong>Hidden constraint revealed:</strong> The loop ISN'T overhead - it's the core mechanism."
    },
    {
      "id": "grad-9",
      "type": "gradient",
      "linkedSection": "equations",
      "title": "How Ralph degrades without external state",
      "content": "<strong>Iteration 1-3:</strong> Works fine (context fresh)<br>\n          <strong>Iteration 4-8:</strong> Starts repeating mistakes<br>\n          <strong>Iteration 9-15:</strong> No velocity improvement<br>\n          <strong>Iteration 15+:</strong> Same as iteration 1 forever<br><br>\n          <em>Without external state, there's no learning curve.</em>"
    },
    {
      "id": "comp-10",
      "type": "composition",
      "linkedSection": "equations",
      "title": "CC Mirror + Git Worktrees",
      "content": "<strong>Works:</strong> Task dependencies + conflict-free parallel execution<br>\n          <strong>Caveat:</strong> Task API doesn't know about worktrees natively<br>\n          <strong>Recommendation:</strong> Use file-based handoffs between worktree workers"
    },
    {
      "id": "ana-11",
      "type": "analogy",
      "linkedSection": "equations",
      "title": "Gas Town = Microservices Architecture",
      "content": "Mayor -&gt; API Gateway<br>\n          Polecats -&gt; Stateless workers<br>\n          Beads -&gt; Shared database<br>\n          AgentMail -&gt; Message queue<br><br>\n          <em>If you've built microservices, Gas Town is the same pattern for agents.</em>"
    },
    {
      "id": "trade-12",
      "type": "tradeoff",
      "linkedSection": "operators",
      "title": "Sequential vs. Parallel",
      "content": "<strong>Sequential:</strong> Safe, predictable, but slow. No isolation needed.<br>\n          <strong>Parallel:</strong> Fast, but requires isolation. Race conditions possible.<br><br>\n          <strong>Heuristic:</strong> Start sequential. Profile. Parallelize only proven bottlenecks."
    },
    {
      "id": "vio-13",
      "type": "violation",
      "linkedSection": "operators",
      "title": "If you use parallel without isolation",
      "content": "<strong>IF:</strong> Two agents edit same file in parallel<br>\n          <strong>THEN:</strong> One overwrites the other's work<br>\n          <strong>THEN:</strong> Later agent has corrupted foundation<br>\n          <strong>THEN:</strong> Cascading failures in dependent work<br>\n          <strong>FINALLY:</strong> Hours of debugging for 10 minutes of parallelism<br><br>\n          <em>The fix: Worktrees or explicit file ownership.</em>"
    },
    {
      "id": "exp-14",
      "type": "expertise",
      "linkedSection": "operators",
      "title": "Operator selection depth",
      "content": "<strong>Beginner:</strong> \"Which operator?\" -&gt; Sequential for safety<br>\n          <strong>Intermediate:</strong> \"When parallel?\" -&gt; Independent tasks only<br>\n          <strong>Advanced:</strong> \"When nested?\" -&gt; Expensive ops needing isolation<br>\n          <strong>Staff:</strong> \"When delegation?\" -&gt; When workers shouldn't spawn<br>\n          <strong>Expert:</strong> \"Operator combinations?\" -&gt; Sequential-of-parallel is common"
    },
    {
      "id": "hor-15",
      "type": "horizon",
      "linkedSection": "operators",
      "title": "How operator choice feels over time",
      "content": "<strong>Day 1:</strong> \"Sequential is slow, let's parallelize!\"<br>\n          <strong>Day 3:</strong> \"Why are there merge conflicts everywhere?\"<br>\n          <strong>Week 2:</strong> \"Oh, isolation is the real work, not parallelism\"<br>\n          <strong>Month 1:</strong> \"Sequential was actually fine for 80% of cases\"<br><br>\n          <em>Optimize operators based on data, not intuition.</em>"
    },
    {
      "id": "comp-16",
      "type": "composition",
      "linkedSection": "valid",
      "title": "Ralph + Playwright",
      "content": "<strong>Works:</strong> Visual verification catches UI bugs tests miss<br>\n          <strong>Danger:</strong> Browser context is expensive (5-10x tokens)<br>\n          <strong>Recommendation:</strong> Put Playwright in subagent to protect main context"
    },
    {
      "id": "comp-17",
      "type": "composition",
      "linkedSection": "valid",
      "title": "Ralph + Claude-Mem",
      "content": "<strong>Works:</strong> Cross-session memory without progress.txt bloat<br>\n          <strong>Caveat:</strong> Requires 3-layer retrieval strategy (Search -&gt; Timeline -&gt; Get)<br>\n          <strong>Recommendation:</strong> Inject only relevant memories, not everything"
    },
    {
      "id": "eff-18",
      "type": "effect",
      "linkedSection": "valid",
      "title": "At Tier 3, coordination dominates",
      "content": "<strong>Tier 1-2:</strong> Execution is the bottleneck<br>\n          <strong>Tier 3:</strong> Coordination is the bottleneck<br><br>\n          <strong>Threshold:</strong> ~7 agents, ~5 concurrent tasks<br>\n          <em>Past this point, you need explicit coordination primitives (Beads, AgentMail).</em>"
    },
    {
      "id": "inf-19",
      "type": "inflection",
      "linkedSection": "valid",
      "title": "When Tier 2 becomes insufficient",
      "content": "<strong>1-3 features:</strong> Single Ralph handles it<br>\n          <strong>4-6 features:</strong> Parallel Ralph or CC Mirror<br>\n          <strong>7+ features:</strong> Factory pattern needed<br>\n          <strong>10+ features:</strong> Gas Town or equivalent<br><br>\n          <strong>THE INFLECTION:</strong> ~7 concurrent features<br>\n          <em>Detection: Tasks blocked waiting for other tasks.</em>"
    },
    {
      "id": "vio-20",
      "type": "violation",
      "linkedSection": "antipatterns",
      "title": "If orchestrator uses tools directly",
      "content": "<strong>IF:</strong> Orchestrator calls Write() or Edit() directly<br>\n          <strong>THEN:</strong> Tool output fills orchestrator context<br>\n          <strong>THEN:</strong> Less room for coordination logic<br>\n          <strong>THEN:</strong> Orchestrator becomes unfocused<br>\n          <strong>FINALLY:</strong> Coordination quality degrades, workers go rogue<br><br>\n          <em>The fix: Orchestrators ONLY use TaskCreate/TaskUpdate/Task().</em>"
    },
    {
      "id": "inv-21",
      "type": "inversion",
      "linkedSection": "antipatterns",
      "title": "Why CAN'T workers spawn?",
      "content": "<strong>What if workers could spawn?</strong> Recursive spawning. Worker spawns worker spawns worker.<br>\n          <strong>Why this fails:</strong> Unbounded depth. No clear termination. Cost explosion.<br>\n          <strong>Hidden constraint revealed:</strong> Spawn hierarchy MUST be shallow. Orchestrator -&gt; Worker. No deeper."
    },
    {
      "id": "grad-22",
      "type": "gradient",
      "linkedSection": "antipatterns",
      "title": "How context pollution degrades work",
      "content": "<strong>1 domain:</strong> Full focus, high quality<br>\n          <strong>2 domains:</strong> Slight confusion, still workable<br>\n          <strong>3 domains:</strong> Mixing concerns, errors creep in<br>\n          <strong>4+ domains:</strong> Model confused, wrong domain context in outputs<br><br>\n          <em>Critical: Degradation is invisible until quality cliff.</em>"
    },
    {
      "id": "fron-23",
      "type": "frontier",
      "linkedSection": "antipatterns",
      "title": "UNSOLVED: Anti-pattern detection",
      "content": "<strong>The question:</strong> Can we automatically detect invalid compositions before they fail?<br>\n          <strong>Why it's hard:</strong> Failures are emergent. Components work alone but fail together.<br>\n          <strong>Current practice:</strong> Manual review, incremental testing, pattern knowledge."
    },
    {
      "id": "trade-24",
      "type": "tradeoff",
      "linkedSection": "hard",
      "title": "Isolation vs. Coordination",
      "content": "<strong>Strong isolation:</strong> Clean boundaries, but hard to share state<br>\n          <strong>Weak isolation:</strong> Easy sharing, but race conditions<br>\n          <strong>Shared data plane (Beads):</strong> Balanced, but more infrastructure<br><br>\n          <strong>WHY NO PERFECT ANSWER:</strong> The tension is fundamental. Pick based on coordination needs."
    },
    {
      "id": "war-25",
      "type": "warstory",
      "linkedSection": "hard",
      "title": "Debugging a 5-primitive composition",
      "content": "\"Added Playwright to Ralph. Broke completely. Spent 4 hours debugging. Problem wasn't Playwright - it was progress.txt getting filled with screenshot base64. Subagent isolation fixed it in 10 minutes.\"<br><br>\n          <em>Key learning: Diagnose primitives in isolation before blaming composition.</em>"
    },
    {
      "id": "exp-26",
      "type": "expertise",
      "linkedSection": "hard",
      "title": "Composition debugging depth",
      "content": "<strong>Beginner:</strong> \"It doesn't work\" -&gt; Check each primitive alone<br>\n          <strong>Intermediate:</strong> \"Which primitive broke?\" -&gt; Binary search elimination<br>\n          <strong>Advanced:</strong> \"Is the operator wrong?\" -&gt; Try different wiring<br>\n          <strong>Staff:</strong> \"Is this composition valid?\" -&gt; Check compatibility matrix<br>\n          <strong>Expert:</strong> \"Is this a new anti-pattern?\" -&gt; Document for others"
    },
    {
      "id": "alt-27",
      "type": "alternative",
      "linkedSection": "decision",
      "title": "If you're overwhelmed by composition",
      "content": "<strong>Can't decide?</strong> -&gt; Start with Ralph (simplest)<br>\n          <strong>Need parallelism fast?</strong> -&gt; CC Mirror (built-in coordination)<br>\n          <strong>Building from scratch?</strong> -&gt; Start with primitives, add one at a time<br>\n          <strong>Enterprise scale?</strong> -&gt; Gas Town (maximum capability)"
    },
    {
      "id": "hor-28",
      "type": "horizon",
      "linkedSection": "decision",
      "title": "How pattern choice feels over time",
      "content": "<strong>Week 1:</strong> \"I need the most powerful pattern\"<br>\n          <strong>Month 1:</strong> \"Why is Gas Town so complex to debug?\"<br>\n          <strong>Month 3:</strong> \"Oh, Ralph handles 80% of my cases\"<br>\n          <strong>Month 6:</strong> \"I compose patterns based on actual need now\"<br><br>\n          <em>Don't over-engineer. Start simple, compose when needed.</em>"
    },
    {
      "id": "inv-29",
      "type": "invariant",
      "linkedSection": "decision",
      "title": "INV-007: Simpler compositions are more reliable",
      "content": "Ralph, CC Mirror, Gas Town, Panopticon all follow this: minimum primitives for the job.<br>\n          <strong>Why this matters:</strong> Every added primitive is a failure point. Composition complexity is not free."
    }
  ]
}