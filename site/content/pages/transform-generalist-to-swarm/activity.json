{
  "items": [
    {
      "id": "inv-1",
      "type": "inversion",
      "linkedSection": "essence",
      "title": "What if context DIDN'T dilute?",
      "content": "<strong>You'd design:</strong> One mega-agent for all domains. Load everything.<br>\n          <strong>Why this fails:</strong> Transformer attention is finite. Quality degrades with context size.<br>\n          <strong>Hidden constraint revealed:</strong> Domain specialization isn't preference, it's physics."
    },
    {
      "id": "min-2",
      "type": "minimal",
      "linkedSection": "essence",
      "title": "The irreducible swarm",
      "content": "<strong>Minimal:</strong> Orchestrator + 2 workers with Task tool.<br>\n          <strong>Essential:</strong> Orchestrator never codes. Workers never spawn.<br>\n          <strong>Everything else:</strong> Refinement for reliability and monitoring."
    },
    {
      "id": "inv-3",
      "type": "invariant",
      "linkedSection": "essence",
      "title": "INV-5: Parallelization over single-agent",
      "content": "Swarm, Gas Town, and CC Mirror all share this: when work is decomposable, parallel specialists beat sequential generalists. The invariant forces the architecture."
    },
    {
      "id": "grad-4",
      "type": "gradient",
      "linkedSection": "core",
      "title": "How generalist quality degrades",
      "content": "<strong>Domain 1 (DB):</strong> 70% quality - fresh context<br>\n          <strong>Domain 2 (API):</strong> 60% quality - context filling<br>\n          <strong>Domain 3 (UI):</strong> 40% quality - attention splitting<br>\n          <strong>Domain 4 (Tests):</strong> 20% quality - context exhausted<br><br>\n          <em>Critical: The last domain always suffers most.</em>"
    },
    {
      "id": "ana-5",
      "type": "analogy",
      "linkedSection": "core",
      "title": "Swarm = Microservices",
      "content": "Monolith = Generalist (does everything, coupling increases)<br>\n          Microservice = Worker (single responsibility, focused)<br>\n          API Gateway = Orchestrator (routes, coordinates)<br>\n          Service mesh = Task tool (communication layer)<br><br>\n          <em>If you've designed microservices, you understand swarms.</em>"
    },
    {
      "id": "eff-6",
      "type": "effect",
      "linkedSection": "core",
      "title": "At 4+ workers, monitoring becomes essential",
      "content": "<strong>Threshold:</strong> 3 workers - you can track in your head<br>\n          <strong>Beyond:</strong> Need logs, status board, or HUD<br>\n          <strong>Implication:</strong> Swarm complexity has a steepness curve. Don't start with 8 workers."
    },
    {
      "id": "con-7",
      "type": "constraint",
      "linkedSection": "decisions",
      "title": "One constraint leads to FIVE decisions",
      "content": "<strong>ROOT:</strong> Context dilution reduces quality<br>\n          -&gt; Workers must have focused domains<br>\n          -&gt; Domains need explicit boundaries<br>\n          -&gt; Boundaries need enforcement (prompts)<br>\n          -&gt; Orchestrator must not code (or becomes generalist)<br>\n          -&gt; Workers must not nest (or lose flat coordination)"
    },
    {
      "id": "vio-8",
      "type": "violation",
      "linkedSection": "decisions",
      "title": "If orchestrator starts coding",
      "content": "<strong>IF:</strong> Orchestrator writes \"just one quick fix\"<br>\n          <strong>THEN:</strong> Orchestrator context fills with code details<br>\n          <strong>THEN:</strong> Coordination quality degrades<br>\n          <strong>THEN:</strong> Worker spawning becomes inconsistent<br>\n          <strong>FINALLY:</strong> You have a bad generalist, not a swarm<br><br>\n          <em>The fix: Iron law in system prompt. No exceptions.</em>"
    },
    {
      "id": "trade-9",
      "type": "tradeoff",
      "linkedSection": "decisions",
      "title": "Worker Granularity Dilemma",
      "content": "<strong>Fine-grained:</strong> Many small workers - overhead dominates<br>\n          <strong>Coarse-grained:</strong> Few large workers - back to generalist<br>\n          <strong>Right-sized:</strong> Domain-aligned - judgment required<br><br>\n          <em>Heuristic: One worker per clear domain boundary (backend, frontend, tests).</em>"
    },
    {
      "id": "exp-10",
      "type": "expertise",
      "linkedSection": "implementation",
      "title": "Implementation understanding depth",
      "content": "<strong>Beginner:</strong> \"How do I run a swarm?\" -&gt; Manual terminals<br>\n          <strong>Intermediate:</strong> \"How do I isolate workers?\" -&gt; Git worktrees<br>\n          <strong>Advanced:</strong> \"How do I automate?\" -&gt; CC Mirror Task tool<br>\n          <strong>Staff:</strong> \"How do I monitor?\" -&gt; Log aggregation, HUD<br>\n          <strong>Expert:</strong> \"How do I scale?\" -&gt; Worker pools, dynamic spawning"
    },
    {
      "id": "comp-11",
      "type": "composition",
      "linkedSection": "implementation",
      "title": "Swarm + Git Worktrees",
      "content": "<strong>Works:</strong> Yes, this is the recommended approach.<br>\n          <strong>Why:</strong> Filesystem isolation prevents merge conflicts.<br>\n          <strong>The danger:</strong> Worktree management adds complexity.<br>\n          <strong>Recommendation:</strong> Start manual, graduate to worktrees when conflicts appear."
    },
    {
      "id": "war-12",
      "type": "warstory",
      "linkedSection": "implementation",
      "title": "Matt Pocock: Full-stack in 90 minutes",
      "content": "Auth system that would take 4 hours generalist. Backend, frontend, tests workers. \"The orchestrator never touched code. That's what made it work.\""
    },
    {
      "id": "hor-13",
      "type": "horizon",
      "linkedSection": "path",
      "title": "How swarm perception evolves",
      "content": "<strong>First swarm:</strong> \"This is so much setup overhead\"<br>\n          <strong>Third swarm:</strong> \"Okay, the parallelism is nice\"<br>\n          <strong>Tenth swarm:</strong> \"I can't imagine doing full-stack any other way\"<br>\n          <strong>Mature:</strong> \"Generalist for exploration, swarm for execution\"<br><br>\n          <em>Don't judge swarms by your first run.</em>"
    },
    {
      "id": "vio-14",
      "type": "violation",
      "linkedSection": "path",
      "title": "If you skip dependency tracking",
      "content": "<strong>IF:</strong> Spawn frontend worker before backend completes<br>\n          <strong>THEN:</strong> Frontend builds against non-existent API<br>\n          <strong>THEN:</strong> Integration fails at test worker<br>\n          <strong>THEN:</strong> Entire swarm output is broken<br>\n          <strong>FINALLY:</strong> You debug for 2 hours what should have been prevented<br><br>\n          <em>The fix: blocked_by declarations. Honor the dependency graph.</em>"
    },
    {
      "id": "inv-15",
      "type": "invariant",
      "linkedSection": "path",
      "title": "INV-14: Claims-based coordination",
      "content": "Workers claim completion with evidence. Orchestrator validates claims before proceeding. This is the same pattern as Ralph's progress.txt and Gas Town's Inbox - external state for coordination."
    },
    {
      "id": "inf-16",
      "type": "inflection",
      "linkedSection": "gotchas",
      "title": "When swarm cost flips from justified to excessive",
      "content": "<strong>&lt;30 min task:</strong> Swarm overhead &gt; parallelism benefit (use generalist)<br>\n          <strong>30-60 min:</strong> Break-even zone (judgment call)<br>\n          <strong>1-2 hours:</strong> Swarm clearly wins on time<br>\n          <strong>2+ hours:</strong> Swarm essential for quality<br><br>\n          <strong>THE INFLECTION:</strong> ~45 minute equivalent task<br>\n          <em>Detection: If orchestrator setup takes longer than the task, you over-engineered.</em>"
    },
    {
      "id": "inv-17",
      "type": "inversion",
      "linkedSection": "gotchas",
      "title": "What if workers could spawn workers?",
      "content": "<strong>You'd design:</strong> Recursive decomposition. Workers split when tasks are large.<br>\n          <strong>Why this fails:</strong> No single point of visibility. Deep nesting loses coordination.<br>\n          <strong>Hidden constraint revealed:</strong> Flat hierarchy is feature, not limitation."
    },
    {
      "id": "fron-18",
      "type": "frontier",
      "linkedSection": "gotchas",
      "title": "UNSOLVED: Dynamic worker scaling",
      "content": "<strong>The question:</strong> Can orchestrator spawn more workers mid-flight if task proves larger than expected?<br>\n          <strong>Why it's hard:</strong> Mid-flight spawning requires state handoff. No clean protocol yet.<br>\n          <strong>Current practice:</strong> Pre-decompose conservatively. Re-run swarm if under-decomposed."
    },
    {
      "id": "trade-19",
      "type": "tradeoff",
      "linkedSection": "hard",
      "title": "Cost vs. Speed vs. Quality Triangle",
      "content": "<strong>Optimize cost:</strong> Generalist (1 agent) - slow, lower quality<br>\n          <strong>Optimize speed:</strong> Many Haiku workers - fast, lower quality<br>\n          <strong>Optimize quality:</strong> Opus workers - expensive, slow<br><br>\n          <strong>Why no perfect answer:</strong> Pick 2 of 3. Swarm lets you pick differently per domain."
    },
    {
      "id": "exp-20",
      "type": "expertise",
      "linkedSection": "hard",
      "title": "Debugging distributed failures",
      "content": "<strong>Beginner:</strong> \"Which worker broke it?\" -&gt; Check file modification times<br>\n          <strong>Intermediate:</strong> \"How do I reproduce?\" -&gt; Run suspect worker in isolation<br>\n          <strong>Advanced:</strong> \"How do I prevent?\" -&gt; Better worker verification<br>\n          <strong>Staff:</strong> \"How do I monitor?\" -&gt; Centralized logging<br>\n          <strong>Expert:</strong> \"How do I automate detection?\" -&gt; Orchestrator validates outputs"
    },
    {
      "id": "war-21",
      "type": "warstory",
      "linkedSection": "hard",
      "title": "Steve Yegge: Gas Town's Polecat Principle",
      "content": "\"Workers are disposable. If one fails, spawn another. Don't try to save broken context - the cost of retry is less than the cost of debugging corrupted state.\""
    },
    {
      "id": "inv-22",
      "type": "inversion",
      "linkedSection": "when",
      "title": "What if you used swarm for exploration?",
      "content": "<strong>You'd design:</strong> Exploratory workers investigating different approaches.<br>\n          <strong>Why this fails:</strong> No defined completion criteria. Workers wander.<br>\n          <strong>Hidden constraint revealed:</strong> Swarm needs clear deliverables. Use generalist for open-ended work."
    },
    {
      "id": "ana-23",
      "type": "analogy",
      "linkedSection": "when",
      "title": "Generalist vs Swarm = Agile vs Waterfall",
      "content": "<strong>Generalist:</strong> Agile - iterate, explore, pivot<br>\n          <strong>Swarm:</strong> Waterfall - plan upfront, execute parallel<br>\n          <strong>Hybrid:</strong> Best of both - explore with generalist, execute with swarm<br><br>\n          <em>The question isn't \"which is better\" but \"what phase am I in?\"</em>"
    },
    {
      "id": "alt-24",
      "type": "alternative",
      "linkedSection": "when",
      "title": "If Swarm isn't right for your use case",
      "content": "<strong>Need iteration loops?</strong> -&gt; Ralph (sequential with persistence)<br>\n          <strong>Need human gates?</strong> -&gt; HOTL Swarm (orchestrator pauses for approval)<br>\n          <strong>Need overnight execution?</strong> -&gt; Ralph + Swarm hybrid<br>\n          <strong>Need real-time parallelism?</strong> -&gt; CC Mirror native"
    },
    {
      "id": "con-25",
      "type": "constraint",
      "linkedSection": "when",
      "title": "Budget constraint cascades",
      "content": "<strong>ROOT:</strong> Limited budget for tokens<br>\n          -&gt; Can't afford 4 workers + orchestrator<br>\n          -&gt; Must reduce worker count or model tier<br>\n          -&gt; Reduced workers = less parallelism<br>\n          -&gt; Less parallelism = longer wall clock<br>\n          -&gt; May need to accept generalist for small tasks"
    },
    {
      "id": "hor-26",
      "type": "horizon",
      "linkedSection": "when",
      "title": "When swarm mastery arrives",
      "content": "<strong>Week 1:</strong> \"Swarms feel overengineered\"<br>\n          <strong>Month 1:</strong> \"I'm getting faster at decomposition\"<br>\n          <strong>Month 3:</strong> \"I instinctively know when to swarm\"<br>\n          <strong>Month 6:</strong> \"I design features for swarm execution\"<br><br>\n          <em>The skill isn't swarm configuration - it's task decomposition.</em>"
    },
    {
      "id": "comp-27",
      "type": "composition",
      "linkedSection": "when",
      "title": "Swarm + Ralph (Hybrid)",
      "content": "<strong>Works:</strong> Yes, powerful combination.<br>\n          <strong>How:</strong> Ralph loop spawns swarms for each iteration. Fresh swarm context per loop.<br>\n          <strong>The danger:</strong> Cost multiplies. Use for large projects only.<br>\n          <strong>Recommendation:</strong> Master each pattern separately first."
    },
    {
      "id": "war-28",
      "type": "warstory",
      "linkedSection": "when",
      "title": "Molly Cantillon: Personal Panopticon",
      "content": "8 parallel Claude instances managing different life domains. Each specialized for its domain. \"The key was clear boundaries. Finance Claude never touched Health Claude's domain.\""
    }
  ]
}