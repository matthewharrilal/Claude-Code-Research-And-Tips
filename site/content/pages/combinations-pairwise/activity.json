{
  "items": [
    {
      "id": "min-1",
      "type": "minimal",
      "linkedSection": "essence",
      "title": "The irreducible combination insight",
      "content": "<code style=\"background: #f4f4f5; padding: 2px 6px; border-radius: 4px; font-size: 12px;\">Pattern A + Pattern B = Capability C</code><br><br>\n          The capability C should not be achievable with either pattern alone.<br>\n          If it is, you're adding overhead without adding value."
    },
    {
      "id": "inv-2",
      "type": "inversion",
      "linkedSection": "essence",
      "title": "What if patterns shouldn't combine?",
      "content": "<strong>You'd design:</strong> Monolithic super-patterns that do everything.<br>\n          <strong>Why this fails:</strong> Requirements vary. Codebases vary. One size never fits all.<br>\n          <strong>Hidden insight:</strong> Combinability IS the feature. LEGO philosophy wins."
    },
    {
      "id": "war-3",
      "type": "warstory",
      "linkedSection": "essence",
      "title": "@weswinder: \"opus 4.5 with ralph wiggum and playwright is agi\"",
      "content": "The combination that sparked this analysis. Visual verification + autonomous iteration = capability neither provides alone."
    },
    {
      "id": "con-4",
      "type": "constraint",
      "linkedSection": "core",
      "title": "Why combinations create emergent capabilities",
      "content": "<strong>ROOT:</strong> Each pattern solves ONE problem well<br>\n          --&gt; Patterns are constrained (single purpose)<br>\n          --&gt; Real workflows have MULTIPLE problems<br>\n          --&gt; Combining patterns addresses multiple constraints<br>\n          --&gt; Emergent capabilities arise at intersections<br>\n          --&gt; Combinations &gt; sum of parts"
    },
    {
      "id": "ana-5",
      "type": "analogy",
      "linkedSection": "core",
      "title": "Pattern Combinations = Unix Philosophy",
      "content": "<code>grep</code> --&gt; finds text<br>\n          <code>sort</code> --&gt; orders text<br>\n          <code>uniq</code> --&gt; deduplicates text<br>\n          <code>grep | sort | uniq</code> --&gt; unique sorted matches<br><br>\n          <em>If you understand Unix pipes, you understand pattern combinations.</em>"
    },
    {
      "id": "trade-6",
      "type": "tradeoff",
      "linkedSection": "core",
      "title": "Simplicity vs. Capability",
      "content": "<strong>Single pattern:</strong> Simple, but limited capability<br>\n          <strong>Two patterns:</strong> More complex, but emergent value<br>\n          <strong>Many patterns:</strong> Maximum capability, but overhead dominates<br><br>\n          <em>Heuristic: If overhead of combination exceeds 20% of task time, you've over-combined.</em>"
    },
    {
      "id": "comp-7",
      "type": "composition",
      "linkedSection": "loop-tool",
      "title": "Ralph + Playwright: The Visual Verification Unlock",
      "content": "<strong>Works?</strong> Yes, with caveats<br>\n          <strong>Why it works:</strong> Screenshots catch what unit tests miss<br>\n          <strong>The danger:</strong> Browser context consumes tokens<br>\n          <strong>Recommendation:</strong> Put Playwright in subagents"
    },
    {
      "id": "vio-8",
      "type": "violation",
      "linkedSection": "loop-tool",
      "title": "If you put Playwright in main context",
      "content": "<strong>IF:</strong> Playwright runs in main Ralph context<br>\n          <strong>THEN:</strong> Browser DOM consumes thousands of tokens<br>\n          <strong>THEN:</strong> Context fills before story completes<br>\n          <strong>THEN:</strong> Quality degrades, instructions forgotten<br>\n          <strong>FINALLY:</strong> Visual verification defeats its own purpose<br><br>\n          <em>The fix: Subagent isolation for heavy tools.</em>"
    },
    {
      "id": "eff-9",
      "type": "effect",
      "linkedSection": "loop-tool",
      "title": "Claude-Mem + Ralph: Cross-session learning emergence",
      "content": "<strong>At session 1:</strong> No memories, no benefit<br>\n          <strong>At session 5:</strong> Some patterns, some speedup<br>\n          <strong>At session 20:</strong> Rich memory, significant acceleration<br>\n          <strong>At session 50:</strong> Institutional knowledge, dramatic speedup<br><br>\n          <em>Threshold: ~5 sessions before Claude-Mem investment pays off</em>"
    },
    {
      "id": "exp-10",
      "type": "expertise",
      "linkedSection": "loop-tool",
      "title": "Understanding Ralph + HUD combination",
      "content": "<strong>Beginner:</strong> \"Why do I need HUD with Ralph?\"<br>\n          --&gt; Visibility into progress<br>\n          <strong>Intermediate:</strong> \"What should I watch?\"<br>\n          --&gt; Context %, tool calls, todo count<br>\n          <strong>Advanced:</strong> \"When does HUD warn me?\"<br>\n          --&gt; 80%+ context = story too big<br>\n          <strong>Staff:</strong> \"How do I automate HUD insights?\"<br>\n          --&gt; Exit script when context threshold hit"
    },
    {
      "id": "hor-11",
      "type": "horizon",
      "linkedSection": "loop-tool",
      "title": "Ralph + MCP judgment evolution",
      "content": "<strong>Day 1:</strong> \"MCP setup is overhead\"<br>\n          <strong>Day 7:</strong> \"Database verification caught 3 bugs\"<br>\n          <strong>Day 30:</strong> \"MCP is essential for data-intensive features\"<br>\n          <strong>Day 90:</strong> \"I can't imagine Ralph without MCP\"<br><br>\n          <em>Don't judge MCP ROI after one session.</em>"
    },
    {
      "id": "inv-12",
      "type": "invariant",
      "linkedSection": "orch-verify",
      "title": "INV-003: External state > internal memory",
      "content": "CC Mirror + Hooks, Subagents + Worktrees, Gas Town + Beads all share this invariant.<br><br>\n          <strong>Why this matters:</strong> The same principle (externalize state) forces the same architectural choice (file/git-based coordination) across all orchestration patterns."
    },
    {
      "id": "comp-13",
      "type": "composition",
      "linkedSection": "orch-verify",
      "title": "Subagents + Worktrees: True isolation unlock",
      "content": "<strong>Works?</strong> Yes, powerfully<br>\n          <strong>Why it works:</strong> Git worktrees = filesystem isolation, Subagents = process isolation<br>\n          <strong>The benefit:</strong> No file conflicts during parallel work<br>\n          <strong>Human merges at end:</strong> Architectural review built in"
    },
    {
      "id": "grad-14",
      "type": "gradient",
      "linkedSection": "orch-verify",
      "title": "CC Mirror without hooks",
      "content": "<strong>100% quality</strong>: Manual formatting after each agent<br>\n          <strong>90% quality</strong>: Inconsistent style across agents<br>\n          <strong>70% quality</strong>: Style conflicts in merges<br>\n          <strong>50% quality</strong>: Tech debt compounds<br>\n          <strong>CLIFF</strong>: Codebase becomes unreadable<br><br>\n          <em>Hooks prevent the invisible degradation.</em>"
    },
    {
      "id": "war-15",
      "type": "warstory",
      "linkedSection": "orch-verify",
      "title": "Gas Town + Beads: 225K lines of Go",
      "content": "Steve Yegge's production system. Git-backed data plane means all agent state is version-controlled, auditable, recoverable. Universal context without external databases."
    },
    {
      "id": "inf-16",
      "type": "inflection",
      "linkedSection": "memory-learning",
      "title": "progress.txt + AGENTS.md compounding",
      "content": "<strong>0-5 sessions:</strong> progress.txt dominates (short-term)<br>\n          <strong>5-10 sessions:</strong> AGENTS.md starts catching up<br>\n          <strong>10-20 sessions:</strong> Equal value<br>\n          <strong>20+ sessions:</strong> AGENTS.md dominates (long-term)<br><br>\n          <strong>THE INFLECTION:</strong> ~10 sessions<br>\n          <em>Before: Invest in progress.txt discipline. After: Invest in AGENTS.md curation.</em>"
    },
    {
      "id": "inv-17",
      "type": "invariant",
      "linkedSection": "memory-learning",
      "title": "INV-004: Fresh context > extended sessions",
      "content": "progress.txt + AGENTS.md, Git + Claude-Mem both implement this invariant differently.<br><br>\n          <strong>The shared principle:</strong> State persists in files, not context. This enables fresh context while preserving learnings."
    },
    {
      "id": "ana-18",
      "type": "analogy",
      "linkedSection": "memory-learning",
      "title": "Memory combinations = Human learning systems",
      "content": "<strong>progress.txt</strong> = Working memory (what you're thinking about now)<br>\n          <strong>AGENTS.md</strong> = Long-term memory (what you've learned)<br>\n          <strong>Git history</strong> = Episodic memory (what happened when)<br>\n          <strong>Claude-Mem</strong> = Semantic memory (what things mean)<br><br>\n          <em>Humans use all four. So should your agents.</em>"
    },
    {
      "id": "fron-19",
      "type": "frontier",
      "linkedSection": "memory-learning",
      "title": "UNSOLVED: Automatic memory consolidation",
      "content": "<strong>The question:</strong> When should progress.txt learnings automatically flow to AGENTS.md?<br>\n          <strong>Why it's hard:</strong> Not all learnings are permanent. Human judgment still needed.<br>\n          <strong>Current best practice:</strong> Periodic human curation. No automation yet."
    },
    {
      "id": "exp-20",
      "type": "expertise",
      "linkedSection": "synergies",
      "title": "Understanding synergy categories",
      "content": "<strong>Beginner:</strong> \"What's a synergy?\"<br>\n          --&gt; Combined value &gt; sum of parts<br>\n          <strong>Intermediate:</strong> \"Why categorize synergies?\"<br>\n          --&gt; Different investment strategies<br>\n          <strong>Advanced:</strong> \"How do I identify multiplicative?\"<br>\n          --&gt; Ask: \"Does this create NEW capability?\"<br>\n          <strong>Staff:</strong> \"How do I prioritize combinations?\"<br>\n          --&gt; Multiplicative first, then additive, then enabling"
    },
    {
      "id": "trade-21",
      "type": "tradeoff",
      "linkedSection": "synergies",
      "title": "Effort vs. Impact quadrant",
      "content": "<strong>Low effort, high impact:</strong> Ralph + Playwright, progress.txt + AGENTS.md<br>\n          <strong>High effort, high impact:</strong> Worktrees + Subagents, Gas Town + Beads<br>\n          <strong>Low effort, low impact:</strong> HUD + Ralph, Hooks + Formatting<br>\n          <strong>High effort, low impact:</strong> Avoid these combinations<br><br>\n          <em>Start in top-left quadrant. Move to top-right as you scale.</em>"
    },
    {
      "id": "inv-22",
      "type": "inversion",
      "linkedSection": "synergies",
      "title": "What if we had no synergy matrix?",
      "content": "<strong>You'd design:</strong> Trial-and-error combinations, wasted effort on incompatible pairs<br>\n          <strong>Why this fails:</strong> Some combinations actively conflict (fresh context + large shared context)<br>\n          <strong>Hidden insight:</strong> The matrix IS the expertise - knowing what NOT to combine"
    },
    {
      "id": "war-23",
      "type": "warstory",
      "linkedSection": "synergies",
      "title": "@TendiesOfWisdom: Subagent isolation discovery",
      "content": "\"Put costly tools like browser control in subagents to protect your main context window tokens.\" This single insight transformed Ralph + Playwright from problematic to Very High ROI."
    },
    {
      "id": "vio-24",
      "type": "violation",
      "linkedSection": "gotchas",
      "title": "If worktree agents don't share AGENTS.md",
      "content": "<strong>IF:</strong> Each worktree agent has no shared architectural constraints<br>\n          <strong>THEN:</strong> Agents make independent design decisions<br>\n          <strong>THEN:</strong> Designs diverge significantly<br>\n          <strong>THEN:</strong> Merge conflicts are architectural, not just textual<br>\n          <strong>FINALLY:</strong> \"Merge\" becomes \"rewrite\"<br><br>\n          <em>The fix: Shared AGENTS.md with architectural rules.</em>"
    },
    {
      "id": "hor-25",
      "type": "horizon",
      "linkedSection": "gotchas",
      "title": "progress.txt + AGENTS.md sync perception",
      "content": "<strong>Week 1:</strong> \"Why maintain both? Overhead!\"<br>\n          <strong>Week 4:</strong> \"progress.txt has conflicting learnings...\"<br>\n          <strong>Week 8:</strong> \"Periodic curation takes time but prevents confusion\"<br>\n          <strong>Week 16:</strong> \"The curation rhythm IS the value\"<br><br>\n          <em>The sync overhead is an investment, not a cost.</em>"
    },
    {
      "id": "eff-26",
      "type": "effect",
      "linkedSection": "gotchas",
      "title": "Claude-Mem semantic drift at scale",
      "content": "<strong>At 100 memories:</strong> Search is precise<br>\n          <strong>At 1000 memories:</strong> Some irrelevant results<br>\n          <strong>At 10000 memories:</strong> Signal-to-noise degrades<br><br>\n          <em>Threshold: ~1000 memories before you need explicit project tagging</em>"
    },
    {
      "id": "grad-27",
      "type": "gradient",
      "linkedSection": "anti-patterns",
      "title": "Parallel agents on single branch",
      "content": "<strong>100%</strong>: First agent commits cleanly<br>\n          <strong>80%</strong>: Second agent hits merge conflict<br>\n          <strong>60%</strong>: Conflicts compound with each agent<br>\n          <strong>40%</strong>: Agents overwrite each other<br>\n          <strong>CLIFF</strong>: Progress becomes regression<br><br>\n          <em>Use worktrees. There is no alternative.</em>"
    },
    {
      "id": "con-28",
      "type": "constraint",
      "linkedSection": "anti-patterns",
      "title": "Why heavy tools in main context fails",
      "content": "<strong>ROOT:</strong> Context window is finite (200K tokens)<br>\n          --&gt; Heavy tool output consumes tokens<br>\n          --&gt; Less room for actual task<br>\n          --&gt; Quality degrades earlier<br>\n          --&gt; Iteration fails before completion<br>\n          --&gt; \"Verified\" becomes \"broken\""
    },
    {
      "id": "alt-29",
      "type": "alternative",
      "linkedSection": "anti-patterns",
      "title": "If you're hitting anti-patterns",
      "content": "<strong>Context bloat?</strong> --&gt; Subagent isolation<br>\n          <strong>Merge conflicts?</strong> --&gt; Git worktrees<br>\n          <strong>Budget blown?</strong> --&gt; Model selection (Sonnet for implementation)<br>\n          <strong>Monitoring overhead?</strong> --&gt; Pick ONE visibility tool"
    },
    {
      "id": "exp-30",
      "type": "expertise",
      "linkedSection": "when",
      "title": "When to combine patterns",
      "content": "<strong>Beginner:</strong> \"Should I combine patterns?\"<br>\n          --&gt; Master single patterns first<br>\n          <strong>Intermediate:</strong> \"Which combinations?\"<br>\n          --&gt; Start with Quick Wins (low effort, high impact)<br>\n          <strong>Advanced:</strong> \"How many patterns?\"<br>\n          --&gt; 2-3 max for most workflows<br>\n          <strong>Staff:</strong> \"When do I add more?\"<br>\n          --&gt; Only when you hit a wall with current setup"
    },
    {
      "id": "inv-31",
      "type": "inversion",
      "linkedSection": "when",
      "title": "What if you always combined patterns?",
      "content": "<strong>You'd design:</strong> Maximum capability from day one<br>\n          <strong>Why this fails:</strong> Overhead dominates. Debugging nightmare. Can't isolate problems.<br>\n          <strong>Hidden insight:</strong> Start simple. Add combinations when you feel specific pain."
    },
    {
      "id": "alt-32",
      "type": "alternative",
      "linkedSection": "when",
      "title": "If pairwise isn't enough",
      "content": "<strong>Need more combinations?</strong> --&gt; combinations-triple-plus.md<br>\n          <strong>Need the full matrix?</strong> --&gt; combinations-matrix.md<br>\n          <strong>Need unexplored territory?</strong> --&gt; combinations-unexplored.md<br>\n          <strong>Need extension patterns?</strong> --&gt; combinations-extensions.md"
    }
  ]
}