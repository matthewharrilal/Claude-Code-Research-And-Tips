{
  "items": [
    {
      "id": "inv-1",
      "type": "inversion",
      "linkedSection": "essence",
      "title": "What if agents could share memory?",
      "content": "<strong>You'd design:</strong> One massive context, all agents read/write simultaneously.<br>\n          <strong>Why this fails:</strong> Context windows are per-agent. No shared memory exists at the LLM layer.<br>\n          <strong>Hidden constraint:</strong> Topologies ARE the solution to this constraint."
    },
    {
      "id": "ana-2",
      "type": "analogy",
      "linkedSection": "essence",
      "title": "Topologies = Team Org Charts",
      "content": "Sequential = Assembly line<br>\n          Hierarchical = Corporate management<br>\n          Mesh = Flat startup<br>\n          ForestSwarm = Consulting firm routing<br><br>\n          <em>If you've managed humans, you already understand these trade-offs.</em>"
    },
    {
      "id": "inv-3",
      "type": "invariant",
      "linkedSection": "essence",
      "title": "Cross-Pattern DNA: \"Coordination Has Cost\"",
      "content": "Every topology adds overhead. Sequential = chain latency. Concurrent = memory. Hierarchical = director bottleneck. Mesh = N^2 communication.<br><br>\n          <strong>The invariant:</strong> No free coordination. Choose your cost."
    },
    {
      "id": "con-4",
      "type": "constraint",
      "linkedSection": "topologies",
      "title": "One constraint -> topology choice",
      "content": "<strong>ROOT:</strong> Agents can't share context<br>\n          -&gt; Must communicate through messages/files<br>\n          -&gt; Communication has latency<br>\n          -&gt; Topology defines communication paths<br>\n          -&gt; Path complexity = latency + cost<br>\n          -&gt; Choose topology for YOUR constraint priority"
    },
    {
      "id": "exp-5",
      "type": "expertise",
      "linkedSection": "topologies",
      "title": "How deep is your understanding?",
      "content": "<strong>Beginner:</strong> \"Which topology should I use?\" -&gt; Sequential<br>\n          <strong>Intermediate:</strong> \"Why is Hierarchical slower?\" -&gt; Coordination overhead<br>\n          <strong>Advanced:</strong> \"When does Mesh beat Hierarchical?\" -&gt; When no natural leader<br>\n          <strong>Staff:</strong> \"Can I combine topologies?\" -&gt; Yes, that's Hybrid<br>\n          <strong>Expert:</strong> \"What consensus for 200 agents?\" -&gt; Gossip"
    },
    {
      "id": "min-6",
      "type": "minimal",
      "linkedSection": "topologies",
      "title": "The simplest swarm that works",
      "content": "<code style=\"background: #f4f4f5; padding: 2px 6px; border-radius: 4px; font-size: 12px;\">Agent A -&gt; Agent B</code><br><br>\n          Two agents, sequential. That's it.<br>\n          <strong>Everything beyond:</strong> Optimization for specific constraints."
    },
    {
      "id": "war-7",
      "type": "warstory",
      "linkedSection": "topologies",
      "title": "Claude-Flow v3: 54+ agents in production",
      "content": "Enterprise swarm orchestration. Hierarchical topology with Raft consensus. Strategic Queen + Tactical Queens + Worker agents. Proof that Hierarchical scales to enterprise."
    },
    {
      "id": "trade-8",
      "type": "tradeoff",
      "linkedSection": "consensus",
      "title": "Raft vs Gossip",
      "content": "<strong>Raft:</strong> Strong consistency, lower latency, but bottleneck at leader<br>\n          <strong>Gossip:</strong> Eventual consistency, scales better, but no instant agreement<br><br>\n          <strong>THE DILEMMA:</strong> &lt;20 agents? Raft. &gt;100 agents? Gossip. In between? Measure."
    },
    {
      "id": "vio-9",
      "type": "violation",
      "linkedSection": "consensus",
      "title": "If you skip consensus in Mesh",
      "content": "<strong>IF:</strong> 10 agents in mesh without consensus<br>\n          <strong>THEN:</strong> No agreement on which agent handles task<br>\n          <strong>THEN:</strong> Multiple agents duplicate work OR no agent acts<br>\n          <strong>FINALLY:</strong> Wasted cost, inconsistent results<br><br>\n          <em>Mesh without consensus = chaos</em>"
    },
    {
      "id": "hor-10",
      "type": "horizon",
      "linkedSection": "consensus",
      "title": "When consensus matters more",
      "content": "<strong>5 agents:</strong> \"Why do I need consensus? Just coordinate manually.\"<br>\n          <strong>20 agents:</strong> \"Okay, Raft makes sense for leader election.\"<br>\n          <strong>50 agents:</strong> \"Raft leader is overwhelmed. Need Gossip.\"<br>\n          <strong>200 agents:</strong> \"Gossip is essential. Raft can't scale.\"<br><br>\n          <em>Consensus complexity grows with agent count.</em>"
    },
    {
      "id": "fron-11",
      "type": "frontier",
      "linkedSection": "consensus",
      "title": "UNSOLVED: Adaptive consensus",
      "content": "What if consensus algorithm automatically adapted to swarm size? Start with Raft, transition to Gossip at threshold? No production-ready implementation yet."
    },
    {
      "id": "grad-12",
      "type": "gradient",
      "linkedSection": "selection",
      "title": "How wrong topology degrades",
      "content": "<strong>Slightly wrong:</strong> Works but inefficient (10-30% slower)<br>\n          <strong>Moderately wrong:</strong> Bottlenecks emerge, timeouts increase<br>\n          <strong>Very wrong:</strong> Cascading failures, deadlocks<br>\n          <strong>Completely wrong:</strong> Nothing works, system hangs<br><br>\n          <em>Wrong topology fails gradually, then suddenly.</em>"
    },
    {
      "id": "inf-13",
      "type": "inflection",
      "linkedSection": "selection",
      "title": "When to upgrade topology",
      "content": "<strong>1-5 agents:</strong> Sequential/Concurrent sufficient<br>\n          <strong>5-20 agents:</strong> Consider Hierarchical for coordination<br>\n          <strong>20-50 agents:</strong> Need structured routing (ForestSwarm)<br>\n          <strong>50+ agents:</strong> Hybrid mandatory, Gossip consensus<br><br>\n          <strong>THE INFLECTION:</strong> ~20 agents is where simple breaks"
    },
    {
      "id": "comp-14",
      "type": "composition",
      "linkedSection": "selection",
      "title": "Sequential + Concurrent",
      "content": "<strong>Pattern:</strong> Research (sequential) -&gt; Analysis (concurrent) -&gt; Synthesis (sequential)<br>\n          <strong>Implementation:</strong> <code>AgentRearrange(flow=\"A -&gt; B,C,D -&gt; E\")</code><br>\n          <strong>Works:</strong> When phases have different coordination needs"
    },
    {
      "id": "alt-15",
      "type": "alternative",
      "linkedSection": "selection",
      "title": "If swarm topologies are overkill",
      "content": "<strong>Simple task?</strong> -&gt; Single Claude session<br>\n          <strong>Iterative refinement?</strong> -&gt; Ralph loops<br>\n          <strong>Human in loop?</strong> -&gt; HOTL Ralph<br>\n          <strong>Just need parallelism?</strong> -&gt; CC Mirror"
    },
    {
      "id": "inv-16",
      "type": "inversion",
      "linkedSection": "infrastructure",
      "title": "Why Rust for CCSwarm?",
      "content": "<strong>What if it were Python?</strong><br>\n          Runtime type checks. GIL limits parallelism. Memory grows unbounded.<br><br>\n          <strong>Why Rust works:</strong> Compile-time state validation. Lock-free channels. 70% memory reduction. Invalid state sequences are compile errors."
    },
    {
      "id": "ana-17",
      "type": "analogy",
      "linkedSection": "infrastructure",
      "title": "NATS = Message bus for agents",
      "content": "<strong>Kafka:</strong> For data pipelines<br>\n          <strong>NATS:</strong> For agent coordination<br>\n          <strong>Why NATS:</strong> Lower latency, simpler, built-in request-reply<br><br>\n          <em>If you've used Kafka, NATS is the lightweight alternative for real-time agent messaging.</em>"
    },
    {
      "id": "war-18",
      "type": "warstory",
      "linkedSection": "infrastructure",
      "title": "CCSwarm: 93% cost reduction (claimed)",
      "content": "Rust-native coordination with channel-based orchestration. Zero lock contention. Type-state pattern ensures compile-time safety. 70% memory reduction vs Python alternatives."
    },
    {
      "id": "eff-19",
      "type": "effect",
      "linkedSection": "infrastructure",
      "title": "Type-state enables fearless refactoring",
      "content": "When state transitions are in the type system, the compiler catches invalid sequences. Refactoring a 50-agent swarm? Compiler shows all broken paths. No runtime surprises."
    },
    {
      "id": "vio-20",
      "type": "violation",
      "linkedSection": "gotchas",
      "title": "If you skip error handling in Sequential",
      "content": "<strong>IF:</strong> Agent 2 fails without retry logic<br>\n          <strong>THEN:</strong> Chain stops at Agent 2<br>\n          <strong>THEN:</strong> Agents 3, 4, 5 never run<br>\n          <strong>THEN:</strong> Partial result or no result<br>\n          <strong>FINALLY:</strong> User sees failure, no graceful degradation"
    },
    {
      "id": "inv-21",
      "type": "inversion",
      "linkedSection": "gotchas",
      "title": "Why does Hierarchical bottleneck?",
      "content": "<strong>What if director had infinite capacity?</strong><br>\n          Then Hierarchical would scale linearly. But directors are single agents with context limits.<br><br>\n          <strong>The fix:</strong> Add intermediate leaders. Hierarchical becomes Hybrid."
    },
    {
      "id": "min-22",
      "type": "minimal",
      "linkedSection": "gotchas",
      "title": "First diagnostic commands",
      "content": "<code style=\"background: #f4f4f5; padding: 2px 6px; border-radius: 4px; font-size: 12px; display: block; margin-bottom: 4px;\">npx claude-flow@v3alpha doctor</code>\n          <code style=\"background: #f4f4f5; padding: 2px 6px; border-radius: 4px; font-size: 12px; display: block; margin-bottom: 4px;\">npx claude-flow@v3alpha perf diagnose</code>\n          <code style=\"background: #f4f4f5; padding: 2px 6px; border-radius: 4px; font-size: 12px; display: block;\">stn lattice status</code>"
    },
    {
      "id": "trade-23",
      "type": "tradeoff",
      "linkedSection": "hard",
      "title": "The Observability Paradox",
      "content": "<strong>More logging:</strong> Better debugging, but noise drowns signal<br>\n          <strong>Less logging:</strong> Cleaner output, but blind to failures<br>\n          <strong>Tracing:</strong> Full visibility, but adds latency overhead<br><br>\n          <em>No perfect answer. Balance based on failure frequency.</em>"
    },
    {
      "id": "exp-24",
      "type": "expertise",
      "linkedSection": "hard",
      "title": "Understanding topology selection",
      "content": "<strong>Beginner:</strong> \"Just tell me which one to use\"<br>\n          <strong>Intermediate:</strong> \"I can follow the decision tree\"<br>\n          <strong>Advanced:</strong> \"I understand the trade-offs\"<br>\n          <strong>Staff:</strong> \"I can design custom topologies\"<br>\n          <strong>Expert:</strong> \"I can predict emergent behaviors\""
    },
    {
      "id": "fron-25",
      "type": "frontier",
      "linkedSection": "hard",
      "title": "UNSOLVED: Self-optimizing topologies",
      "content": "What if the swarm could observe its own performance and restructure? Start as Hierarchical, detect bottleneck, automatically split into Hybrid? No production-ready implementation exists."
    },
    {
      "id": "inv-26",
      "type": "inversion",
      "linkedSection": "when",
      "title": "What if you used swarms for everything?",
      "content": "<strong>Simple task + swarm:</strong> 10x cost, 5x latency, debugging nightmare<br>\n          <strong>Why this fails:</strong> Coordination overhead dominates small tasks<br><br>\n          <em>Swarms are for problems that NEED coordination, not problems that CAN use it.</em>"
    },
    {
      "id": "ana-27",
      "type": "analogy",
      "linkedSection": "when",
      "title": "Swarm Complexity = Team Size",
      "content": "<strong>1 person:</strong> No coordination needed<br>\n          <strong>2-5 people:</strong> Simple sync (Sequential/Concurrent)<br>\n          <strong>5-20 people:</strong> Need a manager (Hierarchical)<br>\n          <strong>20-50 people:</strong> Need departments (Hybrid)<br>\n          <strong>50+ people:</strong> Need org design expertise<br><br>\n          <em>Brooks's Law applies to swarms too.</em>"
    },
    {
      "id": "alt-28",
      "type": "alternative",
      "linkedSection": "when",
      "title": "Complete pattern landscape",
      "content": "<strong>Level 0-1:</strong> Vanilla Claude Code<br>\n          <strong>Level 2-4:</strong> Ralph loops<br>\n          <strong>Level 3-4:</strong> CC Mirror, Subagents<br>\n          <strong>Level 5-6:</strong> Swarm Topologies (YOU ARE HERE)<br>\n          <strong>Level 6-7:</strong> Gas Town, Hive-Mind"
    },
    {
      "id": "eff-29",
      "type": "effect",
      "linkedSection": "when",
      "title": "Topology choice affects team skills",
      "content": "Choosing complex topologies = requiring distributed systems expertise on your team. Can't debug Mesh consensus without understanding distributed systems fundamentals. The topology IS a hiring signal."
    }
  ]
}