

      <!-- Section 1: ESSENCE -->
      <section id="essence" data-activity="essence">
        <div class="essence-box">
          <div class="essence-label">Essence (15 words)</div>
          <div class="essence-text">Swarm topologies are structural patterns that define how multiple AI agents coordinate, communicate, and collaborate.</div>
        </div>

        <p class="text-text-secondary mb-6">
          When you move beyond single-agent workflows (vanilla Claude Code, Ralph loops), you enter the territory of multi-agent systems. The question becomes: HOW do agents talk to each other? This is topology.
        </p>

        <p class="text-text-secondary mb-6">
          This synthesis extracts topology patterns from four major frameworks: Claude-Flow v3 (54+ agents, enterprise), CCSwarm (Rust-native), Swarms Framework (14+ patterns), and Station (NATS messaging backbone).
        </p>
      </section>

      <!-- Section 2: 14+ TOPOLOGIES CATALOG -->
      <section id="topologies" data-activity="topologies">
        <h2 class="section-title">
          <span class="section-number">2</span>
          The 14+ Topologies Catalog
        </h2>

        <!-- Quick Reference Table -->
        <div class="overflow-x-auto mb-8">
          <table class="quick-ref-table">
            <thead>
              <tr>
                <th>#</th>
                <th>Topology</th>
                <th>Agent Count</th>
                <th>Parallelism</th>
                <th>Best For</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>1</td>
                <td><strong>Sequential</strong></td>
                <td>2-10</td>
                <td>None</td>
                <td>Pipelines, refinement chains</td>
              </tr>
              <tr>
                <td>2</td>
                <td><strong>Concurrent</strong></td>
                <td>2-50</td>
                <td>Full</td>
                <td>Speed, parallel analysis</td>
              </tr>
              <tr>
                <td>3</td>
                <td><strong>Hierarchical</strong></td>
                <td>3-100+</td>
                <td>Partial</td>
                <td>Enterprise, projects</td>
              </tr>
              <tr>
                <td>4</td>
                <td><strong>Mesh</strong></td>
                <td>5-20</td>
                <td>Full</td>
                <td>Distributed workloads</td>
              </tr>
              <tr>
                <td>5</td>
                <td><strong>Ring</strong></td>
                <td>3-30</td>
                <td>Partial</td>
                <td>Pipeline with feedback</td>
              </tr>
              <tr>
                <td>6</td>
                <td><strong>Star</strong></td>
                <td>3-50</td>
                <td>Full</td>
                <td>Simple coordination</td>
              </tr>
              <tr>
                <td>7</td>
                <td><strong>Hybrid</strong></td>
                <td>10-200+</td>
                <td>Mixed</td>
                <td>Factory scale</td>
              </tr>
              <tr>
                <td>8</td>
                <td><strong>Mixture-of-Agents</strong></td>
                <td>3-10</td>
                <td>Full</td>
                <td>Expert synthesis</td>
              </tr>
              <tr>
                <td>9</td>
                <td><strong>GraphWorkflow</strong></td>
                <td>5-50</td>
                <td>DAG-based</td>
                <td>Complex pipelines</td>
              </tr>
              <tr>
                <td>10</td>
                <td><strong>ForestSwarm</strong></td>
                <td>10-100+</td>
                <td>Dynamic</td>
                <td>Large agent pools</td>
              </tr>
              <tr>
                <td>11</td>
                <td><strong>GroupChat</strong></td>
                <td>3-8</td>
                <td>Turn-based</td>
                <td>Discussion, debate</td>
              </tr>
              <tr>
                <td>12</td>
                <td><strong>MajorityVoting</strong></td>
                <td>3-9 (odd)</td>
                <td>Full</td>
                <td>Decision making</td>
              </tr>
              <tr>
                <td>13</td>
                <td><strong>AgentRearrange</strong></td>
                <td>2-20</td>
                <td>Configurable</td>
                <td>Dynamic workflows</td>
              </tr>
              <tr>
                <td>14</td>
                <td><strong>HeavySwarm</strong></td>
                <td>5</td>
                <td>Phased</td>
                <td>Deep analysis</td>
              </tr>
            </tbody>
          </table>
        </div>

        <!-- Sequential Topology -->
        <div class="topology-card" id="sequential">
          <div class="topology-header">
            <span class="topology-number">1</span>
            <span class="topology-name">Sequential Workflow</span>
            <span class="topology-badge">Basic</span>
          </div>

          <p class="text-text-secondary mb-4">
            Linear chain where each agent's output becomes the next agent's input. This is the simplest multi-agent topology.
          </p>

          <div class="ascii-diagram">
            <pre>+----------+     +----------+     +----------+     +----------+
|  Agent 1 | --&gt; |  Agent 2 | --&gt; |  Agent 3 | --&gt; |  Result  |
| Research |     |  Writer  |     |  Editor  |     |          |
+----------+     +----------+     +----------+     +----------+</pre>
          </div>

          <table class="char-table">
            <tbody><tr><th>Aspect</th><th>Value</th></tr>
            <tr><td>Parallelism</td><td>None - strictly sequential</td></tr>
            <tr><td>Latency</td><td>Sum of all agent latencies</td></tr>
            <tr><td>Failure mode</td><td>Single point - any failure stops chain</td></tr>
            <tr><td>Memory usage</td><td>Low - one agent active at a time</td></tr>
          </tbody></table>

          <p class="text-text-muted text-sm"><strong>Use cases:</strong> Document pipelines (research -&gt; write -&gt; edit), step-by-step analysis, content refinement</p>
        </div>

        <!-- Concurrent Topology -->
        <div class="topology-card" id="concurrent">
          <div class="topology-header">
            <span class="topology-number">2</span>
            <span class="topology-name">Concurrent Workflow</span>
            <span class="topology-badge">Speed</span>
          </div>

          <p class="text-text-secondary mb-4">
            Multiple agents work simultaneously on the same or different tasks. Maximum parallelism.
          </p>

          <div class="ascii-diagram">
            <pre>              +------------+
          +--&gt;|  Agent 1   |--+
          |   | Market     |  |
          |   +------------+  |
          |                   |
+-------+ |   +------------+  |     +---------+
| Task  |-+--&gt;|  Agent 2   |--+----&gt;| Results |
|       | |   | Financial  |  |     |         |
+-------+ |   +------------+  |     +---------+
          |                   |
          |   +------------+  |
          +--&gt;|  Agent 3   |--+
              | Risk       |
              +------------+</pre>
          </div>

          <table class="char-table">
            <tbody><tr><th>Aspect</th><th>Value</th></tr>
            <tr><td>Parallelism</td><td>Full - all agents execute simultaneously</td></tr>
            <tr><td>Latency</td><td>Max of individual agent latencies</td></tr>
            <tr><td>Failure mode</td><td>Independent - one failure doesn't stop others</td></tr>
            <tr><td>Memory usage</td><td>High - all agents active simultaneously</td></tr>
          </tbody></table>

          <p class="text-text-muted text-sm"><strong>Use cases:</strong> Parallel data analysis, multi-perspective evaluation, speed-critical processing</p>
        </div>

        <!-- Hierarchical Topology -->
        <div class="topology-card" id="hierarchical">
          <div class="topology-header">
            <span class="topology-number">3</span>
            <span class="topology-name">Hierarchical Swarm</span>
            <span class="topology-badge">Enterprise</span>
          </div>

          <p class="text-text-secondary mb-4">
            Director/Queen agent coordinates specialized workers with feedback loops. This is the Gas Town / Claude-Flow default.
          </p>

          <div class="ascii-diagram">
            <pre>                +-------------------+
                |   STRATEGIC QUEEN |
                |     (Planning)    |
                +---------+---------+
                          |
          +---------------+---------------+
          |               |               |
          v               v               v
  +-------+-------+ +-----+-----+ +-------+-------+
  | TACTICAL      | | ADAPTIVE  | |   SECURITY    |
  | QUEEN         | | QUEEN     | |   ARCHITECT   |
  +-------+-------+ +-----+-----+ +-------+-------+
          |               |               |
    +-----+-----+         |         +-----+-----+
    |     |     |         |         |     |     |
    v     v     v         v         v     v     v
+------+ +--+ +------+ +------+ +------+ +--+ +----+
|Coder1| |C2| |Tester| |Analyt| |Review| |Do| |Opt |
+------+ +--+ +------+ +------+ +------+ +--+ +----+</pre>
          </div>

          <table class="char-table">
            <tbody><tr><th>Aspect</th><th>Value</th></tr>
            <tr><td>Parallelism</td><td>Partial - workers parallel, coordination serial</td></tr>
            <tr><td>Latency</td><td>Director overhead + max worker latency</td></tr>
            <tr><td>Failure mode</td><td>Director is critical, workers replaceable</td></tr>
            <tr><td>Memory usage</td><td>Medium - workers share through director</td></tr>
          </tbody></table>

          <p class="text-text-muted text-sm"><strong>Use cases:</strong> Enterprise development teams, project management workflows, complex task decomposition</p>
        </div>

        <!-- Mesh Topology -->
        <div class="topology-card" id="mesh">
          <div class="topology-header">
            <span class="topology-number">4</span>
            <span class="topology-name">Mesh Network</span>
            <span class="topology-badge">Resilient</span>
          </div>

          <p class="text-text-secondary mb-4">
            Agents connect directly to each other in a peer-to-peer network. No single point of failure.
          </p>

          <div class="ascii-diagram">
            <pre>        +----------+
        | Agent A  |
        +----+-----+
            /|\
           / | \
          /  |  \
         v   v   v
+------+  +------+  +------+
|Agent B|&lt;-&gt;|Agent C|&lt;-&gt;|Agent D|
+------+  +------+  +------+
    \        |        /
     \       |       /
      v      v      v
        +----------+
        | Agent E  |
        +----------+</pre>
          </div>

          <table class="char-table">
            <tbody><tr><th>Aspect</th><th>Value</th></tr>
            <tr><td>Parallelism</td><td>Full - any agent can communicate with any other</td></tr>
            <tr><td>Failure mode</td><td>Resilient - no single point of failure</td></tr>
            <tr><td>Memory usage</td><td>High - maintaining multiple connections</td></tr>
            <tr><td>Best for</td><td>5-20 agents</td></tr>
          </tbody></table>

          <p class="text-text-muted text-sm"><strong>Use cases:</strong> Distributed workloads without central coordinator, decentralized decision making</p>
        </div>

        <!-- Mixture-of-Agents Topology -->
        <div class="topology-card" id="moa">
          <div class="topology-header">
            <span class="topology-number">8</span>
            <span class="topology-name">Mixture-of-Agents (MoA)</span>
            <span class="topology-badge">Synthesis</span>
          </div>

          <p class="text-text-secondary mb-4">
            Multiple experts work in parallel, then an aggregator synthesizes their outputs. Expert panel simulation.
          </p>

          <div class="ascii-diagram">
            <pre>              +----------------+
          +--&gt;| Python Expert  |--+
          |   +----------------+  |
          |                       |
+-------+ |   +----------------+  |     +------------+     +--------+
| Task  |-+--&gt;| Security Expert|--+----&gt;| AGGREGATOR |----&gt;| Result |
|       | |   +----------------+  |     | (Synthesis)|     |        |
+-------+ |                       |     +------------+     +--------+
          |   +----------------+  |
          +--&gt;| Arch Expert    |--+
              +----------------+</pre>
          </div>

          <table class="char-table">
            <tbody><tr><th>Aspect</th><th>Value</th></tr>
            <tr><td>Parallelism</td><td>Full for experts, serial for aggregation</td></tr>
            <tr><td>Latency</td><td>Max expert latency + aggregator latency</td></tr>
            <tr><td>Agent count</td><td>3-10 experts + 1 aggregator</td></tr>
            <tr><td>Failure mode</td><td>Expert failures reduce quality, aggregator critical</td></tr>
          </tbody></table>

          <p class="text-text-muted text-sm"><strong>Use cases:</strong> Complex problem solving, multi-domain expertise, consensus building</p>
        </div>

        <!-- GraphWorkflow Topology -->
        <div class="topology-card" id="graph">
          <div class="topology-header">
            <span class="topology-number">9</span>
            <span class="topology-name">GraphWorkflow (DAG)</span>
            <span class="topology-badge">Complex</span>
          </div>

          <p class="text-text-secondary mb-4">
            Directed Acyclic Graph for complex dependencies. Like a build system for agent workflows.
          </p>

          <div class="ascii-diagram">
            <pre>          +---+
          | A |  (Data Collection)
          +-+-+
           /|\
          / | \
         v  v  v
      +---+ +---+ +---+
      | B | | C | | D |  (Parallel Analysis)
      +-+-+ +-+-+ +-+-+
        |     |     |
        |     v     |
        |   +---+   |
        +--&gt;| E |&lt;--+  (Synthesis)
            +-+-+
              |
              v
            +---+
            | F |  (Final Report)
            +---+</pre>
          </div>

          <table class="char-table">
            <tbody><tr><th>Aspect</th><th>Value</th></tr>
            <tr><td>Parallelism</td><td>DAG-based - parallel where no dependencies</td></tr>
            <tr><td>Latency</td><td>Critical path through DAG</td></tr>
            <tr><td>Failure mode</td><td>Dependent nodes blocked by upstream failure</td></tr>
          </tbody></table>

          <p class="text-text-muted text-sm"><strong>Use cases:</strong> Build system-like dependencies, complex data pipelines, conditional execution paths</p>
        </div>

        <!-- ForestSwarm Topology -->
        <div class="topology-card" id="forest">
          <div class="topology-header">
            <span class="topology-number">10</span>
            <span class="topology-name">ForestSwarm</span>
            <span class="topology-badge">Scale</span>
          </div>

          <p class="text-text-secondary mb-4">
            Dynamic agent selection using semantic similarity. Routes tasks to the best-matched specialist.
          </p>

          <div class="ascii-diagram">
            <pre>+----------+      +-----------+      +---------------+      +---------------+
|   Task   | ---&gt; | Embedding | ---&gt; | Tree Selection| ---&gt; | Agent Select  |
+----------+      | [0.2,0.8] |      | "Finance Tree"|      | "Tax Speclist"|
                  +-----------+      +---------------+      +---------------+
                                            |
                                            v
                  +------------------------------------------------+
                  |                    FOREST                       |
                  |  +-------------+  +-------------+  +----------+ |
                  |  |Finance Tree |  | Legal Tree  |  | Tech Tree| |
                  |  | -Tax Agent  |  | -Contract   |  | -Backend | |
                  |  | -Invest Agt |  | -IP Agent   |  | -Frontend| |
                  |  +-------------+  +-------------+  +----------+ |
                  +------------------------------------------------+</pre>
          </div>

          <table class="char-table">
            <tbody><tr><th>Aspect</th><th>Value</th></tr>
            <tr><td>Agent count</td><td>10-100+</td></tr>
            <tr><td>Parallelism</td><td>Dynamic - routes to best agent</td></tr>
            <tr><td>Failure mode</td><td>Fallback to next-best agent</td></tr>
            <tr><td>Memory usage</td><td>Low per task - only one agent active</td></tr>
          </tbody></table>

          <p class="text-text-muted text-sm"><strong>Use cases:</strong> Large agent pools with specialization, dynamic task routing, scalable specialist networks</p>
        </div>
      </section>

      <!-- Section 3: CONSENSUS ALGORITHMS -->
      <section id="consensus" data-activity="consensus">
        <h2 class="section-title">
          <span class="section-number">3</span>
          Consensus Algorithms
        </h2>

        <p class="text-text-secondary mb-6">
          When multiple agents need to agree on state (what task to do, what result is correct), you need consensus. Different algorithms trade off consistency, latency, and fault tolerance.
        </p>

        <!-- Raft -->
        <div class="consensus-card">
          <div class="consensus-header">
            <i data-lucide="crown" class="w-5 h-5 text-accent"></i>
            Raft Consensus (Default)
          </div>

          <p class="text-text-secondary mb-4">
            Leader-based with strong consistency. A leader is elected, and all decisions flow through it. If the leader fails, a new election happens.
          </p>

          <div class="ascii-diagram">
            <pre>   +----------+
   |  LEADER  |  &lt;-- Elected via voting
   | (Queen)  |
   +----+-----+
        |
        | Heartbeats + Log Replication
        |
   +----+----+----+----+----+
   |    |    |    |    |    |
   v    v    v    v    v    v
 +--+ +--+ +--+ +--+ +--+ +--+
 |F1| |F2| |F3| |F4| |F5| |F6|  Followers
 +--+ +--+ +--+ +--+ +--+ +--+

 Leader fails? --&gt; New election
 Follower fails? --&gt; Continue with majority</pre>
          </div>

          <table class="char-table">
            <tbody><tr><th>Property</th><th>Value</th></tr>
            <tr><td>Consistency</td><td>Strong</td></tr>
            <tr><td>Fault tolerance</td><td>f &lt; n/2 (can lose up to half minus one)</td></tr>
            <tr><td>Latency</td><td>15-35ms</td></tr>
            <tr><td>Best for</td><td>Enterprise default, &lt;20 agents</td></tr>
          </tbody></table>
        </div>

        <!-- Byzantine -->
        <div class="consensus-card">
          <div class="consensus-header">
            <i data-lucide="shield" class="w-5 h-5 text-red-500"></i>
            Byzantine Fault Tolerant (BFT)
          </div>

          <p class="text-text-secondary mb-4">
            Handles malicious or buggy agents. Requires 2/3 majority to reach consensus. Higher latency but works even when some agents are actively sabotaging.
          </p>

          <table class="char-table">
            <tbody><tr><th>Property</th><th>Value</th></tr>
            <tr><td>Consistency</td><td>Strong</td></tr>
            <tr><td>Fault tolerance</td><td>f &lt; n/3 (tolerates up to 1/3 faulty)</td></tr>
            <tr><td>Latency</td><td>50-100ms</td></tr>
            <tr><td>Best for</td><td>Untrusted environments</td></tr>
          </tbody></table>
        </div>

        <!-- Gossip -->
        <div class="consensus-card" id="gossip">
          <div class="consensus-header">
            <i data-lucide="radio" class="w-5 h-5 text-purple-500"></i>
            Gossip Protocol
          </div>

          <p class="text-text-secondary mb-4">
            Eventual consistency for large swarms. Information spreads exponentially as nodes "gossip" to their neighbors.
          </p>

          <div class="ascii-diagram">
            <pre>Round 1:  Node A gossips to B, C, D
          +---+
          | A | ----&gt; B, C, D
          +---+

Round 2:  B, C, D gossip to their neighbors
          B ----&gt; E, F
          C ----&gt; G, H
          D ----&gt; I, J

Round N:  Eventually all nodes converge
          (Exponential spread)

Convergence: 99%+ agreement</pre>
          </div>

          <table class="char-table">
            <tbody><tr><th>Property</th><th>Value</th></tr>
            <tr><td>Consistency</td><td>Eventual</td></tr>
            <tr><td>Fault tolerance</td><td>f &lt; n/2</td></tr>
            <tr><td>Latency</td><td>10-40ms per round</td></tr>
            <tr><td>Best for</td><td>Large swarms (100+ agents)</td></tr>
          </tbody></table>
        </div>
      </section>

      <!-- Section 4: SELECTION GUIDE -->
      <section id="selection" data-activity="selection">
        <h2 class="section-title">
          <span class="section-number">4</span>
          Topology Selection Guide
        </h2>

        <p class="text-text-secondary mb-6">
          Use this decision tree to select the right topology for your use case.
        </p>

        <div class="selection-card">
          <div class="selection-question">What's your coordination need?</div>

          <div class="selection-answer">
            <i data-lucide="arrow-right" class="w-4 h-4 text-accent"></i>
            <span>Linear dependency (A must complete before B)?</span>
            <code>SequentialWorkflow</code>
          </div>

          <div class="selection-answer">
            <i data-lucide="arrow-right" class="w-4 h-4 text-accent"></i>
            <span>Independent parallel work?</span>
            <code>ConcurrentWorkflow</code>
          </div>

          <div class="selection-answer">
            <i data-lucide="arrow-right" class="w-4 h-4 text-accent"></i>
            <span>Boss delegates to workers with feedback?</span>
            <code>HierarchicalSwarm</code>
          </div>

          <div class="selection-answer">
            <i data-lucide="arrow-right" class="w-4 h-4 text-accent"></i>
            <span>Experts synthesize opinions?</span>
            <code>MixtureOfAgents</code>
          </div>

          <div class="selection-answer">
            <i data-lucide="arrow-right" class="w-4 h-4 text-accent"></i>
            <span>Complex dependencies (DAG)?</span>
            <code>GraphWorkflow</code>
          </div>

          <div class="selection-answer">
            <i data-lucide="arrow-right" class="w-4 h-4 text-accent"></i>
            <span>Dynamic routing to specialists?</span>
            <code>ForestSwarm</code>
          </div>

          <div class="selection-answer">
            <i data-lucide="arrow-right" class="w-4 h-4 text-accent"></i>
            <span>Peer-to-peer without central coordinator?</span>
            <code>Mesh</code>
          </div>

          <div class="selection-answer">
            <i data-lucide="arrow-right" class="w-4 h-4 text-accent"></i>
            <span>Conversational collaboration?</span>
            <code>GroupChat</code>
          </div>

          <div class="selection-answer">
            <i data-lucide="arrow-right" class="w-4 h-4 text-accent"></i>
            <span>Voting/consensus needed?</span>
            <code>MajorityVoting</code>
          </div>

          <div class="selection-answer">
            <i data-lucide="arrow-right" class="w-4 h-4 text-accent"></i>
            <span>Don't know? Let the framework decide:</span>
            <code>SwarmRouter(swarm_type="auto")</code>
          </div>
        </div>

        <!-- Scale-Based Selection -->
        <h3 class="font-semibold text-lg mb-4 mt-8" id="scale-selection">Scale-Based Selection</h3>

        <div class="overflow-x-auto mb-8">
          <table class="quick-ref-table">
            <thead>
              <tr>
                <th>Agent Count</th>
                <th>Recommended Topologies</th>
                <th>Notes</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>1</td>
                <td>Plain Agent class</td>
                <td>No orchestration needed</td>
              </tr>
              <tr>
                <td>2-5</td>
                <td>Sequential, Concurrent</td>
                <td>Simple coordination</td>
              </tr>
              <tr>
                <td>5-20</td>
                <td>Hierarchical, MoA, Mesh</td>
                <td>Medium complexity</td>
              </tr>
              <tr>
                <td>20-50</td>
                <td>GraphWorkflow, Star</td>
                <td>Structured dependencies</td>
              </tr>
              <tr>
                <td>50-100</td>
                <td>ForestSwarm, Hybrid</td>
                <td>Large agent pools</td>
              </tr>
              <tr>
                <td>100+</td>
                <td>Hybrid with Gossip consensus</td>
                <td>Factory scale</td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>

      <!-- Section 5: INFRASTRUCTURE -->
      <section id="ccswarm" data-activity="infrastructure">
        <h2 class="section-title">
          <span class="section-number">5</span>
          Infrastructure Patterns
        </h2>

        <h3 class="font-semibold text-lg mb-4">CCSwarm: Rust-Native Coordination</h3>

        <p class="text-text-secondary mb-4">
          CCSwarm uses Rust's type system to encode valid state machine transitions at compile time. Invalid sequences become compile errors, not runtime crashes.
        </p>

        <div class="code-block">
          <button class="copy-btn" onclick="copyCodeBlock(this)">
            <i data-lucide="copy" class="w-3 h-3"></i>
            Copy
          </button>
          <pre><span class="comment">// States are types, not runtime values</span>
<span class="keyword">struct</span> Uninitialized;
<span class="keyword">struct</span> Configured;
<span class="keyword">struct</span> Connected;
<span class="keyword">struct</span> Executing;

<span class="keyword">struct</span> Agent&lt;State&gt; {
    config: Option&lt;Config&gt;,
    connection: Option&lt;Connection&gt;,
    _state: PhantomData&lt;State&gt;,
}

<span class="comment">// Only valid transitions compile</span>
<span class="keyword">impl</span> Agent&lt;Uninitialized&gt; {
    <span class="keyword">fn</span> configure(self, config: Config) -&gt; Agent&lt;Configured&gt; {
        Agent {
            config: Some(config),
            connection: None,
            _state: PhantomData,
        }
    }
}

<span class="comment">// COMPILE ERROR: No such method on Agent&lt;Uninitialized&gt;</span>
<span class="comment">// agent.execute_task(task);  // Won't compile!</span></pre>
        </div>

        <h3 class="font-semibold text-lg mb-4 mt-8" id="nats">NATS Messaging Backbone (Station)</h3>

        <p class="text-text-secondary mb-4">
          Station uses NATS with JetStream for production-grade messaging infrastructure. The Lattice architecture allows stations to form a mesh network.
        </p>

        <div class="ascii-diagram">
          <pre>+------------------------------------------------------------------+
|                         LATTICE MESH                              |
|  +---------------+    +---------------+    +---------------+      |
|  |  Station A    |    |  Station B    |    |  Station C    |      |
|  |  (Security)   |&lt;--&gt;|  (Orchestr.)  |&lt;--&gt;|   (SRE)       |      |
|  |               |    |               |    |               |      |
|  | VulnScanner   |    | Coordinator   |    | K8sHealth     |      |
|  | CVELookup     |    |               |    | LogAnalyzer   |      |
|  +---------------+    +---------------+    +---------------+      |
|          |                   |                   |                 |
|          +-------------------+-------------------+                 |
|                              |                                    |
|                     +--------+--------+                           |
|                     |   NATS Server   |                           |
|                     |   + JetStream   |                           |
|                     +-----------------+                           |
+------------------------------------------------------------------+</pre>
        </div>

        <div class="overflow-x-auto mb-8">
          <table class="quick-ref-table">
            <thead>
              <tr>
                <th>Mode</th>
                <th>Command</th>
                <th>Purpose</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Standalone</td>
                <td><code>stn serve</code></td>
                <td>Default single-station, no mesh</td>
              </tr>
              <tr>
                <td>Orchestrator</td>
                <td><code>stn serve --orchestration</code></td>
                <td>Runs embedded NATS (port 4222)</td>
              </tr>
              <tr>
                <td>Member</td>
                <td><code>stn serve --lattice &lt;url&gt;</code></td>
                <td>Joins orchestrator mesh</td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>

      <!-- Section 6: GOTCHAS -->
      <section id="gotchas" data-activity="gotchas">
        <h2 class="section-title">
          <span class="section-number">6</span>
          Gotchas
        </h2>

        <p class="text-text-secondary mb-6">
          Topology-specific failures you'll encounter and how to fix them.
        </p>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Sequential chain breaks mid-execution
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Agent 1 completes -&gt; Agent 2 fails -&gt; Agent 3 never starts</div>
          <div class="gotcha-detail"><strong>Fix 1:</strong> Add retry logic with <code>max_loops=3</code></div>
          <div class="gotcha-detail"><strong>Fix 2:</strong> Implement per-agent fallback models</div>
          <div class="gotcha-detail"><strong>Fix 3:</strong> Add checkpointing between agents to resume from failure</div>
        </div>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Concurrent workflow produces inconsistent results
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Agent 1: "Price is $100", Agent 2: "Price is $150", Agent 3: "Price is $120"</div>
          <div class="gotcha-detail"><strong>Fix 1:</strong> Add aggregation step to synthesize conflicting information</div>
          <div class="gotcha-detail"><strong>Fix 2:</strong> Use MixtureOfAgents instead for built-in synthesis</div>
          <div class="gotcha-detail"><strong>Fix 3:</strong> Add MajorityVoting for factual questions</div>
        </div>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Hierarchical director bottleneck
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Director overwhelmed with 50+ workers, response times increasing</div>
          <div class="gotcha-detail"><strong>Fix 1:</strong> Add intermediate leaders (1 director + 5 team leads + 10 workers each)</div>
          <div class="gotcha-detail"><strong>Fix 2:</strong> Reduce feedback loop frequency</div>
          <div class="gotcha-detail"><strong>Fix 3:</strong> Switch to Hybrid topology with multiple hierarchies</div>
        </div>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Consensus never achieves
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> "Timeout: could not reach agreement"</div>
          <div class="gotcha-detail"><strong>Fix 1:</strong> Increase timeout (e.g., 10000ms)</div>
          <div class="gotcha-detail"><strong>Fix 2:</strong> Lower threshold (e.g., 0.5 instead of 0.66)</div>
          <div class="gotcha-detail"><strong>Fix 3:</strong> Switch algorithm (Gossip for scale, Raft for simplicity)</div>
          <div class="gotcha-detail"><strong>Fix 4:</strong> Check for network partitions or agent failures</div>
        </div>
      </section>

      <!-- Section 7: WHAT'S HARD -->
      <section id="hard" data-activity="hard">
        <h2 class="section-title">
          <span class="section-number">7</span>
          What's Hard
        </h2>

        <p class="text-text-secondary mb-6">
          These are fundamental tensions, not bugs to fix.
        </p>

        <div class="hard-box">
          <div class="hard-title">
            <i data-lucide="flame" class="w-4 h-4"></i>
            Topology Selection is Context-Dependent
          </div>
          <div class="hard-detail"><strong>The tension:</strong> The "best" topology depends on your specific workload, agent capabilities, latency requirements, and failure modes. There's no universal answer.</div>
          <div class="hard-detail"><strong>Symptoms:</strong> What works for 5 agents fails at 50. What works for code review fails for data analysis.</div>
          <div class="hard-detail"><strong>Mitigation:</strong> Start simple (Sequential/Concurrent), measure, then evolve. Use SwarmRouter auto-selection to learn what the framework thinks.</div>
        </div>

        <div class="hard-box">
          <div class="hard-title">
            <i data-lucide="flame" class="w-4 h-4"></i>
            Observability at Scale
          </div>
          <div class="hard-detail"><strong>The tension:</strong> With 50+ agents, understanding what's happening is hard. Traditional logging drowns in noise. Tracing helps but adds overhead.</div>
          <div class="hard-detail"><strong>Symptoms:</strong> "Something went wrong somewhere" - hard to diagnose which agent, which message, which decision.</div>
          <div class="hard-detail"><strong>Mitigation:</strong> Structured logging with correlation IDs. OpenTelemetry for distributed tracing. Accept that some opacity is the cost of scale.</div>
        </div>

        <div class="hard-box">
          <div class="hard-title">
            <i data-lucide="flame" class="w-4 h-4"></i>
            Cost Multiplies with Agents
          </div>
          <div class="hard-detail"><strong>The tension:</strong> More agents = more API calls = higher costs. A 10-agent concurrent workflow costs 10x a single agent.</div>
          <div class="hard-detail"><strong>Symptoms:</strong> Unexpected bills. "Why did that cost $50 for a simple task?"</div>
          <div class="hard-detail"><strong>Mitigation:</strong> Use smaller models for simpler agents. Implement caching. Consider Rust-based CCSwarm for 93% cost reduction claims.</div>
        </div>
      </section>

      <!-- Section 8: WHEN TO USE -->
      <section id="when" data-activity="when">
        <h2 class="section-title">
          <span class="section-number">8</span>
          When to Use / When Not
        </h2>

        <div class="when-grid">
          <div class="when-use">
            <div class="when-title">
              <i data-lucide="check" class="w-5 h-5"></i>
              USE SWARM TOPOLOGIES WHEN
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>Task can be decomposed into independent subtasks</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>Multiple perspectives improve output quality</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>Parallelism can reduce latency meaningfully</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>Fault tolerance is important (resilient topologies)</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>You have clear coordination requirements</span>
            </div>
          </div>

          <div class="when-not">
            <div class="when-title">
              <i data-lucide="x" class="w-5 h-5"></i>
              DON'T USE SWARM TOPOLOGIES WHEN
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>A single Claude session suffices</span>
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>Ralph pattern (simple loops) meets your needs</span>
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>Cost is primary concern (swarms multiply API calls)</span>
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>Debugging is hard enough already</span>
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>Team lacks distributed systems experience</span>
            </div>
          </div>
        </div>

        <p class="text-text-muted text-sm">
          <strong>Rule of thumb:</strong> Start with the simplest pattern that could work (often Sequential or Ralph loops). Add complexity only when you hit a wall that simpler approaches can't solve.
        </p>
      </section>

    