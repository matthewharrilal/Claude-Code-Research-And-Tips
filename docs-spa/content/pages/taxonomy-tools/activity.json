{
  "items": [
    {
      "id": "inv-1",
      "type": "inversion",
      "linkedSection": "essence",
      "title": "What if Claude had NO extension points?",
      "content": "<strong>You'd design:</strong> Custom forks of Claude Code for each use case.<br>\n          <strong>Why this fails:</strong> Maintenance nightmare. No ecosystem. No sharing.<br>\n          <strong>Hidden constraint revealed:</strong> Extension points ARE the product."
    },
    {
      "id": "min-2",
      "type": "minimal",
      "linkedSection": "essence",
      "title": "The simplest extension",
      "content": "<code style=\"background: #f4f4f5; padding: 2px 6px; border-radius: 4px; font-size: 12px;\">echo \"hello\" &gt;&gt; log.txt</code> in a PostToolUse hook.<br>\n          <strong>Essential:</strong> Event trigger + shell command.<br>\n          <strong>Everything else:</strong> Sophistication for specific problems."
    },
    {
      "id": "war-3",
      "type": "warstory",
      "linkedSection": "essence",
      "title": "@jarrodwatts: Claude HUD plugin",
      "content": "Built context visibility into Claude Code. \"I needed to see what was happening inside.\" Now shows context remaining, tools executing, subagents running - all via hooks updating every 300ms."
    },
    {
      "id": "ana-4",
      "type": "analogy",
      "linkedSection": "core",
      "title": "Claude Code Extensions = VS Code Extensions",
      "content": "Hooks = VS Code tasks<br>\n          MCP = Language Server Protocol<br>\n          Skills = Snippets + keybindings<br>\n          Plugins = Extension packs<br><br>\n          <em>If you've extended VS Code, you already understand the architecture.</em>"
    },
    {
      "id": "con-5",
      "type": "constraint",
      "linkedSection": "core",
      "title": "One constraint: Claude can't persist",
      "content": "<strong>ROOT:</strong> Claude instances are stateless between invocations<br>\n          → Need hooks for state persistence (SessionEnd)<br>\n          → Need MCP for external data access<br>\n          → Need skills for workflow memory<br>\n          → Need plugins to bundle persistence patterns<br>\n          → Need sub-agents to isolate state scope"
    },
    {
      "id": "inv-6",
      "type": "invariant",
      "linkedSection": "core",
      "title": "Every pattern needs external state",
      "content": "Ralph, Gas Town, CC Mirror all share INV-003: External state &gt; internal memory.<br>\n          <strong>Tools are the bridge:</strong> Hooks write state. MCP reads state. Skills define state schemas."
    },
    {
      "id": "grad-7",
      "type": "gradient",
      "linkedSection": "core",
      "title": "How extension complexity degrades",
      "content": "<strong>1-2 tools:</strong> Clear, maintainable<br>\n          <strong>3-5 tools:</strong> Interactions emerge, test harder<br>\n          <strong>6-10 tools:</strong> Debugging requires detective work<br>\n          <strong>10+ tools:</strong> \"Which layer broke?\"<br><br>\n          <em>Critical: Add tools slowly. Each doubles interaction surface.</em>"
    },
    {
      "id": "trade-8",
      "type": "tradeoff",
      "linkedSection": "decisions",
      "title": "Hooks vs Skills: The Automation Dilemma",
      "content": "<strong>Hooks:</strong> Deterministic, fast, no context cost. But no reasoning.<br>\n          <strong>Skills:</strong> Reasoning, flexible, context-aware. But consume tokens.<br><br>\n          <strong>Heuristic:</strong> If the task never varies, use a hook. If it needs judgment, use a skill."
    },
    {
      "id": "exp-9",
      "type": "expertise",
      "linkedSection": "decisions",
      "title": "How deep is your tool understanding?",
      "content": "<strong>Beginner:</strong> \"What tools exist?\" → The 5 types<br>\n          <strong>Intermediate:</strong> \"Which one for my problem?\" → Decision criteria<br>\n          <strong>Advanced:</strong> \"How do they compose?\" → Hook + MCP + skill combos<br>\n          <strong>Staff:</strong> \"What's the context cost?\" → Token budgeting<br>\n          <strong>Expert:</strong> \"How do I build new types?\" → Plugin development"
    },
    {
      "id": "vio-10",
      "type": "violation",
      "linkedSection": "decisions",
      "title": "If you use MCP when you need a hook",
      "content": "<strong>IF:</strong> Use MCP server for simple automation<br>\n          <strong>THEN:</strong> Server adds tool descriptions to context<br>\n          <strong>THEN:</strong> Claude reasons about whether to use it<br>\n          <strong>THEN:</strong> Sometimes it doesn't (LLM variance)<br>\n          <strong>FINALLY:</strong> Inconsistent automation<br><br>\n          <em>The fix: Hooks are deterministic. Use them for must-always-happen.</em>"
    },
    {
      "id": "hor-11",
      "type": "horizon",
      "linkedSection": "decisions",
      "title": "How tool choice looks over time",
      "content": "<strong>Day 1:</strong> \"I'll just add this MCP server\"<br>\n          <strong>Week 1:</strong> \"Why are there 8 MCP servers?\"<br>\n          <strong>Month 1:</strong> \"Context is always 60% MCP tool descriptions\"<br>\n          <strong>Month 3:</strong> \"I disabled 5 servers and everything improved\"<br><br>\n          <em>Audit your tools monthly. Remove unused ones.</em>"
    },
    {
      "id": "inv-12",
      "type": "inversion",
      "linkedSection": "decisions",
      "title": "What if MCP didn't exist?",
      "content": "<strong>You'd build:</strong> Custom tool integrations for each AI system.<br>\n          <strong>Why this fails:</strong> No ecosystem. Every integration is bespoke.<br>\n          <strong>Hidden constraint revealed:</strong> MCP is \"USB-C for AI\" - standardization enables ecosystem."
    },
    {
      "id": "comp-13",
      "type": "composition",
      "linkedSection": "categories",
      "title": "Hooks + MCP Memory Server",
      "content": "<strong>Works:</strong> SessionEnd hook triggers MCP memory save.<br>\n          <strong>Danger:</strong> Memory server is another context consumer.<br>\n          <strong>Recommendation:</strong> Use for long-running projects. Skip for quick tasks."
    },
    {
      "id": "comp-14",
      "type": "composition",
      "linkedSection": "categories",
      "title": "Skills + Sub-Agents",
      "content": "<strong>Works:</strong> Orchestrator skill spawns specialized sub-agents.<br>\n          <strong>Danger:</strong> Orchestration overhead. Sub-agent context isolation means repeated setup.<br>\n          <strong>Recommendation:</strong> Use for parallel tasks. CC Mirror skill is the reference implementation."
    },
    {
      "id": "eff-15",
      "type": "effect",
      "linkedSection": "categories",
      "title": "At 5+ MCP servers, discovery breaks",
      "content": "<strong>IMPLICATION:</strong> Claude can't reason about 20+ tools effectively. It starts ignoring some.<br>\n          <strong>THRESHOLD:</strong> ~5 MCP servers before you need explicit tool selection in prompts."
    },
    {
      "id": "war-16",
      "type": "warstory",
      "linkedSection": "categories",
      "title": "@thedotmack: Claude-Mem plugin",
      "content": "Built persistent memory with semantic compression. \"Up to 95% fewer tokens, ~20x more tool calls.\" 3-layer retrieval: search() → timeline() → get_observations(). SQLite + Chroma vector DB."
    },
    {
      "id": "ana-17",
      "type": "analogy",
      "linkedSection": "categories",
      "title": "Sub-Agents = Microservices",
      "content": "Haiku = Lambda function (cheap, fast, stateless)<br>\n          Sonnet = Container (capable, balanced)<br>\n          Opus = Full VM (expensive, powerful, for complex reasoning)<br><br>\n          <em>Match agent model to task complexity, like matching compute to workload.</em>"
    },
    {
      "id": "fron-18",
      "type": "frontier",
      "linkedSection": "categories",
      "title": "UNSOLVED: Optimal tool discovery",
      "content": "<strong>THE QUESTION:</strong> How should Claude discover which tools to use among 50+ options?<br>\n          <strong>WHY IT'S HARD:</strong> Tool descriptions consume context. Reasoning about tools consumes tokens.<br>\n          <strong>CURRENT PRACTICE:</strong> Manual curation. Disable unused servers."
    },
    {
      "id": "vio-19",
      "type": "violation",
      "linkedSection": "path",
      "title": "If you skip chmod +x on your hook script",
      "content": "<strong>IF:</strong> Hook script not executable<br>\n          <strong>THEN:</strong> Hook silently fails (no error, just doesn't run)<br>\n          <strong>THEN:</strong> You think hooks don't work<br>\n          <strong>THEN:</strong> Hours debugging the wrong layer<br>\n          <strong>FINALLY:</strong> \"Oh, it was just chmod\"<br><br>\n          <em>The fix: Always chmod +x. Always test scripts manually first.</em>"
    },
    {
      "id": "inf-20",
      "type": "inflection",
      "linkedSection": "path",
      "title": "When PreToolUse gates flip from help to hurt",
      "content": "<strong>0-2 gates:</strong> Pure benefit (catch dangerous commands)<br>\n          <strong>3-5 gates:</strong> Friction noticeable (more blocked operations)<br>\n          <strong>5+ gates:</strong> Net negative (Claude workarounds, user frustration)<br><br>\n          <strong>THE INFLECTION:</strong> ~3 PreToolUse gates<br>\n          <em>Detection: Are you approving gates more than they're blocking bad actions?</em>"
    },
    {
      "id": "exp-21",
      "type": "expertise",
      "linkedSection": "path",
      "title": "Hook debugging understanding",
      "content": "<strong>Beginner:</strong> \"Why isn't my hook running?\" → Check chmod, check path<br>\n          <strong>Intermediate:</strong> \"How do I debug hook input?\" → Log $EVENT_DATA<br>\n          <strong>Advanced:</strong> \"How do I test without Claude?\" → Manual: TOOL_NAME=X ./script.sh<br>\n          <strong>Staff:</strong> \"How do I audit all hook executions?\" → Centralized logging hook"
    },
    {
      "id": "inv-22",
      "type": "inversion",
      "linkedSection": "gotchas",
      "title": "Why is matcher case-sensitive?",
      "content": "<strong>What if it wasn't?</strong> \"bash\" would match \"Bash\" would match \"BASH\".<br>\n          <strong>Why this fails:</strong> Tool names are identifiers, not strings. Consistency matters.<br>\n          <strong>Hidden constraint:</strong> The constraint IS the documentation. If you get the case wrong, you learn the right case."
    },
    {
      "id": "trade-23",
      "type": "tradeoff",
      "linkedSection": "gotchas",
      "title": "Skill Auto-Loading vs Explicit Loading",
      "content": "<strong>Auto-load:</strong> Convenient when it works. Mysterious when it doesn't.<br>\n          <strong>Explicit:</strong> Reliable but requires knowing skill name.<br><br>\n          <strong>Heuristic:</strong> Use auto-load for frequently-used skills. Use explicit for rare skills."
    },
    {
      "id": "eff-24",
      "type": "effect",
      "linkedSection": "gotchas",
      "title": "At 10+ skills, naming collisions emerge",
      "content": "<strong>IMPLICATION:</strong> Two skills with similar triggers compete. Claude picks semi-randomly.<br>\n          <strong>THRESHOLD:</strong> ~10 skills before you need naming conventions.<br>\n          <strong>FIX:</strong> Prefix skills: <code>project-</code>, <code>domain-</code>, <code>workflow-</code>"
    },
    {
      "id": "war-25",
      "type": "warstory",
      "linkedSection": "gotchas",
      "title": "Sub-agent timeout debugging",
      "content": "\"Spent 2 hours debugging why sub-agents weren't returning. The task was 'implement the entire auth system' - too big. Split into 5 focused tasks, all completed in minutes.\" The lesson: sub-agents need atomic tasks."
    },
    {
      "id": "con-26",
      "type": "constraint",
      "linkedSection": "hard",
      "title": "Context budget constraint cascades",
      "content": "<strong>ROOT:</strong> 200K context window is fixed<br>\n          → MCP tool descriptions consume context<br>\n          → Skills consume context when loaded<br>\n          → Sub-agent results consume context when returned<br>\n          → Every extension competes for same budget<br>\n          → More tools = less room for actual work"
    },
    {
      "id": "trade-27",
      "type": "tradeoff",
      "linkedSection": "hard",
      "title": "Capability vs Simplicity",
      "content": "<strong>More tools:</strong> More capability, but more complexity, more debugging, more context cost.<br>\n          <strong>Fewer tools:</strong> Simpler, faster, cheaper. But capability gaps.<br><br>\n          <strong>WHY NO PERFECT ANSWER:</strong> Your needs change. Today's \"essential\" tool is tomorrow's context waste."
    },
    {
      "id": "grad-28",
      "type": "gradient",
      "linkedSection": "hard",
      "title": "How debugging difficulty scales",
      "content": "<strong>1 layer (just hooks):</strong> Easy - check script output<br>\n          <strong>2 layers (hooks + MCP):</strong> Medium - check both<br>\n          <strong>3 layers (hooks + MCP + skills):</strong> Hard - which layer failed?<br>\n          <strong>4+ layers:</strong> Detective work - disable and re-enable<br><br>\n          <em>Critical: Add layers slowly. Test each layer in isolation.</em>"
    },
    {
      "id": "fron-29",
      "type": "frontier",
      "linkedSection": "hard",
      "title": "UNSOLVED: Tool cost attribution",
      "content": "<strong>THE QUESTION:</strong> Which tools are worth their context cost? How do you measure ROI?<br>\n          <strong>WHY IT'S HARD:</strong> Value is subjective. Context cost is measurable but benefit isn't.<br>\n          <strong>CURRENT PRACTICE:</strong> Gut feel. Remove tools that \"feel unused.\""
    },
    {
      "id": "alt-30",
      "type": "alternative",
      "linkedSection": "when",
      "title": "If these tools aren't right for your use case",
      "content": "<strong>Need browser automation?</strong> → Playwright MCP or Browserbase<br>\n          <strong>Need persistent memory?</strong> → Claude-Mem plugin or MCP Memory Server<br>\n          <strong>Need multi-agent orchestration?</strong> → CC Mirror skill<br>\n          <strong>Need context visibility?</strong> → Claude HUD plugin"
    },
    {
      "id": "ana-31",
      "type": "analogy",
      "linkedSection": "when",
      "title": "Tool Selection = Architecture Selection",
      "content": "Hooks = Synchronous middleware<br>\n          MCP = API gateway<br>\n          Skills = Domain services<br>\n          Sub-agents = Worker processes<br>\n          Plugins = Microservice bundles<br><br>\n          <em>Choose tools like you choose architecture: simplest that works.</em>"
    },
    {
      "id": "hor-32",
      "type": "horizon",
      "linkedSection": "when",
      "title": "How tool needs evolve",
      "content": "<strong>Week 1:</strong> \"I need everything!\" (install all MCP servers)<br>\n          <strong>Month 1:</strong> \"Why is Claude so slow?\" (context bloat)<br>\n          <strong>Month 3:</strong> \"Less is more\" (curated tool set)<br>\n          <strong>Month 6:</strong> \"I build my own\" (custom plugins)<br><br>\n          <em>Everyone goes through the bloat-then-curate cycle.</em>"
    },
    {
      "id": "inv-33",
      "type": "invariant",
      "linkedSection": "when",
      "title": "All orchestration patterns use these tools",
      "content": "<strong>Ralph:</strong> Stop hook for loop continuation<br>\n          <strong>Gas Town:</strong> Sub-agents as Polecats<br>\n          <strong>CC Mirror:</strong> Skill for orchestration, sub-agents for workers<br><br>\n          <em>Master these tools, master the patterns.</em>"
    }
  ]
}