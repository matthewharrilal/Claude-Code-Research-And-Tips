<!--
═══════════════════════════════════════════════════════════════════════════════
INLINE THREADING HEADER — Phase 2B
File: docs-spa/content/pages/transform-generalist-to-swarm/content.html
Tier: C | Batch: 13 | Generated: 2026-02-06

1. WHY THIS EXISTS
Rendered HTML content page for the transform-generalist-to-swarm synthesis document.

3. STATUS
ACTIVE

5. BUILT ON
Extracted from synthesis/transform-generalist-to-swarm.md by content extraction scripts.

8. CONSUMED BY
docs-spa/app/(docs)/synthesis/transform-generalist-to-swarm/page.tsx renders this content via dangerouslySetInnerHTML.

═══════════════════════════════════════════════════════════════════════════════
END INLINE THREADING HEADER
═══════════════════════════════════════════════════════════════════════════════
-->

      <!-- Section 1: ESSENCE -->
      <section id="essence" data-activity="essence">
        <div class="essence-box">
          <div class="essence-label">Essence (15 words)</div>
          <div class="essence-text">Replace context-diluted generalist with focused domain specialists coordinated by a non-coding orchestrator.</div>
        </div>

        <p class="text-text-secondary mb-6">
          <strong>You Are Here:</strong> This document shows how to evolve from a single agent doing everything (poorly) to specialized workers doing their domains excellently. If your full-stack features have inconsistent quality or take forever due to context dilution, the swarm pattern solves this.
        </p>

        <p class="text-text-secondary mb-6">
          This connects to Level 5-6 (CC Mirror Hub-and-Spoke) on the complexity ladder and enables true parallel execution with domain expertise.
        </p>
      </section>

      <!-- Section 2: CORE ABSTRACTION + IMPLEMENTATION -->
      <section id="core-abstraction" data-activity="core">
        <h2 class="section-title">
          <span class="section-number">2</span>
          The Core Abstraction
        </h2>

        <div class="core-abstraction">
          <div class="core-philosophy">"Single context tries to be everything. Domain specialists excel at one thing."</div>

          <div class="core-code">
            <button class="copy-btn" onclick="copyCode(this, 'Orchestrator (coordinates) + Workers (execute) = Swarm')">
              <i data-lucide="copy" class="w-3 h-3"></i>
              Copy
            </button>
            <code>Orchestrator (coordinates) + Workers (execute) = Swarm</code>
          </div>

          <div class="core-anchor">The orchestrator never touches code. Workers never spawn subworkers. That's the iron law.</div>
        </div>

        <p class="text-text-secondary mb-6">
          The transformation is from single-context generalist to orchestrated domain specialists. Instead of one Claude instance handling database, API, frontend, and tests sequentially (with context dilution killing quality by the end), you have dedicated workers for each domain running in parallel.
        </p>

        <h3 class="font-semibold text-lg mb-4 mt-8" id="before-after">The Before and After</h3>

        <!-- Before: Generalist -->
        <div class="architecture-diagram">
          <pre>BEFORE: GENERALIST AGENT (Single Instance)
========================================

Context Window (filling up...)
┌─────────────────────────────────────────────────────┐
│ DB schema design decisions...                        │
│ SQL migration syntax...                              │
│ API route patterns...                                │
│ JWT token implementation...                          │
│ React component structure...                         │
│ Form validation patterns...                          │
│ Test setup boilerplate...                           │
│ Mock configuration...                                │
│ [CONTEXT GETTING CROWDED]                           │
└─────────────────────────────────────────────────────┘

Execution: Sequential
Step 1: Design schema          [45 min]
Step 2: Write migrations       [30 min]
Step 3: Implement API          [60 min]
Step 4: Build UI components    [45 min]
Step 5: Write tests            [60 min]
─────────────────────────────────────
Total:                         [240 min = 4 hours]
          </pre>
        </div>

        <!-- After: Swarm -->
        <div class="architecture-diagram">
          <pre>AFTER: SPECIALIZED SWARM (CC Mirror Pattern)
============================================

           ┌─────────────────────────────────┐
           │       ORCHESTRATOR              │
           │       (Opus 4.5)                │
           │                                 │
           │  "I coordinate. I never code."  │
           │                                 │
           │  Tools: Task*, Read (minimal)   │
           └─────────────┬───────────────────┘
                         │
        ┌────────────────┼────────────────┐
        │                │                │
        ▼                ▼                ▼
┌─────────────┐  ┌─────────────┐  ┌─────────────┐
│  BACKEND    │  │  FRONTEND   │  │   TEST      │
│  WORKER     │  │  WORKER     │  │   WORKER    │
│  (Sonnet)   │  │  (Sonnet)   │  │  (Haiku)    │
│             │  │             │  │             │
│ DB schema   │  │ UI comps    │  │ Integration │
│ Migrations  │  │ Forms       │  │ tests       │
│ API routes  │  │ Auth ctx    │  │ E2E tests   │
└─────────────┘  └─────────────┘  └─────────────┘

Execution:
├── Backend Worker    ████████░░  [60 min]
├── Frontend Worker   ████████░░  [45 min] (parallel after APIs)
└── Test Worker       ██████░░░░  [30 min] (after both complete)
─────────────────────────────────────────
Total Wall Clock:     [~90 min with dependencies]
          </pre>
        </div>

        <h3 class="font-semibold text-lg mb-4 mt-8">Quality Distribution Comparison</h3>

        <div class="quality-bar">
          <div class="quality-label">Database (Generalist): 40%</div>
          <div class="quality-track">
            <div class="quality-fill low" style="width: 40%;"></div>
          </div>
        </div>

        <div class="quality-bar">
          <div class="quality-label">Database (Swarm): 85%</div>
          <div class="quality-track">
            <div class="quality-fill high" style="width: 85%;"></div>
          </div>
        </div>

        <div class="quality-bar">
          <div class="quality-label">API (Generalist): 50%</div>
          <div class="quality-track">
            <div class="quality-fill medium" style="width: 50%;"></div>
          </div>
        </div>

        <div class="quality-bar">
          <div class="quality-label">API (Swarm): 80%</div>
          <div class="quality-track">
            <div class="quality-fill high" style="width: 80%;"></div>
          </div>
        </div>

        <div class="quality-bar">
          <div class="quality-label">Frontend (Generalist): 30%</div>
          <div class="quality-track">
            <div class="quality-fill low" style="width: 30%;"></div>
          </div>
        </div>

        <div class="quality-bar">
          <div class="quality-label">Frontend (Swarm): 75%</div>
          <div class="quality-track">
            <div class="quality-fill high" style="width: 75%;"></div>
          </div>
        </div>

        <div class="quality-bar">
          <div class="quality-label">Tests (Generalist): 20%</div>
          <div class="quality-track">
            <div class="quality-fill low" style="width: 20%;"></div>
          </div>
        </div>

        <div class="quality-bar">
          <div class="quality-label">Tests (Swarm): 80%</div>
          <div class="quality-track">
            <div class="quality-fill high" style="width: 80%;"></div>
          </div>
        </div>

        <p class="text-text-muted text-sm mt-4 mb-8">
          <strong>Generalist average: 35%</strong> | <strong>Swarm average: 80%</strong><br>
          Tests suffer most in generalist mode because they come last, when context is most crowded.
        </p>
      </section>

      <!-- Section 3: DESIGN DECISIONS -->
      <section id="why-specialization" data-activity="decisions">
        <h2 class="section-title">
          <span class="section-number">3</span>
          Design Decisions
        </h2>

        <div class="decision-box">
          <div class="decision-why">WHY SPECIALIZATION?</div>
          <div class="decision-reasoning">
            Each worker loads only relevant patterns. A backend worker doesn't pollute its context with React component patterns. A test worker doesn't carry API implementation details. Fresh, focused contexts outperform crowded, diluted ones.
          </div>
          <div class="decision-implication">
            <div class="decision-implication-label">What this means for you</div>
            <div class="text-text-secondary text-sm">
              Design worker prompts with explicit scope boundaries. "You handle /src/api/** ONLY. Do NOT touch /src/components/**." The boundaries aren't bureaucracy - they're what makes specialization work.
            </div>
          </div>
        </div>

        <div class="decision-box" id="why-parallelism">
          <div class="decision-why">WHY PARALLELISM?</div>
          <div class="decision-reasoning">
            Wall-clock time matters for human productivity. 4 hours sequential means you wait all afternoon. 90 minutes parallel (with dependencies) means you're reviewing code after lunch. The productivity gain isn't theoretical - it's hours back in your day.
          </div>
          <div class="decision-implication">
            <div class="decision-implication-label">What this means for you</div>
            <div class="text-text-secondary text-sm">
              Identify which tasks can run in parallel (no dependencies) vs sequential (blocked by others). Use <code>run_in_background: true</code> for parallel tasks. Don't serialize work that doesn't need serialization.
            </div>
          </div>
        </div>

        <div class="decision-box" id="why-orchestrator">
          <div class="decision-why">WHY A NON-CODING ORCHESTRATOR?</div>
          <div class="decision-reasoning">
            If the orchestrator starts writing code, it stops being an orchestrator. It becomes just another generalist with extra complexity. The orchestrator's only job is coordination: spawn workers, track completion, synthesize results. This separation is what makes swarms manageable.
          </div>
          <div class="decision-implication">
            <div class="decision-implication-label">What this means for you</div>
            <div class="text-text-secondary text-sm">
              Enforce the iron law: "You do NOT write code. You do NOT run commands. You ONLY coordinate workers." Put this in the orchestrator's system prompt. If you see the orchestrator touching files, your prompts are broken.
            </div>
          </div>
        </div>
      </section>

      <!-- Section 4: IMPLEMENTATION -->
      <section id="orchestrator-prompt" data-activity="implementation">
        <h2 class="section-title">
          <span class="section-number">4</span>
          Implementation
        </h2>

        <h3 class="font-semibold text-lg mb-4">Orchestrator System Prompt</h3>

        <div class="code-block">
          <button class="copy-btn" onclick="copyCodeBlock(this)">
            <i data-lucide="copy" class="w-3 h-3"></i>
            Copy
          </button>
          <pre><span class="comment"># ORCHESTRATOR SYSTEM PROMPT</span>

You are the orchestrator for building a user authentication system.

<span class="comment">## IRON LAW</span>
- You do NOT write code
- You do NOT run commands
- You do NOT explore codebases directly
- You ONLY coordinate workers

<span class="comment">## YOUR TOOLS</span>
- Task (to spawn workers)
- Read (only for high-level overview, 1-2 files max)

<span class="comment">## TASK BREAKDOWN</span>

1. <span class="keyword">Backend Task</span> (blocked_by: none)
   - Design and implement users/sessions schema
   - Create API endpoints: register, login, logout, refresh
   - Run backend tests before reporting complete

2. <span class="keyword">Frontend Task</span> (blocked_by: Backend Task)
   - Create LoginForm, RegistrationForm components
   - Implement AuthContext provider
   - Wire up to API endpoints
   - Run component tests before reporting complete

3. <span class="keyword">Test Task</span> (blocked_by: Frontend Task)
   - Write integration tests for auth flow
   - Write E2E test for complete user journey
   - Verify all tests pass

<span class="comment">## WORKFLOW</span>
1. Spawn Backend Worker (run_in_background: true)
2. Wait for Backend completion
3. Spawn Frontend Worker (run_in_background: true)
4. Wait for Frontend completion
5. Spawn Test Worker
6. Synthesize results and report to human</pre>
        </div>

        <h3 class="font-semibold text-lg mb-4 mt-8" id="worker-preambles">Worker Preambles</h3>

        <p class="text-text-secondary mb-4">Every worker prompt must include these elements:</p>

        <div class="code-block">
          <button class="copy-btn" onclick="copyCodeBlock(this)">
            <i data-lucide="copy" class="w-3 h-3"></i>
            Copy
          </button>
          <pre><span class="comment"># WORKER CONTEXT</span>

ROLE: Backend Worker
SCOPE: Database schema and API endpoints ONLY

<span class="comment">## RULES</span>
- Complete ONLY the task described below
- Use tools directly (Read, Write, Edit, Bash, Glob, Grep)
- Do NOT spawn sub-agents
- Do NOT call Task or TaskCreate
- Report results with absolute file paths

<span class="comment">## AVAILABLE TOOLS</span>
Read, Write, Edit, Bash, Glob, Grep, WebSearch

<span class="comment">## TASK</span>
Implement user authentication backend:

1. <span class="keyword">Database Schema</span>
   - users table (id, email, password_hash, created_at, updated_at)
   - sessions table (id, user_id, token, expires_at, created_at)
   - Use existing migration patterns in /db/migrations/

2. <span class="keyword">API Endpoints</span>
   - POST /auth/register
   - POST /auth/login
   - POST /auth/logout
   - POST /auth/refresh
   - Follow patterns in /src/api/

3. <span class="keyword">Verification</span>
   - Run: npm run test:backend
   - All tests must pass before reporting complete

<span class="comment">## DELIVERABLES</span>
Report with:
- Files created/modified (absolute paths)
- Any blockers encountered
- Test results summary</pre>
        </div>

        <h3 class="font-semibold text-lg mb-4 mt-8" id="execution-patterns">Execution Patterns</h3>

        <h4 class="font-medium text-base mb-3">Manual Swarm (No Infrastructure)</h4>

        <div class="code-block">
          <button class="copy-btn" onclick="copyCodeBlock(this)">
            <i data-lucide="copy" class="w-3 h-3"></i>
            Copy
          </button>
          <pre><span class="comment"># Terminal 1: Backend Worker</span>
cd ~/project
claude --print <span class="string">"You are a backend worker. Implement auth DB and API..."</span> &gt; backend.log &amp;

<span class="comment"># Wait for backend to complete (monitor backend.log)</span>
<span class="comment"># Then Terminal 2: Frontend Worker</span>
claude --print <span class="string">"You are a frontend worker. Implement auth UI..."</span> &gt; frontend.log &amp;

<span class="comment"># Wait for frontend to complete</span>
<span class="comment"># Then Terminal 3: Test Worker</span>
claude --print <span class="string">"You are a test worker. Write integration tests..."</span> &gt; test.log</pre>
        </div>

        <h4 class="font-medium text-base mb-3 mt-6">Git Worktrees (Filesystem Isolation)</h4>

        <div class="code-block">
          <button class="copy-btn" onclick="copyCodeBlock(this)">
            <i data-lucide="copy" class="w-3 h-3"></i>
            Copy
          </button>
          <pre><span class="comment"># Create worktrees for each worker</span>
git worktree add ../auth-backend feature/auth-backend
git worktree add ../auth-frontend feature/auth-frontend
git worktree add ../auth-tests feature/auth-tests

<span class="comment"># Run workers in parallel</span>
(cd ../auth-backend &amp;&amp; claude <span class="string">"Implement auth backend..."</span>) &amp;
(cd ../auth-frontend &amp;&amp; claude <span class="string">"Implement auth frontend..."</span>) &amp;
wait

<span class="comment"># Sequential tests after parallel work completes</span>
cd ../auth-tests &amp;&amp; claude <span class="string">"Write auth tests..."</span>

<span class="comment"># Merge back</span>
git checkout main
git merge feature/auth-backend
git merge feature/auth-frontend
git merge feature/auth-tests</pre>
        </div>

        <div class="checkpoint-box">
          <div class="checkpoint-title">
            <i data-lucide="check-circle" class="w-4 h-4"></i>
            Checkpoint: After Git Worktrees Setup
          </div>
          <div class="checkpoint-detail"><strong>Where you are:</strong> You have isolated filesystem environments for parallel agent work via git worktrees.</div>
          <div class="checkpoint-detail"><strong>Verify with:</strong> <code>git worktree list</code> - should show 4 entries (main + 3 worktrees)</div>
          <div class="checkpoint-detail"><strong>You should see:</strong> Each worktree on its own branch, independent file changes don't interfere.</div>
        </div>

        <h4 class="font-medium text-base mb-3 mt-6">CC Mirror Native (Task Tool)</h4>

        <div class="code-block">
          <button class="copy-btn" onclick="copyCodeBlock(this)">
            <i data-lucide="copy" class="w-3 h-3"></i>
            Copy
          </button>
          <pre><span class="comment"># .claude/orchestrator.md</span>

You are an orchestrator. Your only tool is Task.

For this session, break work into:
1. Backend tasks (subagent_type: <span class="string">"coder"</span>)
2. Frontend tasks (subagent_type: <span class="string">"coder"</span>)
3. Test tasks (subagent_type: <span class="string">"coder"</span>)

Each worker prompt must include:
- WORKER CONTEXT header
- Explicit scope boundaries
- <span class="string">"Do NOT spawn sub-agents"</span> rule
- Required verification steps</pre>
        </div>
      </section>

      <!-- Section 5: PATH OF A TASK -->
      <section id="path" data-activity="path">
        <h2 class="section-title">
          <span class="section-number">5</span>
          The Path of a Task
        </h2>

        <p class="text-text-secondary mb-6">
          Follow a full-stack feature through the swarm to see how coordination works:
        </p>

        <div class="path-container">
          <div class="path-step">
            <div class="path-number">1</div>
            <div class="path-content">Orchestrator receives task: "Build user authentication system"</div>
          </div>
          <div class="path-step">
            <div class="path-number">2</div>
            <div class="path-content">Orchestrator decomposes into worker tasks with dependency graph</div>
          </div>
          <div class="path-step">
            <div class="path-number">3</div>
            <div class="path-content">Spawns Backend Worker with <code>run_in_background: true</code></div>
          </div>
          <div class="path-step">
            <div class="path-number">4</div>
            <div class="path-content">Backend Worker creates migrations, implements endpoints, runs tests</div>
          </div>
          <div class="path-step">
            <div class="path-number">5</div>
            <div class="path-content">Backend Worker reports: 8 files modified, 12 tests passing</div>
          </div>
          <div class="path-step">
            <div class="path-number">6</div>
            <div class="path-content">Orchestrator validates completion, spawns Frontend Worker</div>
          </div>
          <div class="path-step">
            <div class="path-number">7</div>
            <div class="path-content">Frontend Worker creates components, implements AuthContext, runs tests</div>
          </div>
          <div class="path-step">
            <div class="path-number">8</div>
            <div class="path-content">Frontend Worker reports: 6 files modified, 8 tests passing</div>
          </div>
          <div class="path-step">
            <div class="path-number">9</div>
            <div class="path-content">Orchestrator validates, spawns Test Worker (depends on both)</div>
          </div>
          <div class="path-step">
            <div class="path-number">10</div>
            <div class="path-content">Test Worker writes integration and E2E tests, verifies full flow</div>
          </div>
          <div class="path-step">
            <div class="path-number">11</div>
            <div class="path-content">Test Worker reports: 2 files created, 10 tests passing</div>
          </div>
          <div class="path-step">
            <div class="path-number">12</div>
            <div class="path-content">Orchestrator synthesizes results, reports to human: 16 files, 30 tests, ready for review</div>
          </div>
        </div>

        <h3 class="font-semibold text-lg mb-4">Orchestrator Execution Log</h3>

        <div class="architecture-diagram">
          <pre>ORCHESTRATOR LOG
================================================================

[00:00] Received task: Build user authentication system

[00:01] Decomposing into worker tasks...
        Task 1: Backend (DB + API)     [no dependencies]
        Task 2: Frontend (UI + State)  [depends on: Backend]
        Task 3: Tests (Integration/E2E) [depends on: Frontend]

[00:02] Spawning Backend Worker (run_in_background: true)
        -&gt; Worker ID: backend-auth-001

[00:45] Backend Worker completed
        -&gt; Files modified: 8
        -&gt; /db/migrations/20260109_users.sql
        -&gt; /db/migrations/20260109_sessions.sql
        -&gt; /src/api/auth/register.ts
        -&gt; /src/api/auth/login.ts
        -&gt; /src/api/auth/logout.ts
        -&gt; /src/api/auth/refresh.ts
        -&gt; /src/api/auth/index.ts
        -&gt; /src/api/auth/__tests__/auth.test.ts
        -&gt; Tests: 12 passed, 0 failed

[00:46] Spawning Frontend Worker (run_in_background: true)
        -&gt; Worker ID: frontend-auth-001

[01:15] Frontend Worker completed
        -&gt; Files modified: 6
        -&gt; /src/components/auth/LoginForm.tsx
        -&gt; /src/components/auth/RegistrationForm.tsx
        -&gt; /src/components/auth/ProtectedRoute.tsx
        -&gt; /src/context/AuthContext.tsx
        -&gt; /src/hooks/useAuth.ts
        -&gt; /src/components/auth/__tests__/auth.test.tsx
        -&gt; Tests: 8 passed, 0 failed

[01:16] Spawning Test Worker
        -&gt; Worker ID: test-auth-001

[01:35] Test Worker completed
        -&gt; Files created: 2
        -&gt; /tests/integration/auth.integration.test.ts
        -&gt; /tests/e2e/auth.e2e.spec.ts
        -&gt; Integration tests: 6 passed
        -&gt; E2E tests: 4 passed

[01:36] SYNTHESIS
        ========================================

        Authentication system complete.

        Total files: 16
        Total tests: 30 (all passing)

        Backend:  /src/api/auth/
        Frontend: /src/components/auth/, /src/context/
        Tests:    /tests/integration/, /tests/e2e/

        Ready for human review.

================================================================
          </pre>
        </div>
      </section>

      <!-- Section 6: GOTCHAS -->
      <section id="gotchas" data-activity="gotchas">
        <h2 class="section-title">
          <span class="section-number">6</span>
          Gotchas
        </h2>

        <p class="text-text-secondary mb-6">
          Real problems you'll hit when running swarms, with concrete fixes:
        </p>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Workers Interfere With Each Other's Files
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Merge conflicts when combining worker output. One worker overwrites another's changes.</div>
          <div class="gotcha-detail"><strong>Cause:</strong> Workers are operating on overlapping file scopes without isolation.</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Use git worktrees for filesystem isolation, OR include explicit scope boundaries in worker prompts: "SCOPE: Only modify files in /src/api/** - do NOT touch /src/components/**"</div>
        </div>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Orchestrator Waits Too Long (No Parallelism)
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Workers run sequentially when they could run in parallel. Total time = sum of all workers.</div>
          <div class="gotcha-detail"><strong>Cause:</strong> Dependencies defined too conservatively, or <code>run_in_background: true</code> not used.</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Identify truly independent tasks. Backend static setup and frontend static components often have no real dependencies - run them parallel. Only serialize when there's a genuine data dependency.</div>
        </div>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Worker Spawns Sub-Workers (Nesting)
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Backend worker spawns "DB worker" and "API worker". Deep hierarchy, hard to track.</div>
          <div class="gotcha-detail"><strong>Cause:</strong> Worker prompt didn't prohibit Task tool usage, or task was too large for single worker.</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Add to every worker preamble: "Do NOT spawn sub-agents. Do NOT call Task or TaskCreate." If task genuinely needs splitting, do it at orchestrator level, not worker level.</div>
        </div>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Worker Reports Complete But Verification Fails
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Worker says "Done!" but tests fail when orchestrator checks.</div>
          <div class="gotcha-detail"><strong>Cause:</strong> Worker prompt didn't require verification before reporting, or verification command is wrong.</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Add verification requirements to worker preamble: "Before reporting complete, you MUST: 1) Run npm run typecheck, 2) Run npm run test:[domain], 3) Include test results in your report. If any verification fails, fix the issue and re-verify."</div>
        </div>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Swarm Cost Is Too High
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Multiple workers + orchestrator = 3-5x the token cost of a generalist approach.</div>
          <div class="gotcha-detail"><strong>Cause:</strong> Swarm pattern has overhead. Not all tasks benefit from it.</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Do cost-benefit analysis. Generalist: ~50K tokens x 1 agent = 50K. Swarm: ~30K x 4 agents = 120K. But swarm time is 90 min vs 4 hours. When time savings justify cost (billing rate &gt; token cost), use swarm. When budget constrained or task is small, use generalist.</div>
        </div>

        <h3 class="font-semibold text-lg mb-4 mt-8" id="antipatterns">Anti-Patterns to Avoid</h3>

        <div class="antipattern-box">
          <div class="antipattern-header">
            <i data-lucide="x-circle" class="w-4 h-4"></i>
            Spawning Workers for Simple Tasks
          </div>
          <div class="antipattern-bad">BAD: Orchestrator spawns worker to add a comment</div>
          <div class="antipattern-good">GOOD: Just do it directly (if generalist) or batch with other work</div>
        </div>

        <div class="antipattern-box">
          <div class="antipattern-header">
            <i data-lucide="x-circle" class="w-4 h-4"></i>
            Deep Worker Nesting
          </div>
          <div class="antipattern-bad">BAD: Orchestrator -&gt; Worker -&gt; SubWorker -&gt; SubSubWorker</div>
          <div class="antipattern-good">GOOD: Orchestrator -&gt; Worker (flat structure, max 2 levels)</div>
        </div>

        <div class="antipattern-box">
          <div class="antipattern-header">
            <i data-lucide="x-circle" class="w-4 h-4"></i>
            Orchestrator Doing Code
          </div>
          <div class="antipattern-bad">BAD: Orchestrator: "Let me just quickly fix this bug..."</div>
          <div class="antipattern-good">GOOD: Orchestrator: "Spawning bugfix worker for issue #123..."</div>
        </div>

        <div class="antipattern-box">
          <div class="antipattern-header">
            <i data-lucide="x-circle" class="w-4 h-4"></i>
            Workers Spawning Workers
          </div>
          <div class="antipattern-bad">BAD: Backend Worker spawns "DB Worker" and "API Worker"</div>
          <div class="antipattern-good">GOOD: Backend Worker does all backend work, reports to orchestrator</div>
        </div>

        <div class="antipattern-box">
          <div class="antipattern-header">
            <i data-lucide="x-circle" class="w-4 h-4"></i>
            No Verification Before Complete
          </div>
          <div class="antipattern-bad">BAD: Worker: "I wrote the code, marking complete"</div>
          <div class="antipattern-good">GOOD: Worker: "Tests pass: 12/12. Files: [...]. Marking complete."</div>
        </div>
      </section>

      <!-- Section 7: WHAT'S HARD -->
      <section id="hard" data-activity="hard">
        <h2 class="section-title">
          <span class="section-number">7</span>
          What's Hard
        </h2>

        <p class="text-text-secondary mb-6">
          These are fundamental tensions in swarm architectures, not bugs to fix:
        </p>

        <div class="hard-box">
          <div class="hard-title">
            <i data-lucide="flame" class="w-4 h-4"></i>
            Coordination Overhead vs. Parallelism Gains
          </div>
          <div class="hard-detail"><strong>The tension:</strong> Adding an orchestrator and worker spawning has cost. For small tasks, the coordination overhead exceeds the parallelism gains. You have to calibrate when swarm is worth it.</div>
          <div class="hard-detail"><strong>Symptoms:</strong> Swarm takes longer than generalist for simple features. You're spending more on orchestration than execution.</div>
          <div class="hard-detail"><strong>Mitigation:</strong> Use the 30-minute rule: if a generalist could do the whole feature in under 30 minutes, don't use a swarm. Swarm shines at 2+ hour equivalent tasks with parallelizable components.</div>
        </div>

        <div class="hard-box">
          <div class="hard-title">
            <i data-lucide="flame" class="w-4 h-4"></i>
            Worker Scope Definition
          </div>
          <div class="hard-detail"><strong>The tension:</strong> Too narrow scope = spawn overhead dominates. Too broad scope = you're back to generalist problems. Finding the right granularity requires judgment.</div>
          <div class="hard-detail"><strong>Symptoms:</strong> Workers finish in seconds (too narrow) or hit context limits (too broad). Frequent merge conflicts (overlapping scope).</div>
          <div class="hard-detail"><strong>Mitigation:</strong> Start with domain boundaries: backend, frontend, tests. Split further only when a single domain exceeds context limits. Review first few runs and adjust based on actual worker performance.</div>
        </div>

        <div class="hard-box">
          <div class="hard-title">
            <i data-lucide="flame" class="w-4 h-4"></i>
            Debugging Distributed Failures
          </div>
          <div class="hard-detail"><strong>The tension:</strong> When swarm output is broken, which worker caused it? Multiple contexts to examine. The bug might be in worker prompts, orchestrator logic, or genuine code issues.</div>
          <div class="hard-detail"><strong>Symptoms:</strong> Broken output with no clear cause. "It worked for backend worker but frontend worker broke it." Blame ambiguity.</div>
          <div class="hard-detail"><strong>Mitigation:</strong> Require workers to report file paths modified. Log orchestrator decisions. When debugging, start with worker outputs before examining code. Consider running suspect workers in isolation to reproduce.</div>
        </div>

        <div class="hard-box">
          <div class="hard-title">
            <i data-lucide="flame" class="w-4 h-4"></i>
            Model Selection for Workers
          </div>
          <div class="hard-detail"><strong>The tension:</strong> Using Opus for everything maximizes quality but cost scales with worker count. Using Haiku for everything cuts cost but may sacrifice quality on complex tasks.</div>
          <div class="hard-detail"><strong>Symptoms:</strong> Budget overruns. Or: simple test-writing takes forever because you used Opus. Or: complex API design is buggy because you used Haiku.</div>
          <div class="hard-detail"><strong>Mitigation:</strong> Match model to task complexity. Opus for orchestration (reasoning about dependencies). Sonnet for implementation (code generation). Haiku for mechanical tasks (writing boilerplate tests, formatting). Adjust based on actual worker output quality.</div>
        </div>
      </section>

      <!-- Section 8: WHEN TO USE -->
      <section id="when" data-activity="when">
        <h2 class="section-title">
          <span class="section-number">8</span>
          When to Use / When Not
        </h2>

        <div class="when-grid">
          <div class="when-use">
            <div class="when-title">
              <i data-lucide="check" class="w-5 h-5"></i>
              USE SWARM WHEN
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>Multi-domain work (full-stack features spanning DB, API, UI, tests)</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>Task size would exhaust single context window</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>Parallelism provides significant time savings (2+ hour equivalent)</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>Quality requirements are high per domain</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>Team is comfortable with orchestration overhead</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>Overnight/AFK execution desired</span>
            </div>
          </div>

          <div class="when-not">
            <div class="when-title">
              <i data-lucide="x" class="w-5 h-5"></i>
              USE GENERALIST WHEN
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>Task is simple (&lt;30 min equivalent human time)</span>
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>Single domain (backend only, frontend only)</span>
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>Exploratory/research work with unclear scope</span>
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>Quick iterations with human feedback</span>
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>Budget constraints (swarm costs 2-4x more)</span>
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>Learning the codebase (context sharing is valuable)</span>
            </div>
          </div>
        </div>

        <h3 class="font-semibold text-lg mb-4">Comparison Matrix</h3>

        <table class="comparison-table">
          <thead>
            <tr>
              <th>Aspect</th>
              <th>Generalist</th>
              <th>Specialized Swarm</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>Parallelism</strong></td>
              <td>None (sequential)</td>
              <td>Full (with dependency awareness)</td>
            </tr>
            <tr>
              <td><strong>Specialization</strong></td>
              <td>None (one agent does all)</td>
              <td>Per-worker domain focus</td>
            </tr>
            <tr>
              <td><strong>Context</strong></td>
              <td>Shared/diluted across domains</td>
              <td>Focused per domain</td>
            </tr>
            <tr>
              <td><strong>Speed</strong></td>
              <td>Linear (4 hours)</td>
              <td>Parallel (~90 min with deps)</td>
            </tr>
            <tr>
              <td><strong>Quality</strong></td>
              <td>Averages down (35%)</td>
              <td>High per domain (80%)</td>
            </tr>
            <tr>
              <td><strong>Fault Tolerance</strong></td>
              <td>Single point of failure</td>
              <td>Isolated failures, retry individual</td>
            </tr>
            <tr>
              <td><strong>Cost</strong></td>
              <td>Lower (one agent)</td>
              <td>Higher (multiple agents)</td>
            </tr>
            <tr>
              <td><strong>Complexity</strong></td>
              <td>Simple to run</td>
              <td>Requires orchestration setup</td>
            </tr>
            <tr>
              <td><strong>Debugging</strong></td>
              <td>Single context to examine</td>
              <td>Multiple contexts, need monitoring</td>
            </tr>
            <tr>
              <td><strong>Scaling</strong></td>
              <td>Add more time</td>
              <td>Add more workers</td>
            </tr>
          </tbody>
        </table>

        <h3 class="font-semibold text-lg mb-4">The Hybrid Approach</h3>

        <p class="text-text-secondary mb-4">You don't have to choose one or the other:</p>

        <ul class="list-disc list-inside text-text-secondary mb-6 space-y-2">
          <li>Use generalist for <strong>planning and exploration</strong></li>
          <li>Spawn swarm for <strong>execution</strong> once plan is clear</li>
          <li>Generalist <strong>synthesizes and reviews</strong> swarm output</li>
        </ul>

        <p class="text-text-secondary">
          This gives you the benefits of both: generalist flexibility for understanding the problem, swarm parallelism and specialization for solving it.
        </p>
      </section>

    