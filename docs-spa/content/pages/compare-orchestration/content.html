

      <!-- Section 1: ESSENCE -->
      <section id="essence" data-activity="essence">
        <div class="essence-box">
          <div class="essence-label">Essence (15 words)</div>
          <div class="essence-text">Four orchestration strategies exist: choose based on parallelism needs, budget, and your complexity tolerance.</div>
        </div>
      </section>

      <!-- Section 2: CORE ABSTRACTION -->
      <section id="core-abstraction" data-activity="core">
        <h2 class="section-title">
          <span class="section-number">2</span>
          The Decision Framework
        </h2>

        <div class="core-abstraction">
          <div class="core-philosophy">"The best orchestration approach is the simplest one that meets your needs. Complexity has costs."</div>

          <div class="core-code">
            <button class="copy-btn" onclick="copyCode(this, 'Parallelism? No -> Ralph. Yes -> Agents > 5? No -> CC Mirror. Yes -> Gas Town')">
              <i data-lucide="copy" class="w-3 h-3"></i>
              Copy
            </button>
            <code>Parallelism? No -&gt; Ralph. Yes -&gt; Agents &gt; 5? No -&gt; CC Mirror. Yes -&gt; Gas Town</code>
          </div>

          <div class="core-anchor">That's the core decision. Everything else is refinement.</div>
        </div>

        <p class="text-text-secondary mb-6">
          All four approaches share the SAME goal: <strong>ship a complete feature autonomously</strong> from specification to working, tested code with minimal human intervention. They differ in HOW they achieve this goal, with distinct tradeoffs in setup complexity, parallelism capability, and operational overhead.
        </p>

        <table class="comparison-table">
          <thead>
            <tr>
              <th>Factor</th>
              <th>Basic Ralph</th>
              <th>PRD-Ralph</th>
              <th>CC Mirror</th>
              <th>Gas Town</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>Parallelism</strong></td>
              <td>None</td>
              <td>None</td>
              <td>High (3-8)</td>
              <td>Maximum (10-50+)</td>
            </tr>
            <tr>
              <td><strong>Setup Time</strong></td>
              <td>30 min</td>
              <td>2 hrs</td>
              <td>2 hrs</td>
              <td>8 hrs</td>
            </tr>
            <tr>
              <td><strong>Daily Cost</strong></td>
              <td>$5-20</td>
              <td>$10-30</td>
              <td>$30-80</td>
              <td>$50-200</td>
            </tr>
            <tr>
              <td><strong>Learning Curve</strong></td>
              <td>Low</td>
              <td>Low</td>
              <td>Medium</td>
              <td>High</td>
            </tr>
            <tr>
              <td><strong>Best For</strong></td>
              <td>Solo dev, overnight</td>
              <td>Structured specs</td>
              <td>Multi-domain</td>
              <td>Factory scale</td>
            </tr>
          </tbody>
        </table>
      </section>

      <!-- Section 3: DESIGN DECISIONS -->
      <section id="why-four-approaches" data-activity="decisions">
        <h2 class="section-title">
          <span class="section-number">3</span>
          Design Decisions
        </h2>

        <div class="decision-box">
          <div class="decision-why">WHY FOUR APPROACHES?</div>
          <div class="decision-reasoning">
            Different projects have different constraints. A solo developer shipping overnight has different needs than a team running 10 parallel feature streams. One-size-fits-all orchestration doesn't exist because the tradeoffs are real: simplicity vs. parallelism, cost vs. speed, control vs. automation.
          </div>
          <div class="decision-implication">
            <div class="decision-implication-label">What this means for you</div>
            <div class="text-text-secondary text-sm">
              Don't start with Gas Town because it's "most powerful." Start with Basic Ralph, then upgrade only when you hit a specific limitation. Each upgrade brings complexity costs that only pay off at scale.
            </div>
          </div>
        </div>

        <div class="decision-box" id="why-parallelism-matters">
          <div class="decision-why">WHY PARALLELISM MATTERS</div>
          <div class="decision-reasoning">
            A single Claude instance can only work on one task at a time. If your feature requires frontend + backend + tests + docs, sequential execution means 4x the calendar time. Parallelism lets multiple agents work different domains simultaneously, but adds coordination overhead.
          </div>
          <div class="decision-implication">
            <div class="decision-implication-label">What this means for you</div>
            <div class="text-text-secondary text-sm">
              Measure your bottleneck. If tasks complete faster than you can review, you don't need parallelism. If you're waiting on Claude, consider CC Mirror. If you're shipping multiple features simultaneously, consider Gas Town.
            </div>
          </div>
        </div>

        <div class="decision-box" id="why-cost-varies">
          <div class="decision-why">WHY COST VARIES SO MUCH</div>
          <div class="decision-reasoning">
            More agents = more tokens = more cost. Gas Town running 10 agents simultaneously burns through API credits 10x faster than single-agent Ralph. But if Gas Town ships a feature in 1 day that would take Ralph 5 days, the total cost might be similar while calendar time is dramatically different.
          </div>
          <div class="decision-implication">
            <div class="decision-implication-label">What this means for you</div>
            <div class="text-text-secondary text-sm">
              Measure cost-per-feature, not cost-per-day. A $200/day Gas Town that ships 5 features beats a $20/day Ralph that ships 1, if you need the throughput. But if you're shipping 1 feature/week, Ralph is 10x more economical.
            </div>
          </div>
        </div>
      </section>

      <!-- Section 4: THE FOUR APPROACHES -->
      <section id="basic-ralph" data-activity="approaches">
        <h2 class="section-title">
          <span class="section-number">4</span>
          The Four Approaches
        </h2>

        <!-- Basic Ralph -->
        <div class="approach-card">
          <div class="approach-header">
            <span class="approach-badge">Level 1</span>
            <span class="approach-title">Basic Ralph</span>
          </div>
          <div class="approach-subtitle">Simple bash loop with fresh context per iteration</div>

          <div class="code-block">
            <button class="copy-btn" onclick="copyCodeBlock(this)">
              <i data-lucide="copy" class="w-3 h-3"></i>
              Copy
            </button>
            <pre><span class="keyword">for</span> (( i=1; i&lt;=$MAX_ITERATIONS; i++ )); <span class="keyword">do</span>
  claude <span class="string">"Review prd.json... If complete, output PROMISE COMPLETE HERE"</span>
  <span class="keyword">if</span> grep -q <span class="string">"PROMISE COMPLETE HERE"</span> output.txt; <span class="keyword">then</span> <span class="keyword">break</span>; <span class="keyword">fi</span>
<span class="keyword">done</span></pre>
          </div>

          <div class="pros-cons">
            <div class="pros-list">
              <h4>Pros</h4>
              <ul>
                <li>Simple to set up (30 min)</li>
                <li>Low overhead, no infrastructure</li>
                <li>Easy to understand and debug</li>
                <li>Fresh context avoids rot</li>
                <li>Git history as implicit memory</li>
              </ul>
            </div>
            <div class="cons-list">
              <h4>Cons</h4>
              <ul>
                <li>Sequential only, no parallelism</li>
                <li>Single agent, no specialization</li>
                <li>Context amnesia between iterations</li>
                <li>Human must decompose tasks</li>
              </ul>
            </div>
          </div>

          <p class="text-sm text-text-muted mt-4">
            <strong>Best for:</strong> Solo developers, overnight "ship it while I sleep" workflows, well-scoped features (Stage 1-3)
          </p>
        </div>

        <!-- PRD-Ralph -->
        <div class="approach-card" id="prd-ralph">
          <div class="approach-header">
            <span class="approach-badge">Level 2</span>
            <span class="approach-title">PRD-Driven Ralph</span>
          </div>
          <div class="approach-subtitle">Structured task management via JSON-based Product Requirements Document</div>

          <div class="code-block">
            <button class="copy-btn" onclick="copyCodeBlock(this)">
              <i data-lucide="copy" class="w-3 h-3"></i>
              Copy
            </button>
            <pre>{
  <span class="string">"name"</span>: <span class="string">"Authentication System"</span>,
  <span class="string">"stories"</span>: [
    {
      <span class="string">"id"</span>: <span class="string">"story-1"</span>,
      <span class="string">"title"</span>: <span class="string">"User can register"</span>,
      <span class="string">"acceptanceCriteria"</span>: [<span class="string">"Email validation"</span>, <span class="string">"Password hashed"</span>],
      <span class="string">"passes"</span>: <span class="keyword">false</span>,
      <span class="string">"priority"</span>: 1
    }
  ]
}</pre>
          </div>

          <div class="pros-cons">
            <div class="pros-list">
              <h4>Pros</h4>
              <ul>
                <li>Structured tasks with boundaries</li>
                <li>Acceptance criteria as gates</li>
                <li>Priority ordering</li>
                <li>Measurable progress tracking</li>
                <li>Self-documenting PRD</li>
              </ul>
            </div>
            <div class="cons-list">
              <h4>Cons</h4>
              <ul>
                <li>Upfront PRD writing required</li>
                <li>PRD quality determines output</li>
                <li>Still sequential, no parallelism</li>
                <li>Rigid to emergent requirements</li>
              </ul>
            </div>
          </div>

          <p class="text-sm text-text-muted mt-4">
            <strong>Best for:</strong> Well-defined features, teams that already write good specs, regulated environments (Stage 3-5)
          </p>
        </div>

        <!-- CC Mirror -->
        <div class="approach-card" id="cc-mirror">
          <div class="approach-header">
            <span class="approach-badge">Level 3</span>
            <span class="approach-title">CC Mirror Hub-and-Spoke</span>
          </div>
          <div class="approach-subtitle">Central orchestrator delegates to specialized worker agents via Task API</div>

          <div class="scaling-diagram">
            <pre>                +-----------------+
                |  Orchestrator   |
                |  (Conductor)    |
                +--------+--------+
                         |
         +---------------+---------------+
         |               |               |
         v               v               v
   +-----------+   +-----------+   +-----------+
   |  Coder    |   |  Tester   |   |  Reviewer |
   |  (Opus)   |   |  (Sonnet) |   |  (Haiku)  |
   +-----------+   +-----------+   +-----------+</pre>
          </div>

          <p class="text-text-secondary mb-4">
            <strong>Key principle:</strong> The orchestrator NEVER writes code. It only coordinates.
          </p>

          <div class="pros-cons">
            <div class="pros-list">
              <h4>Pros</h4>
              <ul>
                <li>True parallelism (3-8 workers)</li>
                <li>Right model for each task type</li>
                <li>Cost optimization via model routing</li>
                <li>Built-in dependency tracking</li>
                <li>Native Claude Code integration</li>
              </ul>
            </div>
            <div class="cons-list">
              <h4>Cons</h4>
              <ul>
                <li>More complex setup</li>
                <li>Coordination overhead</li>
                <li>Needs good task decomposition</li>
                <li>Workers isolated from each other</li>
                <li>Merge conflicts possible</li>
              </ul>
            </div>
          </div>

          <p class="text-sm text-text-muted mt-4">
            <strong>Best for:</strong> Multi-domain features (frontend + backend + tests), cost-optimized model usage, interactive development (Stage 4-6)
          </p>
        </div>

        <!-- Gas Town -->
        <div class="approach-card" id="gas-town">
          <div class="approach-header">
            <span class="approach-badge">Level 4</span>
            <span class="approach-title">Gas Town Factory</span>
          </div>
          <div class="approach-subtitle">Self-managing agent factory with specialized workers and inbox coordination</div>

          <div class="scaling-diagram">
            <pre>Gas Town (~/.gt)
+-- HQ (town-level management)
+-- Rigs (project repos)
|   +-- Witness (per-rig observer)
+-- Workers
|   +-- Mayor (town coordination)
|   +-- Deacon (monitoring/handshakes)
|   +-- Dogs (quality gates)
|   +-- Refinery (task decomposition)
|   +-- Polecat (named persistent workers)
|   +-- Crew (ephemeral workers)
+-- Overseer (YOU - human with inbox)</pre>
          </div>

          <p class="text-text-secondary mb-4">
            <strong>Philosophy:</strong> "You just make up features, design them, file the implementation plans, and sling work around to your polecats and crew."
          </p>

          <div class="pros-cons">
            <div class="pros-list">
              <h4>Pros</h4>
              <ul>
                <li>Maximum parallelism (10-50+ agents)</li>
                <li>Deep specialization per role</li>
                <li>Self-improving factory</li>
                <li>Automatic task decomposition</li>
                <li>Built-in quality gates (Dogs)</li>
                <li>Persistent workers (Polecats)</li>
              </ul>
            </div>
            <div class="cons-list">
              <h4>Cons</h4>
              <ul>
                <li>Complex setup (8+ hours)</li>
                <li>High cost ($50-200/day)</li>
                <li>Overkill for small features</li>
                <li>Requires extensive experience</li>
                <li>Hard to debug across agents</li>
                <li>Tmux proficiency required</li>
              </ul>
            </div>
          </div>

          <p class="text-sm text-text-muted mt-4">
            <strong>Best for:</strong> Large projects with parallel workstreams, Stage 7+ developers, organizations with significant AI budget
          </p>
        </div>
      </section>

      <!-- Section 5: PATH OF SELECTION -->
      <section id="path" data-activity="path">
        <h2 class="section-title">
          <span class="section-number">5</span>
          The Path of Selection
        </h2>

        <p class="text-text-secondary mb-6">
          Follow this decision tree to select the right orchestration approach:
        </p>

        <div class="path-container">
          <div class="path-step">
            <div class="path-number">1</div>
            <div class="path-content"><strong>Do you need parallelism?</strong> (Multiple tasks working simultaneously)</div>
          </div>
          <div class="path-step">
            <div class="path-number">2</div>
            <div class="path-content">If NO: Do you have detailed specs? <code>Yes -&gt; PRD-Ralph</code>, <code>No -&gt; Basic Ralph</code></div>
          </div>
          <div class="path-step">
            <div class="path-number">3</div>
            <div class="path-content">If YES: How many parallel agents do you need?</div>
          </div>
          <div class="path-step">
            <div class="path-number">4</div>
            <div class="path-content"><code>3-8 agents</code> -&gt; CC Mirror Hub-and-Spoke</div>
          </div>
          <div class="path-step">
            <div class="path-number">5</div>
            <div class="path-content"><code>10+ agents</code> -&gt; Are you Stage 7+ with $50+/day budget?</div>
          </div>
          <div class="path-step">
            <div class="path-number">6</div>
            <div class="path-content">If YES: Gas Town Factory</div>
          </div>
          <div class="path-step">
            <div class="path-number">7</div>
            <div class="path-content">If NO: Stay with CC Mirror, add worktrees for more parallelism</div>
          </div>
        </div>

        <div class="scaling-diagram">
          <pre>   SCALING PROGRESSION

   SIMPLE -----------------------------------------&gt; COMPLEX

   Stage 1-3        Stage 4-5        Stage 6        Stage 7+
   +---------+     +---------+     +---------+     +-------+
   | Ralph   |----&gt;|  PRD    |----&gt;|CC Mirror|----&gt;|  Gas  |
   | (Basic) |     | Ralph   |     |Hub-Spoke|     | Town  |
   +---------+     +---------+     +---------+     +-------+

   1 agent         1 agent         3-8 agents      10+ agents
   $5/day          $10/day         $50/day         $150/day</pre>
        </div>
      </section>

      <!-- Section 6: GOTCHAS -->
      <section id="gotchas" data-activity="gotchas">
        <h2 class="section-title">
          <span class="section-number">6</span>
          Gotchas
        </h2>

        <p class="text-text-secondary mb-6">
          Common mistakes when selecting and operating orchestration approaches:
        </p>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Starting with Gas Town
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Spending 2 weeks setting up Gas Town for a 2-day feature</div>
          <div class="gotcha-detail"><strong>Cause:</strong> Assuming "most powerful" = "best choice"</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Start with Basic Ralph. Upgrade only when you hit specific limitations (need parallelism, need cost optimization). Gas Town's setup cost only pays off at factory scale.</div>
        </div>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Underestimating CC Mirror coordination
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Orchestrator context explodes, workers produce conflicting changes</div>
          <div class="gotcha-detail"><strong>Threshold:</strong> &gt;8 simultaneous workers typically causes coordination breakdown</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Keep CC Mirror to 3-5 workers per feature. Use dependency blocking. If you need more, consider multiple CC Mirror instances on separate worktrees.</div>
        </div>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            PRD-Ralph with vague acceptance criteria
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Tasks marked "complete" that aren't actually working</div>
          <div class="gotcha-detail"><strong>Cause:</strong> Acceptance criteria like "authentication works" instead of "POST /login returns JWT"</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Make every acceptance criterion verifiable by automation. If you can't write a test for it, it's not specific enough.</div>
        </div>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Overnight Ralph with no stuck detection
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Wake up to find Ralph ran 50 iterations on the same failing task</div>
          <div class="gotcha-detail"><strong>Cause:</strong> No detection for "same task attempted 3+ times with no progress"</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Add stuck detection: if git HEAD unchanged for 3 iterations, exit loop and alert. Check for infinite retry loops.</div>
        </div>
      </section>

      <!-- Section 7: WHAT'S HARD -->
      <section id="hard" data-activity="hard">
        <h2 class="section-title">
          <span class="section-number">7</span>
          What's Hard
        </h2>

        <p class="text-text-secondary mb-6">
          Fundamental tensions in orchestration that have no perfect solution:
        </p>

        <div class="hard-box">
          <div class="hard-title">
            <i data-lucide="flame" class="w-4 h-4"></i>
            Simplicity vs. Parallelism
          </div>
          <div class="hard-detail"><strong>The tension:</strong> Simpler approaches (Ralph) are easier to debug but slower. Parallel approaches (Gas Town) are faster but much harder to reason about when things go wrong.</div>
          <div class="hard-detail"><strong>Symptoms:</strong> Ralph runs take 5 hours when you need results in 1. Gas Town agents produce conflicts that take 3 hours to untangle.</div>
          <div class="hard-detail"><strong>Mitigation:</strong> Accept that parallelism complexity is a one-way door. Only open it when sequential is demonstrably too slow. Build debugging skills at each level before advancing.</div>
        </div>

        <div class="hard-box">
          <div class="hard-title">
            <i data-lucide="flame" class="w-4 h-4"></i>
            Cost vs. Speed
          </div>
          <div class="hard-detail"><strong>The tension:</strong> More agents = faster results = higher cost. At some point, diminishing returns: 10 agents aren't 10x faster than 5 because coordination overhead dominates.</div>
          <div class="hard-detail"><strong>Symptoms:</strong> Gas Town burns $200/day but only ships 2x what CC Mirror would for $50/day.</div>
          <div class="hard-detail"><strong>Mitigation:</strong> Measure cost-per-feature, not cost-per-day. Find your saturation point where adding agents no longer improves throughput proportionally.</div>
        </div>

        <div class="hard-box">
          <div class="hard-title">
            <i data-lucide="flame" class="w-4 h-4"></i>
            Upfront Planning vs. Emergent Work
          </div>
          <div class="hard-detail"><strong>The tension:</strong> PRD-Ralph needs detailed specs upfront. But many features evolve as you build them. Gas Town can adapt, but requires experienced operators.</div>
          <div class="hard-detail"><strong>Symptoms:</strong> PRD written at day 1 is 40% wrong by day 3. Basic Ralph handles pivots but loses velocity gains from structure.</div>
          <div class="hard-detail"><strong>Mitigation:</strong> Use HOTL (Human On The Loop) variants for exploratory work. Reserve autonomous approaches for features with stable requirements.</div>
        </div>
      </section>

      <!-- Section 8: WHEN TO USE -->
      <section id="when" data-activity="when">
        <h2 class="section-title">
          <span class="section-number">8</span>
          Selection Guide
        </h2>

        <div class="when-grid">
          <div class="when-use">
            <div class="when-title">
              <i data-lucide="check" class="w-5 h-5"></i>
              START WITH RALPH WHEN
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>You're new to autonomous development</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>Feature is well-scoped and fits in a day</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>You want "set it and forget it" overnight</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>Budget is constrained ($5-20/day)</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>Simplicity &gt; parallelism for your use case</span>
            </div>
          </div>

          <div class="when-not">
            <div class="when-title">
              <i data-lucide="x" class="w-5 h-5"></i>
              UPGRADE TO CC MIRROR WHEN
            </div>
            <div class="when-item">
              <i data-lucide="arrow-right" class="w-4 h-4 flex-shrink-0"></i>
              <span>You need parallelism across domains</span>
            </div>
            <div class="when-item">
              <i data-lucide="arrow-right" class="w-4 h-4 flex-shrink-0"></i>
              <span>Cost optimization matters (right model/task)</span>
            </div>
            <div class="when-item">
              <i data-lucide="arrow-right" class="w-4 h-4 flex-shrink-0"></i>
              <span>Features span frontend + backend + tests</span>
            </div>
            <div class="when-item">
              <i data-lucide="arrow-right" class="w-4 h-4 flex-shrink-0"></i>
              <span>You want interactive development with oversight</span>
            </div>
          </div>
        </div>

        <div class="when-grid">
          <div class="when-use">
            <div class="when-title">
              <i data-lucide="check" class="w-5 h-5"></i>
              UPGRADE TO GAS TOWN WHEN
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>You're Stage 7+ (10+ agent experience)</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>Project scale justifies the overhead</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>Speed-to-market is critical</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>Budget is $50-200/day</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>You're comfortable with emergence and chaos</span>
            </div>
          </div>

          <div class="when-not">
            <div class="when-title">
              <i data-lucide="x" class="w-5 h-5"></i>
              USE HYBRID STRATEGIES WHEN
            </div>
            <div class="when-item">
              <i data-lucide="arrow-right" class="w-4 h-4 flex-shrink-0"></i>
              <span><strong>Ralph + Worktrees:</strong> Parallel features without CC Mirror</span>
            </div>
            <div class="when-item">
              <i data-lucide="arrow-right" class="w-4 h-4 flex-shrink-0"></i>
              <span><strong>CC Mirror by day, Ralph by night:</strong> Interactive + autonomous</span>
            </div>
            <div class="when-item">
              <i data-lucide="arrow-right" class="w-4 h-4 flex-shrink-0"></i>
              <span><strong>Gas Town + PRD:</strong> Factory scale with structured specs</span>
            </div>
          </div>
        </div>

        <h3 class="font-semibold text-lg mt-8 mb-4">Quick Reference Commands</h3>

        <div class="code-block">
          <button class="copy-btn" onclick="copyCodeBlock(this)">
            <i data-lucide="copy" class="w-3 h-3"></i>
            Copy
          </button>
          <pre><span class="comment"># Basic Ralph</span>
./ralph.sh 25

<span class="comment"># PRD-Ralph (same command, different prd.json structure)</span>
./ralph.sh 25  <span class="comment"># With structured prd.json</span>

<span class="comment"># CC Mirror</span>
npx cc-mirror quick --provider mirror --name mclaude

<span class="comment"># Gas Town</span>
go install github.com/steveyegge/gastown/cmd/gt@latest
gt init  <span class="comment"># Initialize town</span></pre>
        </div>
      </section>

    