{
  "items": [
    {
      "id": "inv-1",
      "type": "inversion",
      "linkedSection": "essence",
      "title": "What if patterns DIDN'T connect?",
      "content": "<strong>You'd design:</strong> 55 isolated documents, no cross-references, no shared principles.<br>\n          <strong>Why this fails:</strong> You'd rediscover the same insight 10 times across different patterns.<br>\n          <strong>Hidden constraint revealed:</strong> The themes ARE the architecture. Patterns are implementations."
    },
    {
      "id": "min-2",
      "type": "minimal",
      "linkedSection": "essence",
      "title": "The irreducible cross-reference",
      "content": "<strong>Essential:</strong> 10 themes + terminology mapping.<br>\n          <strong>Everything else:</strong> Convenience for faster navigation.<br>\n          <em>If you understand the themes, you can derive the dependencies.</em>"
    },
    {
      "id": "ana-3",
      "type": "analogy",
      "linkedSection": "essence",
      "title": "Cross-Reference = Software Architecture Docs",
      "content": "Themes → Design principles<br>\n          Dependencies → Module relationships<br>\n          Terminology → Ubiquitous language (DDD)<br>\n          Authors → Original designers<br><br>\n          <em>If you've read architecture docs, you already understand this document.</em>"
    },
    {
      "id": "inv-4",
      "type": "invariant",
      "linkedSection": "core",
      "title": "INV-001: Context as Primary Constraint",
      "content": "Ralph, Gas Town, CC Mirror, Panopticon, Claude-Mem ALL address context management.<br><br>\n          <em>This is the deepest invariant. Every pattern is a context management strategy.</em>"
    },
    {
      "id": "con-5",
      "type": "constraint",
      "linkedSection": "core",
      "title": "One constraint generates 10 themes",
      "content": "<strong>ROOT:</strong> Context finite (200K tokens)<br>\n          → Theme 1: Context as constraint<br>\n          → Theme 2: Fresh context (Ralph)<br>\n          → Theme 3: File-based state<br>\n          → Theme 4: Verification loops<br>\n          → Theme 5: Orchestrator/worker<br>\n          → Theme 6-10: All derivatives"
    },
    {
      "id": "war-6",
      "type": "warstory",
      "linkedSection": "core",
      "title": "55 files → 10 themes discovery",
      "content": "During synthesis, 55 extraction files were analyzed. The 10 themes emerged organically - they weren't predefined. Same concepts kept appearing in different vocabularies."
    },
    {
      "id": "exp-7",
      "type": "expertise",
      "linkedSection": "core",
      "title": "How deeply do you understand patterns?",
      "content": "<strong>Beginner:</strong> \"What's Ralph?\" → A loop pattern<br>\n          <strong>Intermediate:</strong> \"Why Ralph?\" → Context rot avoidance<br>\n          <strong>Advanced:</strong> \"Ralph vs CC Mirror?\" → Serial vs parallel<br>\n          <strong>Staff:</strong> \"How do they compose?\" → Dependencies graph<br>\n          <strong>Expert:</strong> \"What's the invariant?\" → All are context strategies"
    },
    {
      "id": "inv-8",
      "type": "invariant",
      "linkedSection": "themes",
      "title": "INV-003: External state > internal memory",
      "content": "Ralph (prd.json), Gas Town (Beads), CC Mirror (task API), Planning-Execution (filesystem queue) ALL externalize state.<br><br>\n          <em>This is the same principle forcing the same architectural choice.</em>"
    },
    {
      "id": "eff-9",
      "type": "effect",
      "linkedSection": "themes",
      "title": "At 100+ patterns, terminology diverges",
      "content": "<strong>Observation:</strong> Early patterns (Ralph, CC Mirror) share vocabulary. Later patterns (Gas Town) invented new terms.<br>\n          <strong>Implication:</strong> The community outgrew coordinated terminology.<br>\n          <strong>Threshold:</strong> ~50 patterns, ~30 active authors"
    },
    {
      "id": "grad-10",
      "type": "gradient",
      "linkedSection": "themes",
      "title": "How verification degrades",
      "content": "<strong>Full verification:</strong> Typecheck + unit + integration + E2E → High quality<br>\n          <strong>Partial:</strong> Typecheck + unit only → Good for logic, blind to UI<br>\n          <strong>Minimal:</strong> Typecheck only → Catches types, misses runtime<br>\n          <strong>None:</strong> \"YOLO\" → Errors compound exponentially<br><br>\n          <em>Each level you skip, failure modes multiply.</em>"
    },
    {
      "id": "vio-11",
      "type": "violation",
      "linkedSection": "themes",
      "title": "If workers spawn sub-agents",
      "content": "<strong>IF:</strong> CC Mirror workers spawn their own sub-agents<br>\n          <strong>THEN:</strong> Context budget explodes unpredictably<br>\n          <strong>THEN:</strong> Orchestrator loses track of actual work<br>\n          <strong>THEN:</strong> Costs spiral, tasks timeout<br>\n          <strong>FINALLY:</strong> \"Multi-agent doesn't work\" (incorrect conclusion)<br><br>\n          <em>Keep workers flat. Only orchestrators spawn.</em>"
    },
    {
      "id": "trade-12",
      "type": "tradeoff",
      "linkedSection": "themes",
      "title": "The Model Selection Dilemma",
      "content": "<strong>Haiku everywhere:</strong> Cheap, but low quality on complex tasks<br>\n          <strong>Opus everywhere:</strong> High quality, but 10x cost<br>\n          <strong>Mixed models:</strong> Optimal, but requires judgment<br><br>\n          <em>Heuristic: Haiku for fetching, Sonnet for implementing, Opus for architecting.</em>"
    },
    {
      "id": "comp-13",
      "type": "composition",
      "linkedSection": "dependencies",
      "title": "Ralph + CC Mirror",
      "content": "<strong>Works?</strong> Yes, with careful design<br>\n          <strong>How:</strong> Ralph for serial iteration, CC Mirror for parallel within iteration<br>\n          <strong>Danger:</strong> Complexity explosion. Only if you've mastered both separately.<br>\n          <strong>Recommendation:</strong> Start with one, graduate to composition."
    },
    {
      "id": "comp-14",
      "type": "composition",
      "linkedSection": "dependencies",
      "title": "Skills + Hooks",
      "content": "<strong>Works?</strong> Yes, this is the intended design<br>\n          <strong>How:</strong> Skills define behavior, hooks automate triggers<br>\n          <strong>Example:</strong> PostToolUse hook → format code → skill for linting<br>\n          <strong>Recommendation:</strong> Learn skills first, add hooks for automation."
    },
    {
      "id": "hor-15",
      "type": "horizon",
      "linkedSection": "dependencies",
      "title": "When dependencies become obvious",
      "content": "<strong>Day 1:</strong> \"I'll just use Claude CLI directly\"<br>\n          <strong>Week 1:</strong> \"CLAUDE.md helps a lot\"<br>\n          <strong>Month 1:</strong> \"I need hooks for automation\"<br>\n          <strong>Month 3:</strong> \"Ralph requires all of these as foundation\"<br><br>\n          <em>The dependency graph is obvious in hindsight.</em>"
    },
    {
      "id": "inv-16",
      "type": "inversion",
      "linkedSection": "dependencies",
      "title": "What if there were NO dependencies?",
      "content": "<strong>You'd design:</strong> Each pattern completely standalone.<br>\n          <strong>Why this fails:</strong> You'd reinvent CLAUDE.md for every pattern. Duplication everywhere.<br>\n          <strong>Hidden constraint:</strong> CLAUDE.md IS the shared foundation. Everything builds on it."
    },
    {
      "id": "fron-17",
      "type": "frontier",
      "linkedSection": "dependencies",
      "title": "UNSOLVED: Automatic dependency detection",
      "content": "<strong>The question:</strong> Can we automatically detect when a user needs pattern B before attempting pattern A?<br>\n          <strong>Why hard:</strong> Dependencies are conceptual, not syntactic.<br>\n          <strong>Current practice:</strong> Manual documentation like this cross-reference."
    },
    {
      "id": "war-18",
      "type": "warstory",
      "linkedSection": "authors",
      "title": "Steve Yegge: 225K lines of Go",
      "content": "Gas Town is the most ambitious documented system - 225K lines, multiple agent types, factory architecture. Yegge's 8-stage evolution doc shows the journey from simple to complex."
    },
    {
      "id": "war-19",
      "type": "warstory",
      "linkedSection": "authors",
      "title": "Boris Cherny: Creator's workflow",
      "content": "The Claude Code creator uses vanilla Claude Code with verification loops. His 13-point canonical setup is the baseline against which all patterns should be compared."
    },
    {
      "id": "exp-20",
      "type": "expertise",
      "linkedSection": "authors",
      "title": "Which author for which depth?",
      "content": "<strong>Getting started:</strong> @bcherny (vanilla workflow)<br>\n          <strong>Ralph basics:</strong> @mattpocockuk (tutorials)<br>\n          <strong>Ralph production:</strong> @ryancarson (PRD-driven)<br>\n          <strong>Multi-agent:</strong> @nummanali (CC Mirror)<br>\n          <strong>Factory scale:</strong> @steve_yegge (Gas Town)"
    },
    {
      "id": "eff-21",
      "type": "effect",
      "linkedSection": "authors",
      "title": "Engagement signals show community validation",
      "content": "<strong>Highest bookmark-to-like ratio:</strong> Ralph Text Thread (2.0x) - high implementation intent<br>\n          <strong>Highest views:</strong> .md Files Superpower (452K) - broad appeal<br>\n          <strong>Interpretation:</strong> Bookmark ratio predicts \"will actually build this\""
    },
    {
      "id": "inf-22",
      "type": "inflection",
      "linkedSection": "gotchas",
      "title": "When documentation gaps hurt",
      "content": "<strong>Beginner:</strong> Gaps don't matter, core patterns documented<br>\n          <strong>Intermediate:</strong> Start hitting edge cases<br>\n          <strong>Advanced:</strong> Enterprise needs (SSO, audit) become blockers<br>\n          <strong>Staff:</strong> Must go to primary sources for undocumented patterns<br><br>\n          <strong>THE INFLECTION:</strong> ~6 months of usage"
    },
    {
      "id": "vio-23",
      "type": "violation",
      "linkedSection": "gotchas",
      "title": "If you skip checking for documentation gaps",
      "content": "<strong>IF:</strong> You assume all patterns are fully documented<br>\n          <strong>THEN:</strong> You attempt implementation without checking sources<br>\n          <strong>THEN:</strong> Hit undocumented edge cases<br>\n          <strong>THEN:</strong> Spend hours debugging what was never specified<br>\n          <strong>FINALLY:</strong> Frustration, \"docs are useless\" (incorrect)<br><br>\n          <em>Check the gaps list first. Know what you don't know.</em>"
    },
    {
      "id": "fron-24",
      "type": "frontier",
      "linkedSection": "gotchas",
      "title": "UNSOLVED: Windows/WSL patterns",
      "content": "<strong>The gap:</strong> Large developer base on Windows, minimal Claude Code documentation.<br>\n          <strong>Why hard:</strong> Most power users on macOS, patterns developed there.<br>\n          <strong>Opportunity:</strong> First comprehensive Windows guide would fill major gap."
    },
    {
      "id": "alt-25",
      "type": "alternative",
      "linkedSection": "gotchas",
      "title": "When gaps block you",
      "content": "<strong>Cron specifics missing?</strong> → Check Unix cron documentation directly<br>\n          <strong>Enterprise SSO needed?</strong> → Contact Anthropic enterprise sales<br>\n          <strong>Windows patterns?</strong> → Experiment and document for community"
    },
    {
      "id": "trade-26",
      "type": "tradeoff",
      "linkedSection": "hard",
      "title": "Terminology standardization vs innovation",
      "content": "<strong>Standardize:</strong> Everyone uses same terms, easier learning<br>\n          <strong>Innovate:</strong> New terms for genuinely new concepts<br>\n          <strong>Current state:</strong> Organic evolution, multiple terms for same thing<br><br>\n          <em>No authority to standardize. Accept the mapping overhead.</em>"
    },
    {
      "id": "ana-27",
      "type": "analogy",
      "linkedSection": "hard",
      "title": "Terminology overlap = JavaScript ecosystem",
      "content": "\"Component\" means different things in React, Vue, Angular<br>\n          \"Worker\" means different things in CC Mirror vs Gas Town<br>\n          Same pattern: organic community evolution without central authority<br><br>\n          <em>If you've navigated JS ecosystem, you already know this pain.</em>"
    },
    {
      "id": "grad-28",
      "type": "gradient",
      "linkedSection": "hard",
      "title": "How terminology confusion degrades understanding",
      "content": "<strong>Clear:</strong> Same term used consistently<br>\n          <strong>Confusing:</strong> 2 terms for same thing<br>\n          <strong>Frustrating:</strong> 4+ terms for same thing<br>\n          <strong>Blocking:</strong> Can't find docs because using wrong term<br><br>\n          <em>This cross-reference exists to prevent the \"blocking\" state.</em>"
    },
    {
      "id": "hor-29",
      "type": "horizon",
      "linkedSection": "hard",
      "title": "How terminology perception changes",
      "content": "<strong>Week 1:</strong> \"Why do people use different words?\"<br>\n          <strong>Month 1:</strong> \"I can translate between vocabularies\"<br>\n          <strong>Month 3:</strong> \"Each vocabulary reveals different emphasis\"<br>\n          <strong>Month 6:</strong> \"The terminology differences ARE the insight\"<br><br>\n          <em>Gas Town's \"Polecat\" emphasizes persistence in ways \"Worker\" doesn't.</em>"
    },
    {
      "id": "inv-30",
      "type": "inversion",
      "linkedSection": "when",
      "title": "What if you chose patterns randomly?",
      "content": "<strong>You'd do:</strong> Gas Town as your first pattern (most complex)<br>\n          <strong>Why this fails:</strong> No CLAUDE.md foundation, no hooks, no understanding of why<br>\n          <strong>Hidden constraint:</strong> Complexity ladder exists. Start at Level 0, not Level 7."
    },
    {
      "id": "con-31",
      "type": "constraint",
      "linkedSection": "when",
      "title": "Need → Pattern selection cascade",
      "content": "<strong>ROOT:</strong> \"I want autonomous development\"<br>\n          → Do I need parallelism? (No → Ralph, Yes → CC Mirror)<br>\n          → Do I need overnight? (Yes → Ralph)<br>\n          → Do I have tests? (No → Add tests first)<br>\n          → Is task decomposition clear? (No → HOTL Ralph)"
    },
    {
      "id": "alt-32",
      "type": "alternative",
      "linkedSection": "when",
      "title": "If this cross-reference isn't what you need",
      "content": "<strong>Need implementation details?</strong> → Pattern-specific pages<br>\n          <strong>Need tutorials?</strong> → journeys/ folder<br>\n          <strong>Need progression path?</strong> → MASTER-PLAYBOOK.md<br>\n          <strong>Need architecture decisions?</strong> → JUDGMENT-GUIDE.md<br>\n          <strong>Just starting?</strong> → claude-code-mastery.md"
    },
    {
      "id": "war-33",
      "type": "warstory",
      "linkedSection": "when",
      "title": "Pattern selection saves hours",
      "content": "A developer tried Gas Town first (impressed by Yegge's post), failed after 2 weeks, started over with Ralph, succeeded in 3 days. The selection guide would have saved those 2 weeks."
    }
  ]
}