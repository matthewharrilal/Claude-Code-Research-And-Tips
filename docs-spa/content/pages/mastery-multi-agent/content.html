<!--
═══════════════════════════════════════════════════════════════════════════════
INLINE THREADING HEADER — Phase 2B
File: docs-spa/content/pages/mastery-multi-agent/content.html
Tier: C | Batch: 12 | Generated: 2026-02-06

1. WHY THIS EXISTS
Rendered HTML content page for the mastery-multi-agent synthesis document.

3. STATUS
ACTIVE

5. BUILT ON
Extracted from synthesis/mastery-multi-agent.md by content extraction scripts.

8. CONSUMED BY
docs-spa/app/(docs)/synthesis/mastery-multi-agent/page.tsx renders this content via dangerouslySetInnerHTML.

═══════════════════════════════════════════════════════════════════════════════
END INLINE THREADING HEADER
═══════════════════════════════════════════════════════════════════════════════
-->

      <!-- Section 1: ESSENCE -->
      <section id="essence" data-activity="essence">
        <div class="essence-box">
          <div class="essence-label">Essence (15 words)</div>
          <div class="essence-text">Orchestrators coordinate. Workers execute. Never mix. This is the iron law of multi-agent architecture.</div>
        </div>

        <div class="info-box">
          <div class="info-title">Note: This Document's Status</div>
          <div class="info-content">
            This document provides a comprehensive overview of multi-agent patterns. For production implementations, see the specific deep-dive documents:
            <code>multi-agent-cc-mirror-complete.md</code> for CC Mirror and <code>ralph-ecosystem-complete.md</code> for Ralph patterns.
          </div>
        </div>
      </section>

      <!-- Section 2: CORE ABSTRACTION + IMPLEMENTATION -->
      <section id="core-abstraction" data-activity="core">
        <h2 class="section-title">
          <span class="section-number">2</span>
          The Core Abstraction
        </h2>

        <div class="core-abstraction">
          <div class="core-philosophy">"You are the CONDUCTOR. Your agents play the instruments."</div>

          <div class="core-code">
            <button class="copy-btn" onclick="copyCode(this, 'ORCHESTRATORS COORDINATE. WORKERS EXECUTE. NEVER MIX.')">
              <i data-lucide="copy" class="w-3 h-3"></i>
              Copy
            </button>
            <code>ORCHESTRATORS COORDINATE. WORKERS EXECUTE. NEVER MIX.</code>
          </div>

          <div class="core-anchor">Violating this causes worker recursion, context explosion, and coordination failures.</div>
        </div>

        <p class="text-text-secondary mb-6">
          This is the foundational principle of ALL multi-agent architecture. The orchestrator decomposes tasks, assigns workers, tracks progress, and synthesizes results. Workers execute specific tasks using tools and report results. Workers NEVER spawn sub-agents or manage task graphs.
        </p>

        <h3 class="font-semibold text-lg mb-4">The Separation in Practice</h3>

        <table class="comparison-table">
          <thead>
            <tr>
              <th>Role</th>
              <th>What They Do</th>
              <th>What They DON'T Do</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>Orchestrator</strong></td>
              <td>Decompose tasks, assign workers, track progress, synthesize results</td>
              <td>Write code, run commands, explore codebases</td>
            </tr>
            <tr>
              <td><strong>Workers</strong></td>
              <td>Execute specific tasks using tools, report results</td>
              <td>Spawn sub-agents, manage task graphs, make architectural decisions</td>
            </tr>
          </tbody>
        </table>

        <h3 class="font-semibold text-lg mb-4 mt-8">Tool Ownership</h3>

        <div class="code-block">
          <button class="copy-btn" onclick="copyCodeBlock(this)">
            <i data-lucide="copy" class="w-3 h-3"></i>
            Copy
          </button>
          <pre><span class="comment"># ORCHESTRATOR uses directly:</span>
Read (references, guides, agent outputs - 1-2 files max)
TaskCreate, TaskUpdate, TaskGet, TaskList
AskUserQuestion
Task (to spawn workers)

<span class="comment"># WORKERS use directly:</span>
Read, Write, Edit, Bash
Glob, Grep, WebFetch, WebSearch, LSP
<span class="comment"># CAN'T: Spawn sub-agents or manage task graph</span></pre>
        </div>
      </section>

      <!-- Section 3: DESIGN DECISIONS -->
      <section id="why-orchestrators" data-activity="decisions">
        <h2 class="section-title">
          <span class="section-number">3</span>
          Design Decisions
        </h2>

        <div class="decision-box">
          <div class="decision-why">WHY ORCHESTRATORS?</div>
          <div class="decision-reasoning">
            Without a central coordinator, agents make conflicting decisions. Two agents might edit the same file, implement overlapping features, or build incompatible interfaces. The orchestrator provides a single source of truth for what's being worked on.
          </div>
          <div class="decision-implication">
            <div class="decision-implication-label">What this means for you</div>
            <div class="text-text-secondary text-sm">
              Your orchestrator MUST track all task state. If you can't query the orchestrator for "what's in progress?", you've violated separation. The orchestrator is your project management layer.
            </div>
          </div>
        </div>

        <div class="decision-box" id="why-tool-ownership">
          <div class="decision-why">WHY TOOL OWNERSHIP MATTERS?</div>
          <div class="decision-reasoning">
            If workers can spawn sub-agents, you get infinite recursion. Worker A spawns Worker B which spawns Worker C... each consuming context and API credits. The recursion is invisible until your bill arrives. Workers using orchestrator tools is like employees hiring other employees without HR approval.
          </div>
          <div class="decision-implication">
            <div class="decision-implication-label">What this means for you</div>
            <div class="text-text-secondary text-sm">
              Enforce tool boundaries in your worker preamble. Explicitly list what tools workers CAN use and what they CAN'T. Never give workers access to TaskCreate or Task tools.
            </div>
          </div>
        </div>

        <div class="decision-box" id="why-worker-preamble">
          <div class="decision-why">WHY WORKER PREAMBLE?</div>
          <div class="decision-reasoning">
            LLMs follow instructions, but they also try to be helpful. Without explicit constraints, a worker asked to "implement auth" might decide to "helpfully" also implement the database, the API, and spawn sub-agents to do it faster. The preamble establishes the worker's sandbox.
          </div>
          <div class="decision-implication">
            <div class="decision-implication-label">What this means for you</div>
            <div class="text-text-secondary text-sm">
              Every worker MUST receive the preamble template. Don't assume workers know their constraints. State them explicitly every time.
            </div>
          </div>
        </div>

        <h3 class="font-semibold text-lg mb-4 mt-8">The Worker Preamble Template</h3>

        <div class="code-block">
          <button class="copy-btn" onclick="copyCodeBlock(this)">
            <i data-lucide="copy" class="w-3 h-3"></i>
            Copy
          </button>
          <pre>CONTEXT: You are a WORKER agent, not an orchestrator.

RULES:
- Complete ONLY the task described below
- Use tools directly (Read, Write, Edit, Bash, etc.)
- Do NOT spawn sub-agents
- Do NOT call TaskCreate or TaskUpdate
- Report your results with absolute file paths

TASK:
[Your specific task here]</pre>
        </div>
      </section>

      <!-- Section 4: ARCHITECTURE COMPARISON -->
      <section id="architectures" data-activity="architectures">
        <h2 class="section-title">
          <span class="section-number">4</span>
          Architecture Comparison
        </h2>

        <p class="text-text-secondary mb-6">
          Four major multi-agent architectures exist in the Claude Code ecosystem. Each solves different problems at different scales.
        </p>

        <div class="hierarchy-box">SIMPLE &lt;-----------------------------------------&gt; COMPLEX

[Ralph Loop]    [CC Mirror]    [Worktrees]    [Gas Town]
     |               |              |              |
Single agent    Multi-agent    Parallel       Agent factory
Retry loop      Task-based     Isolation      Role-based
Bash script     Native CC      Git-native     Full system</div>

        <h3 class="font-semibold text-lg mb-4 mt-8" id="cc-mirror">CC Mirror (Hub-and-Spoke)</h3>

        <p class="text-text-secondary mb-4">
          <strong>Source:</strong> @nummanali (Numman Ali) | <strong>Repo:</strong> github.com/numman-ali/cc-mirror
        </p>

        <p class="text-text-secondary mb-4">
          CC Mirror unlocks Claude Code's disabled native multi-agent orchestration in an isolated environment. It exposes hidden task management primitives (TaskCreate, TaskList, TaskUpdate).
        </p>

        <div class="code-block">
          <button class="copy-btn" onclick="copyCodeBlock(this)">
            <i data-lucide="copy" class="w-3 h-3"></i>
            Copy
          </button>
          <pre><span class="comment"># Quick setup (3 commands)</span>
npx cc-mirror quick --provider mirror --name mclaude
mclaude
<span class="string">"Load the orchestration skill and initiate"</span>

<span class="comment"># Task management (within session)</span>
TaskCreate <span class="string">"subject"</span>, <span class="string">"description"</span>, [<span class="string">"criteria"</span>]
TaskList status=<span class="string">'open'</span>
TaskUpdate id, addBlocks=[<span class="string">"other-id"</span>]</pre>
        </div>

        <div class="checkpoint-box">
          <div class="checkpoint-title">
            <i data-lucide="check-circle" class="w-4 h-4"></i>
            Checkpoint: After CC Mirror Setup
          </div>
          <div class="text-sm text-green-800">
            <strong>Verify:</strong> <code>which mclaude</code> should show path. In mclaude session, ask "List available task management commands" - should mention TaskCreate, TaskList, TaskGet, TaskUpdate.
          </div>
        </div>

        <h3 class="font-semibold text-lg mb-4 mt-8" id="gas-town">Gas Town (Agent Factory)</h3>

        <p class="text-text-secondary mb-4">
          <strong>Source:</strong> @steve_yegge (Steve Yegge) | <strong>Repo:</strong> github.com/steveyegge/gastown
        </p>

        <p class="text-text-secondary mb-4">
          Gas Town is a <em>factory for agents</em>, not a better single agent. Designed for Stage 7+ developers running 10+ agents with hand management. "Claude Code is the world's biggest fuckin' ant. Everyone is focused on making their ant run longer... when nature prefers colonies."
        </p>

        <div class="hierarchy-box">+===============================================================+
|                      GAS TOWN HIERARCHY                        |
+===============================================================+
|                                                                |
|  TOWN LEVEL (Global)                                           |
|  +---------+  +---------+  +---------+                        |
|  |  MAYOR  |  | DEACON  |  |  DOGS   |                        |
|  |  coord  |  | monitor |  |  gates  |                        |
|  +---------+  +---------+  +---------+                        |
|       |                                                        |
|       v                                                        |
|  RIG LEVEL (Per-Project)                                       |
|  +----------+  +----------+  +----------+                     |
|  | REFINERY |  | WITNESS  |  | POLECAT  |                     |
|  | decompose|  | observe  |  |  named   |                     |
|  +----------+  +----------+  +----------+                     |
|                                   |                            |
|                                   v                            |
|                             +----------+                       |
|                             |   CREW   |                       |
|                             |ephemeral |                       |
|                             +----------+                       |
|                                                                |
|  HUMAN LEVEL                                                   |
|  +-------------------------------------------+                |
|  |               OVERSEER (YOU)               |                |
|  |  Product Manager - Decision Maker - Boss   |                |
|  +-------------------------------------------+                |
+===============================================================+</div>

        <div class="code-block">
          <button class="copy-btn" onclick="copyCodeBlock(this)">
            <i data-lucide="copy" class="w-3 h-3"></i>
            Copy
          </button>
          <pre><span class="comment"># Installation</span>
go install github.com/steveyegge/gastown/cmd/gt@latest

<span class="comment"># Initialize and add rig</span>
gt init
gt rig add /path/to/repo

<span class="comment"># Launch roles</span>
gt mayor up
gt refinery up beads
gt polecat up beads alice</pre>
        </div>

        <h3 class="font-semibold text-lg mb-4 mt-8" id="ralph-loop">Ralph Wiggum Loop (Iterative)</h3>

        <p class="text-text-secondary mb-4">
          <strong>Source:</strong> Geoffrey Huntley, popularized by @mattpocockuk, @ryancarson
        </p>

        <p class="text-text-secondary mb-4">
          A bash loop that runs Claude Code repeatedly with fresh context until completion. NOT multi-agent in the traditional sense, but achieves autonomous overnight development through iteration.
        </p>

        <div class="code-block">
          <button class="copy-btn" onclick="copyCode(this, 'while :; do cat PROMPT.md | claude ; done')">
            <i data-lucide="copy" class="w-3 h-3"></i>
            Copy
          </button>
          <pre><span class="comment"># The core pattern</span>
<span class="keyword">while</span> :; <span class="keyword">do</span> cat PROMPT.md | claude ; <span class="keyword">done</span>

<span class="comment"># Official plugin version</span>
/ralph-loop <span class="string">"Build REST API"</span> --completion-promise <span class="string">"COMPLETE"</span> --max-iterations 50</pre>
        </div>

        <h3 class="font-semibold text-lg mb-4 mt-8" id="worktrees">Git Worktrees (Parallel Isolation)</h3>

        <p class="text-text-secondary mb-4">
          Running separate Claude instances in isolated git worktrees, each working on independent features that merge via standard git workflow.
        </p>

        <div class="code-block">
          <button class="copy-btn" onclick="copyCodeBlock(this)">
            <i data-lucide="copy" class="w-3 h-3"></i>
            Copy
          </button>
          <pre><span class="comment"># Create worktrees for parallel work</span>
git worktree add ../feature-auth feature-auth
git worktree add ../feature-payments feature-payments

<span class="comment"># Agent 1 in main checkout</span>
cd ~/project &amp;&amp; claude

<span class="comment"># Agent 2 in worktree (separate terminal)</span>
cd ../feature-auth &amp;&amp; claude

<span class="comment"># Merge when complete</span>
git merge feature-auth feature-payments</pre>
        </div>

        <h3 class="font-semibold text-lg mb-4 mt-8">Quick Comparison Matrix</h3>

        <table class="comparison-table">
          <thead>
            <tr>
              <th>Architecture</th>
              <th>Setup</th>
              <th>Cost</th>
              <th>Parallelism</th>
              <th>Use Case</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>Ralph Loop</strong></td>
              <td>5 min</td>
              <td>$</td>
              <td>None (serial)</td>
              <td>Overnight builds</td>
            </tr>
            <tr>
              <td><strong>CC Mirror</strong></td>
              <td>5 min</td>
              <td>$$</td>
              <td>Native</td>
              <td>80% of projects</td>
            </tr>
            <tr>
              <td><strong>Worktrees</strong></td>
              <td>10 min</td>
              <td>$$$</td>
              <td>Full isolation</td>
              <td>Parallel features</td>
            </tr>
            <tr>
              <td><strong>Gas Town</strong></td>
              <td>Days</td>
              <td>$$$$</td>
              <td>Full factory</td>
              <td>Stage 7+ scale</td>
            </tr>
          </tbody>
        </table>
      </section>

      <!-- Section 5: PATH OF A TASK -->
      <section id="path" data-activity="path">
        <h2 class="section-title">
          <span class="section-number">5</span>
          The Path of a Task (CC Mirror)
        </h2>

        <p class="text-text-secondary mb-6">
          Follow a task through the CC Mirror system to see orchestration in action:
        </p>

        <div class="path-container">
          <div class="path-step">
            <div class="path-number">1</div>
            <div class="path-content">Orchestrator receives high-level goal: <code>"Build user authentication"</code></div>
          </div>
          <div class="path-step">
            <div class="path-number">2</div>
            <div class="path-content">Orchestrator decomposes into tasks with <code>TaskCreate</code>: "Add users table", "Add auth middleware", "Add login form"</div>
          </div>
          <div class="path-step">
            <div class="path-number">3</div>
            <div class="path-content">Orchestrator sets dependencies with <code>addBlocks</code>/<code>addBlockedBy</code>: Login form blocked by middleware</div>
          </div>
          <div class="path-step">
            <div class="path-number">4</div>
            <div class="path-content">Orchestrator spawns worker for first unblocked task with <code>Task</code> tool</div>
          </div>
          <div class="path-step">
            <div class="path-number">5</div>
            <div class="path-content">Worker receives preamble + task description, begins implementation</div>
          </div>
          <div class="path-step">
            <div class="path-number">6</div>
            <div class="path-content">Worker uses <code>Read</code>, <code>Write</code>, <code>Edit</code>, <code>Bash</code> to complete task</div>
          </div>
          <div class="path-step">
            <div class="path-number">7</div>
            <div class="path-content">Worker runs verification: <code>npm run typecheck &amp;&amp; npm test</code></div>
          </div>
          <div class="path-step">
            <div class="path-number">8</div>
            <div class="path-content">Worker reports completion with file paths modified, key decisions made</div>
          </div>
          <div class="path-step">
            <div class="path-number">9</div>
            <div class="path-content">Orchestrator marks task done with <code>TaskUpdate</code>, checks for unblocked tasks</div>
          </div>
          <div class="path-step">
            <div class="path-number">10</div>
            <div class="path-content">Orchestrator spawns next worker for newly-unblocked task</div>
          </div>
          <div class="path-step">
            <div class="path-number">11</div>
            <div class="path-content">Repeat until <code>TaskList status='open'</code> returns empty</div>
          </div>
          <div class="path-step">
            <div class="path-number">12</div>
            <div class="path-content">Orchestrator synthesizes results and reports to human</div>
          </div>
        </div>
      </section>

      <!-- Section 6: GOTCHAS -->
      <section id="gotchas" data-activity="gotchas">
        <h2 class="section-title">
          <span class="section-number">6</span>
          Gotchas
        </h2>

        <p class="text-text-secondary mb-6">
          Real problems you'll hit in multi-agent systems, with concrete symptoms and fixes:
        </p>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Worker Recursion
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Infinite agent spawning, runaway costs, API bills &gt;$500 for simple features</div>
          <div class="gotcha-detail"><strong>Cause:</strong> Workers not properly restricted from spawning sub-agents</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Always use the worker preamble template with explicit "Do NOT spawn sub-agents" rule</div>
        </div>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Context Explosion
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Orchestrator gets "stupider" over time, loses track of goals, forgets early instructions</div>
          <div class="gotcha-detail"><strong>Threshold:</strong> ~80K tokens context rot begins, quality cliff at 100K+</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Workers return summaries only. Orchestrator stays lean. Use <code>/compact</code> when needed.</div>
        </div>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Coordination Failures
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Conflicting edits, lost work, race conditions, two agents modifying same file</div>
          <div class="gotcha-detail"><strong>Cause:</strong> Multiple agents touching same files without locking mechanism</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Use git worktrees for isolation, OR implement file ownership per agent ("Worker 1: only touch src/api/")</div>
        </div>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Dependency Inversion
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Agent tries to build UI before schema exists, features built on broken foundations</div>
          <div class="gotcha-detail"><strong>Cause:</strong> Wrong task ordering in decomposition</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Always order: Schema -&gt; Backend -&gt; Frontend. Explicit <code>addBlockedBy</code> for every dependency.</div>
        </div>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Verification Bypass
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> "Complete" features that don't work, tests pass but functionality broken</div>
          <div class="gotcha-detail"><strong>Cause:</strong> No verification in acceptance criteria, or verification that doesn't actually test the right thing</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Always include <code>npm run typecheck passes</code>, add Playwright for UI verification</div>
        </div>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Model Mismatch
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Expensive failures on simple tasks, weak output on complex tasks</div>
          <div class="gotcha-detail"><strong>Cause:</strong> Using Opus for grep, Haiku for architecture decisions</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Match model to task: Haiku for file lookup, Sonnet for implementation, Opus for architecture</div>
        </div>
      </section>

      <!-- Section 7: WHAT'S HARD -->
      <section id="hard" data-activity="hard">
        <h2 class="section-title">
          <span class="section-number">7</span>
          What's Hard
        </h2>

        <p class="text-text-secondary mb-6">
          These are fundamental tensions in multi-agent systems, not bugs to fix:
        </p>

        <div class="hard-box">
          <div class="hard-title">
            <i data-lucide="flame" class="w-4 h-4"></i>
            Coordination Overhead vs. Parallelism Benefit
          </div>
          <div class="hard-detail"><strong>The tension:</strong> More agents = more parallelism but also more coordination cost. The orchestrator's context fills with status updates, task handoffs, and result synthesis. At some point, coordination cost exceeds parallelism benefit.</div>
          <div class="hard-detail"><strong>Symptoms:</strong> Adding more agents doesn't speed things up. Orchestrator becomes bottleneck. Tasks complete but integration fails.</div>
          <div class="hard-detail"><strong>Mitigation:</strong> Start with 2-3 agents. Add incrementally. Measure if throughput actually increases. Sometimes sequential is faster.</div>
        </div>

        <div class="hard-box">
          <div class="hard-title">
            <i data-lucide="flame" class="w-4 h-4"></i>
            Task Granularity
          </div>
          <div class="hard-detail"><strong>The tension:</strong> Too-small tasks have high overhead (spawning, context loading, result synthesis). Too-large tasks overflow worker context or produce unverifiable outputs.</div>
          <div class="hard-detail"><strong>Symptoms:</strong> Small tasks: workers spend more time loading context than working. Large tasks: workers lose track mid-task, produce broken code.</div>
          <div class="hard-detail"><strong>Mitigation:</strong> Rule of thumb: If description is longer than implementation, task is too small. If task can't be verified in one step, task is too large. Aim for 15-45 minute worker sessions.</div>
        </div>

        <div class="hard-box">
          <div class="hard-title">
            <i data-lucide="flame" class="w-4 h-4"></i>
            Cost Unpredictability
          </div>
          <div class="hard-detail"><strong>The tension:</strong> Multi-agent systems have non-linear cost scaling. One stuck task can trigger retry loops. One misconfigured worker can spawn infinite sub-agents. Costs can explode overnight.</div>
          <div class="hard-detail"><strong>Symptoms:</strong> $500 bills for simple features. No correlation between work done and cost incurred.</div>
          <div class="hard-detail"><strong>Mitigation:</strong> Set hard limits: max-iterations on Ralph, crew.max_per_rig on Gas Town. Monitor token usage. Use Haiku for routine tasks. Review overnight runs in morning before approving more.</div>
        </div>

        <div class="hard-box">
          <div class="hard-title">
            <i data-lucide="flame" class="w-4 h-4"></i>
            No Standardized Protocol
          </div>
          <div class="hard-detail"><strong>The tension:</strong> CC Mirror, Gas Town, and custom solutions all have different task management APIs. Skills learned in one don't transfer to another. No interoperability.</div>
          <div class="hard-detail"><strong>Symptoms:</strong> Starting over when switching architectures. Incompatible tooling. Community fragmentation.</div>
          <div class="hard-detail"><strong>Mitigation:</strong> Choose one architecture and invest deeply. Learn the principles (separation, external state) which transfer even when APIs don't.</div>
        </div>
      </section>

      <!-- Section 8: WHEN TO USE -->
      <section id="when" data-activity="when">
        <h2 class="section-title">
          <span class="section-number">8</span>
          When to Use / When Not
        </h2>

        <div class="when-grid">
          <div class="when-use">
            <div class="when-title">
              <i data-lucide="check" class="w-5 h-5"></i>
              USE MULTI-AGENT WHEN
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>Tasks are parallelizable (independent features that don't share files)</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>You're at Stage 5+ (comfortable with CLI Claude, YOLO mode)</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>Project is large enough that single-agent would take days</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>You have budget for 2-10x single-agent cost</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>Verification is automatable (tests, typecheck, linting)</span>
            </div>
          </div>

          <div class="when-not">
            <div class="when-title">
              <i data-lucide="x" class="w-5 h-5"></i>
              DON'T USE MULTI-AGENT WHEN
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>Stage 1-4 developer (learn single-agent first, or "get face ripped off by chimpanzees")</span>
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>Small feature that fits in single session (orchestration overhead not worth it)</span>
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>Highly coupled codebase (agents will conflict on shared files)</span>
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>Cost-constrained project (multi-agent is expensive)</span>
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>Need guaranteed stability (community tools are beta)</span>
            </div>
          </div>
        </div>

        <h3 class="font-semibold text-lg mb-4 mt-8">Architecture Selection Decision Tree</h3>

        <div class="code-block">
          <pre><span class="comment"># What's your experience level?</span>

Stage 1-4 (Single agent in IDE)
    -&gt; STOP. Use single Claude Code. Learn the basics first.

Stage 5 (CLI single agent, YOLO)
    |
    +-- Want overnight autonomous work?
    |   -&gt; <span class="string">Ralph Wiggum Loop</span>
    |
    +-- Want quick multi-agent test?
        -&gt; <span class="string">CC Mirror</span> (3 commands, done)

Stage 6 (3-5 parallel agents)
    |
    +-- Need task dependencies?
    |   -&gt; <span class="string">CC Mirror Native Orchestration</span>
    |
    +-- Building a product?
        -&gt; <span class="string">Ralph + Playwright</span>

Stage 7+ (10+ agents, hand-managed)
    |
    +-- Cost-sensitive?
    |   -&gt; <span class="string">Enhanced Ralph with Haiku workers</span>
    |
    +-- Want structure + chaos tolerance?
        -&gt; <span class="string">GAS TOWN</span></pre>
        </div>

        <div class="info-box mt-8">
          <div class="info-title">The 80/20 Rule</div>
          <div class="info-content">
            "CC Mirror covers 80% of use cases with zero effort. Gas Town for the remaining 20%." -- @nummanali
          </div>
        </div>
      </section>

    