{
  "items": [
    {
      "id": "inv-1",
      "type": "inversion",
      "linkedSection": "essence",
      "title": "What if workers COULD spawn sub-agents?",
      "content": "<strong>You'd design:</strong> Fully autonomous agents that delegate recursively.<br>\n          <strong>Why this fails:</strong> Infinite recursion. Worker A spawns B spawns C spawns D... each consuming context and credits.<br>\n          <strong>Hidden constraint revealed:</strong> Hierarchy requires explicit boundaries. \"Helpful\" autonomy becomes runaway chaos."
    },
    {
      "id": "min-2",
      "type": "minimal",
      "linkedSection": "essence",
      "title": "The irreducible multi-agent core",
      "content": "<code style=\"background: #f4f4f5; padding: 2px 6px; border-radius: 4px; font-size: 12px;\">Orchestrator + Worker Preamble + Separation</code><br>\n          <strong>Essential:</strong> Central coordinator. Explicit worker boundaries.<br>\n          <strong>Everything else:</strong> Tooling for scale (CC Mirror, Gas Town) or reliability (worktrees)."
    },
    {
      "id": "war-3",
      "type": "warstory",
      "linkedSection": "essence",
      "title": "Steve Yegge: $4K/month, 10+ agents",
      "content": "\"Claude Code is the world's biggest fuckin' ant. Everyone is focused on making their ant run longer... when nature prefers colonies.\" Built Gas Town because single-agent at scale is wrong abstraction."
    },
    {
      "id": "con-4",
      "type": "constraint",
      "linkedSection": "core",
      "title": "One constraint -> FIVE decisions",
      "content": "<strong>ROOT:</strong> LLMs are helpful â†’ Will do more than asked if not constrained<br>\n          -&gt; Must explicitly state worker boundaries<br>\n          -&gt; Must separate orchestrator and worker roles<br>\n          -&gt; Must restrict tool access per role<br>\n          -&gt; Must use preamble template every time<br>\n          -&gt; Must verify workers report, not decide"
    },
    {
      "id": "ana-5",
      "type": "analogy",
      "linkedSection": "core",
      "title": "Multi-Agent = Microservices Architecture",
      "content": "Orchestrator -&gt; API Gateway / Service Mesh<br>\n          Workers -&gt; Individual microservices<br>\n          Tool ownership -&gt; Service boundaries<br>\n          Worker preamble -&gt; Service contract<br>\n          Task dependencies -&gt; Event-driven choreography<br><br>\n          <em>If you've designed microservices, you understand multi-agent.</em>"
    },
    {
      "id": "inv-6",
      "type": "invariant",
      "linkedSection": "core",
      "title": "CC Mirror, Gas Town, Ralph all share INV-001",
      "content": "<strong>INV-001:</strong> Separation of coordination and execution.<br>\n          The pattern that works at 2 agents works at 20. The pattern that fails at 2 fails catastrophically at 20."
    },
    {
      "id": "vio-7",
      "type": "violation",
      "linkedSection": "decisions",
      "title": "If you skip the worker preamble",
      "content": "<strong>IF:</strong> Worker doesn't receive explicit boundaries<br>\n          <strong>THEN:</strong> Worker tries to be \"helpful\" - spawns sub-agents<br>\n          <strong>THEN:</strong> Sub-agents spawn their own sub-agents<br>\n          <strong>THEN:</strong> Infinite recursion, context explosion, API credits drain<br>\n          <strong>FINALLY:</strong> Morning reveals $500+ bill for simple feature<br><br>\n          <em>The fix: Preamble EVERY worker, EVERY time. No exceptions.</em>"
    },
    {
      "id": "trade-8",
      "type": "tradeoff",
      "linkedSection": "decisions",
      "title": "Worker Autonomy vs. Control",
      "content": "<strong>High autonomy:</strong> Workers can \"figure it out,\" but may go off-rails<br>\n          <strong>Low autonomy:</strong> Predictable but orchestrator becomes bottleneck<br>\n          <strong>Medium:</strong> Balanced, but requires careful preamble design<br><br>\n          <strong>Heuristic:</strong> Start with maximum constraint, loosen only when stuck."
    },
    {
      "id": "exp-9",
      "type": "expertise",
      "linkedSection": "decisions",
      "title": "How deep is your understanding?",
      "content": "<strong>Beginner:</strong> \"What's an orchestrator?\" -&gt; The coordinator<br>\n          <strong>Intermediate:</strong> \"Why separate roles?\" -&gt; Prevent recursion<br>\n          <strong>Advanced:</strong> \"When to use which model?\" -&gt; Match to task complexity<br>\n          <strong>Staff:</strong> \"How to handle coordination overhead?\" -&gt; Lean orchestrator context<br>\n          <strong>Expert:</strong> \"Cross-pattern adaptation?\" -&gt; Gas Town roles = CC Mirror tasks"
    },
    {
      "id": "grad-10",
      "type": "gradient",
      "linkedSection": "architectures",
      "title": "How multi-agent systems degrade",
      "content": "<strong>2-3 agents:</strong> Clean coordination, clear ownership<br>\n          <strong>4-6 agents:</strong> Orchestrator context fills, decisions slow<br>\n          <strong>7-10 agents:</strong> Coordination overhead rivals execution time<br>\n          <strong>10+ agents:</strong> Without Gas Town, chaos. Conflicts, lost work.<br><br>\n          <em>Critical: The gradient is invisible until you hit 6+ agents.</em>"
    },
    {
      "id": "comp-11",
      "type": "composition",
      "linkedSection": "architectures",
      "title": "CC Mirror + Git Worktrees",
      "content": "<strong>Works:</strong> Yes, powerfully.<br>\n          <strong>Why it works:</strong> CC Mirror coordinates tasks. Worktrees isolate file systems. No conflicts.<br>\n          <strong>The benefit:</strong> True parallelism with dependency management.<br>\n          <strong>Recommendation:</strong> Use for parallel feature development with shared orchestrator."
    },
    {
      "id": "war-12",
      "type": "warstory",
      "linkedSection": "architectures",
      "title": "Numman Ali: \"80% of use cases\"",
      "content": "Built CC Mirror because native orchestration was there but disabled. 3 commands to unlock. \"80% of use cases with zero effort.\" Gas Town for the remaining 20% who need factory scale."
    },
    {
      "id": "hor-13",
      "type": "horizon",
      "linkedSection": "architectures",
      "title": "How architecture perception evolves",
      "content": "<strong>Week 1:</strong> \"CC Mirror seems easier than Gas Town\"<br>\n          <strong>Week 2:</strong> \"CC Mirror handles everything I need\"<br>\n          <strong>Month 2:</strong> \"I'm managing 8 agents manually, this is chaos\"<br>\n          <strong>Month 3:</strong> \"Gas Town's roles suddenly make sense\"<br><br>\n          <em>Don't judge architecture by week 1 impressions.</em>"
    },
    {
      "id": "eff-14",
      "type": "effect",
      "linkedSection": "architectures",
      "title": "At 10+ agents, model selection dominates cost",
      "content": "<strong>IMPLICATION:</strong> At scale, using Opus for file lookups becomes $15-20/hour waste. Haiku for routine = $1-3/hour.<br>\n          <strong>THRESHOLD:</strong> 10+ agents, multi-hour runs<br>\n          <strong>Budget formula:</strong> Mayor/Refinery (Opus) + Polecats (Sonnet) + Crew (Haiku)"
    },
    {
      "id": "inv-15",
      "type": "inversion",
      "linkedSection": "path",
      "title": "What if there were no task dependencies?",
      "content": "<strong>You'd design:</strong> All tasks in parallel, maximum throughput.<br>\n          <strong>Why this fails:</strong> UI needs backend. Backend needs schema. Login needs auth middleware.<br>\n          <strong>Hidden constraint:</strong> Code has implicit dependencies. Task graph makes them explicit."
    },
    {
      "id": "vio-16",
      "type": "violation",
      "linkedSection": "path",
      "title": "If you skip dependency management (Step 3)",
      "content": "<strong>IF:</strong> Skip <code>addBlockedBy</code> declarations<br>\n          <strong>THEN:</strong> Worker starts UI before backend exists<br>\n          <strong>THEN:</strong> UI makes up API contract, backend implements different one<br>\n          <strong>THEN:</strong> Integration fails, both need rewrite<br>\n          <strong>FINALLY:</strong> 2x work, worse than sequential<br><br>\n          <em>The fix: Schema -&gt; Backend -&gt; Frontend. Always.</em>"
    },
    {
      "id": "ana-17",
      "type": "analogy",
      "linkedSection": "path",
      "title": "CC Mirror tasks = Gas Town roles",
      "content": "<strong>TaskCreate</strong> = Filing work for Refinery<br>\n          <strong>TaskList status='open'</strong> = Checking Polecat availability<br>\n          <strong>addBlockedBy</strong> = Dogs quality gates<br>\n          <strong>Worker completion</strong> = Polecat reporting to Mayor"
    },
    {
      "id": "inf-18",
      "type": "inflection",
      "linkedSection": "gotchas",
      "title": "When orchestrator context flips from help to hurt",
      "content": "<strong>0-40K tokens:</strong> Pure benefit (clear state)<br>\n          <strong>40-60K:</strong> Diminishing returns (more to process)<br>\n          <strong>60-80K:</strong> Neutral (coordination cost = benefit)<br>\n          <strong>80K+:</strong> Net negative (context rot begins)<br><br>\n          <strong>THE INFLECTION:</strong> ~60K tokens<br>\n          <em>Detection: Orchestrator forgetting tasks? Check context size.</em>"
    },
    {
      "id": "fron-19",
      "type": "frontier",
      "linkedSection": "gotchas",
      "title": "UNSOLVED: Optimal agent count",
      "content": "<strong>THE QUESTION:</strong> How many agents maximize throughput for a given project?<br>\n          <strong>WHY IT'S HARD:</strong> Depends on task coupling, codebase structure, coordination overhead. No formula exists.<br>\n          <strong>CURRENT BEST:</strong> Start with 2-3, add incrementally, measure if throughput actually increases."
    },
    {
      "id": "con-20",
      "type": "constraint",
      "linkedSection": "gotchas",
      "title": "Cost unpredictability cascade",
      "content": "<strong>ROOT:</strong> No hard limits on agent behavior<br>\n          -&gt; One stuck task triggers retry loop<br>\n          -&gt; Retries consume more context per attempt<br>\n          -&gt; More context = lower quality = more retries<br>\n          -&gt; Runaway cost spiral<br>\n          -&gt; $500 bill for simple feature"
    },
    {
      "id": "trade-21",
      "type": "tradeoff",
      "linkedSection": "hard",
      "title": "Coordination Overhead vs. Parallelism",
      "content": "<strong>THE DILEMMA:</strong><br>\n          - More agents = more parallelism, but more coordination<br>\n          - Fewer agents = less coordination, but sequential bottlenecks<br>\n          - Optimal varies by project, team, and budget<br><br>\n          <strong>WHY NO PERFECT ANSWER:</strong><br>\n          Coordination overhead is invisible until it dominates. By then you've invested in the architecture.<br><br>\n          <em>Heuristic: If adding another agent doesn't feel like relief, you have too many.</em>"
    },
    {
      "id": "grad-22",
      "type": "gradient",
      "linkedSection": "hard",
      "title": "How task granularity degrades",
      "content": "<strong>Very small (5 min):</strong> 80% overhead, 20% work<br>\n          <strong>Small (15 min):</strong> 40% overhead, 60% work<br>\n          <strong>Medium (30-45 min):</strong> 20% overhead, 80% work (optimal)<br>\n          <strong>Large (1 hr+):</strong> Worker loses track, 50%+ broken output<br><br>\n          <em>Critical: Medium feels \"too big\" but performs best.</em>"
    },
    {
      "id": "war-23",
      "type": "warstory",
      "linkedSection": "hard",
      "title": "Molly Cantillon: Personal Panopticon",
      "content": "8 parallel Claude instances managing life domains: ~/nox (product), ~/metrics (data), ~/email, ~/growth, ~/trades, ~/health, ~/writing, ~/personal. Filesystem isolation prevents context pollution. \"Each instance operates independently.\""
    },
    {
      "id": "exp-24",
      "type": "expertise",
      "linkedSection": "hard",
      "title": "Cost management understanding",
      "content": "<strong>Beginner:</strong> \"What will this cost?\" -&gt; $$ to $$$$ depending on architecture<br>\n          <strong>Intermediate:</strong> \"How to reduce cost?\" -&gt; Use Haiku for routine tasks<br>\n          <strong>Advanced:</strong> \"Cost formula?\" -&gt; Base + Per-Rig + Workers<br>\n          <strong>Staff:</strong> \"Budget limits?\" -&gt; crew.max_per_rig, max-iterations<br>\n          <strong>Expert:</strong> \"Cost vs. value?\" -&gt; Replaces 2-3 junior devs at $5K/month"
    },
    {
      "id": "inv-25",
      "type": "inversion",
      "linkedSection": "when",
      "title": "What if you used multi-agent for a small feature?",
      "content": "<strong>You'd design:</strong> Orchestrator + 3 workers for \"Add button\"<br>\n          <strong>Why this fails:</strong> Orchestration overhead (context loading, task decomposition, result synthesis) exceeds feature cost. Single agent does it in 2 minutes.<br>\n          <strong>Hidden constraint:</strong> Multi-agent has fixed overhead. Only makes sense above threshold."
    },
    {
      "id": "alt-26",
      "type": "alternative",
      "linkedSection": "when",
      "title": "If multi-agent isn't right for your use case",
      "content": "<strong>Need overnight autonomous?</strong> -&gt; Ralph Loop (single agent iteration)<br>\n          <strong>Need quick debugging?</strong> -&gt; Single Claude session<br>\n          <strong>Need cost-efficient?</strong> -&gt; Ralph with Haiku<br>\n          <strong>Need team collaboration?</strong> -&gt; Git worktrees + human orchestration"
    },
    {
      "id": "hor-27",
      "type": "horizon",
      "linkedSection": "when",
      "title": "Stage evolution perception",
      "content": "<strong>Stage 4:</strong> \"Multi-agent sounds powerful\"<br>\n          <strong>Stage 5:</strong> \"I tried it, my face got ripped off\"<br>\n          <strong>Stage 6:</strong> \"Oh, I needed to master single-agent first\"<br>\n          <strong>Stage 7:</strong> \"Now multi-agent multiplies my effectiveness\"<br><br>\n          <em>Don't skip stages. The prerequisites are real.</em>"
    },
    {
      "id": "comp-28",
      "type": "composition",
      "linkedSection": "when",
      "title": "Ralph Loop + CC Mirror",
      "content": "<strong>Works:</strong> Yes, for different phases.<br>\n          <strong>Why it works:</strong> Ralph for overnight autonomous (serial). CC Mirror for daytime parallel work.<br>\n          <strong>Danger:</strong> Context doesn't transfer between systems.<br>\n          <strong>Recommendation:</strong> Use shared prd.json for state continuity."
    },
    {
      "id": "eff-29",
      "type": "effect",
      "linkedSection": "when",
      "title": "At Stage 7+, human becomes bottleneck",
      "content": "<strong>IMPLICATION:</strong> Agents can produce faster than you can review. Morning reveals 50+ commits. Review backlog accumulates. Quality suffers.<br>\n          <strong>THRESHOLD:</strong> 10+ agents, overnight runs<br>\n          <strong>Mitigation:</strong> Dogs quality gates (Gas Town), or batch commits for morning review."
    }
  ]
}