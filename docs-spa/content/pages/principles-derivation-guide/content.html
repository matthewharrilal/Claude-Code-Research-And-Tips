

      <!-- Section 1: ESSENCE -->
      <section id="essence" data-activity="essence">
        <div class="essence-box">
          <div class="essence-label">Essence (15 words)</div>
          <div class="essence-text">Constraint + Principles + Primitives = Pattern. Learn to fish, not just eat fish.</div>
        </div>

        <p class="text-text-secondary mb-6">
          <strong>You Are Here:</strong> This is the "teach a person to fish" guide. Read this after mastering <code>principles-core.md</code> and several existing patterns. This transforms you from a pattern consumer into a pattern creator.
        </p>
      </section>

      <!-- Section 2: CORE ABSTRACTION + IMPLEMENTATION -->
      <section id="core-abstraction" data-activity="core">
        <h2 class="section-title">
          <span class="section-number">2</span>
          The Derivation Process
        </h2>

        <div class="core-abstraction">
          <div class="core-philosophy">"Patterns are crystalized solutions to specific constraints. Change the constraint, derive a new pattern."</div>

          <div class="diagram-box">
  Step 1: IDENTIFY THE CONSTRAINT
          What limitation are you solving for?
              |
              v
  Step 2: APPLY RELEVANT PRINCIPLES
          Which core principles address this?
              |
              v
  Step 3: COMPOSE PRIMITIVES
          What building blocks implement?
              |
              v
  Step 4: VALIDATE COMPOSITION
          Does it actually work?</div>

          <div class="core-anchor">This four-step process produces every major Claude Code pattern.</div>
        </div>

        <p class="text-text-secondary mb-6">
          Every Ralph, CC Mirror, Gas Town, and worktree pattern emerged from someone applying a few core principles to a specific constraint. The derivation skill matters more than pattern memorization.
        </p>

        <p class="text-text-secondary mb-6">
          <strong>The progression:</strong><br>
          1. Learn existing patterns - Immediate productivity<br>
          2. Understand the principles - Know when patterns apply<br>
          3. Master derivation - Create patterns for novel constraints<br><br>
          You are learning step 3.
        </p>
      </section>

      <!-- Section 3: THE 7 CORE PRINCIPLES -->
      <section id="principles" data-activity="principles">
        <h2 class="section-title">
          <span class="section-number">3</span>
          The 7 Core Principles
        </h2>

        <p class="text-text-secondary mb-6">
          Before deriving any pattern, internalize these foundational truths. Every principle has a direct implication for pattern design.
        </p>

        <div class="principle-card" id="principle-1">
          <div class="principle-number">1</div>
          <div class="principle-title">Context Is the Primary Constraint</div>
          <div class="principle-quote">
            "Context rot: LLMs get stupider with more tokens" - @mattpocockuk
          </div>
          <p class="text-text-secondary text-sm mb-3">
            The ~200K token context window (effective ~100K for quality work) is a <strong>hard ceiling</strong> that shapes every architectural decision.
          </p>
          <div class="principle-implication">
            <strong>Implication:</strong> Any pattern that doesn't respect context limits will eventually fail.
          </div>
        </div>

        <div class="principle-card">
          <div class="principle-number">2</div>
          <div class="principle-title">External State &gt; Internal Memory</div>
          <div class="principle-quote">
            "Each iteration spawns a NEW instance with NO memory. Continuity comes from: Git history, prd.json, progress.txt" - Ryan Carson
          </div>
          <p class="text-text-secondary text-sm mb-3">
            The agent is stateless. All durable state must exist in the filesystem or version control.
          </p>
          <div class="principle-implication">
            <strong>Implication:</strong> Memory is files. Not conversation. Not summaries. Files.
          </div>
        </div>

        <div class="principle-card">
          <div class="principle-number">3</div>
          <div class="principle-title">Verification Is Non-Negotiable</div>
          <p class="text-text-secondary text-sm mb-3">
            Tests, type checks, and quality gates prevent error propagation. A task isn't complete until it's verified.
          </p>
          <div class="principle-implication">
            <strong>Implication:</strong> Any autonomous pattern must include verification steps, or errors compound.
          </div>
        </div>

        <div class="principle-card">
          <div class="principle-number">4</div>
          <div class="principle-title">Separation of Concerns</div>
          <div class="principle-quote">
            "YOU DO NOT WRITE CODE. YOU DO NOT RUN COMMANDS. You are the CONDUCTOR." - CC Mirror philosophy
          </div>
          <p class="text-text-secondary text-sm mb-3">
            Planning and execution are fundamentally different modes. Mixing them causes context pollution, scope creep, and verification bypass.
          </p>
          <div class="principle-implication">
            <strong>Implication:</strong> Orchestrators orchestrate. Workers execute. Never mix.
          </div>
        </div>

        <div class="principle-card">
          <div class="principle-number">5</div>
          <div class="principle-title">Structured Data Beats Natural Language</div>
          <div class="principle-quote">
            "You're a few .md files from outperforming 99% of people" - @gregisenberg
          </div>
          <p class="text-text-secondary text-sm mb-3">
            JSON parses deterministically. Markdown has conventions. Natural language is ambiguous.
          </p>
          <div class="principle-implication">
            <strong>Implication:</strong> Store state in structured formats (JSON, YAML) for machine consumption, Markdown for human context.
          </div>
        </div>

        <div class="principle-card">
          <div class="principle-number">6</div>
          <div class="principle-title">Fresh Context Beats Extended Sessions</div>
          <p class="text-text-secondary text-sm mb-3">
            New agent instances with external state beat long conversations with internal memory. Compaction is lossy; files are not.
          </p>
          <div class="principle-implication">
            <strong>Implication:</strong> Prefer iteration loops over single long sessions.
          </div>
        </div>

        <div class="principle-card" id="principle-7">
          <div class="principle-number">7</div>
          <div class="principle-title">Isolation Enables Parallelism</div>
          <p class="text-text-secondary text-sm mb-3">
            Agents that share state conflict. Agents in isolated environments (branches, worktrees, containers) can work in parallel.
          </p>
          <div class="principle-implication">
            <strong>Implication:</strong> Design for isolation first, coordination second.
          </div>
        </div>
      </section>

      <!-- Section 4: PRIMITIVES CATALOG -->
      <section id="primitives" data-activity="primitives">
        <h2 class="section-title">
          <span class="section-number">4</span>
          The Primitives Catalog
        </h2>

        <p class="text-text-secondary mb-6">
          These are the building blocks you compose into patterns. Every pattern is a specific combination of primitives selected to address a constraint.
        </p>

        <h3 class="font-semibold text-lg mb-4" id="execution-primitives">Execution Primitives</h3>

        <table class="primitive-table">
          <thead>
            <tr>
              <th>Primitive</th>
              <th>What It Does</th>
              <th>When To Use</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>claude "..."</code></td>
              <td>Single Claude invocation</td>
              <td>Atomic task execution</td>
            </tr>
            <tr>
              <td><code>for</code> loop</td>
              <td>Repeated invocations</td>
              <td>Sequential iteration</td>
            </tr>
            <tr>
              <td><code>&amp;</code> (background)</td>
              <td>Parallel execution</td>
              <td>Independent tasks</td>
            </tr>
            <tr>
              <td><code>Task()</code> tool</td>
              <td>Spawn subagent</td>
              <td>Delegated work</td>
            </tr>
            <tr>
              <td>Git worktree</td>
              <td>Isolated directory</td>
              <td>Parallel branches</td>
            </tr>
            <tr>
              <td>Docker container</td>
              <td>Isolated environment</td>
              <td>Maximum isolation</td>
            </tr>
          </tbody>
        </table>

        <h3 class="font-semibold text-lg mb-4 mt-8" id="state-primitives">State Primitives</h3>

        <table class="primitive-table">
          <thead>
            <tr>
              <th>Primitive</th>
              <th>What It Does</th>
              <th>When To Use</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>progress.txt</code></td>
              <td>Append-only log</td>
              <td>Cross-iteration memory</td>
            </tr>
            <tr>
              <td><code>prd.json</code></td>
              <td>Task state tracking</td>
              <td>Pass/fail status</td>
            </tr>
            <tr>
              <td><code>CLAUDE.md</code></td>
              <td>Project context</td>
              <td>Onboarding/constraints</td>
            </tr>
            <tr>
              <td>Git commit</td>
              <td>Checkpoint</td>
              <td>State preservation</td>
            </tr>
            <tr>
              <td>Handoff JSON</td>
              <td>Agent communication</td>
              <td>Multi-agent coordination</td>
            </tr>
            <tr>
              <td><code>status.json</code></td>
              <td>Current state</td>
              <td>Live monitoring</td>
            </tr>
          </tbody>
        </table>

        <h3 class="font-semibold text-lg mb-4 mt-8">Control Primitives</h3>

        <table class="primitive-table">
          <thead>
            <tr>
              <th>Primitive</th>
              <th>What It Does</th>
              <th>When To Use</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Completion signal</td>
              <td><code>&lt;promise&gt;COMPLETE&lt;/promise&gt;</code></td>
              <td>Loop termination</td>
            </tr>
            <tr>
              <td>Hooks</td>
              <td>Lifecycle automation</td>
              <td>Notifications, formatting</td>
            </tr>
            <tr>
              <td>Quality gates</td>
              <td>Tests/types before commit</td>
              <td>Verification enforcement</td>
            </tr>
            <tr>
              <td>Timeout</td>
              <td>Max iterations</td>
              <td>Safety limits</td>
            </tr>
            <tr>
              <td>Worker preamble</td>
              <td>Role enforcement</td>
              <td>Orchestrator/worker separation</td>
            </tr>
          </tbody>
        </table>
      </section>

      <!-- Section 5: WORKED EXAMPLES -->
      <section id="examples" data-activity="examples">
        <h2 class="section-title">
          <span class="section-number">5</span>
          Worked Examples
        </h2>

        <p class="text-text-secondary mb-6">
          Watch the derivation process in action. Each example shows the four steps applied to a real constraint.
        </p>

        <div class="worked-example">
          <div class="worked-example-title">
            <i data-lucide="git-branch" class="w-5 h-5"></i>
            Example 1: Deriving Ralph Wiggum from Principles
          </div>

          <div class="worked-step">
            <div class="worked-step-label">Step 1: Identify the Constraint</div>
            <p class="text-text-secondary text-sm">
              "I need autonomous execution without quality degradation over time."<br>
              The constraint is: <strong>long-running autonomous work that doesn't get stupider.</strong>
            </p>
          </div>

          <div class="worked-step">
            <div class="worked-step-label">Step 2: Apply Relevant Principles</div>
            <ul class="text-text-secondary text-sm list-disc list-inside">
              <li><strong>P1: Context Is Primary</strong> - Quality degrades with context usage</li>
              <li><strong>P6: Fresh Context &gt; Extended</strong> - New instances don't accumulate pollution</li>
              <li><strong>P2: External State &gt; Internal</strong> - State must persist outside conversation</li>
              <li><strong>P3: Verification Is Non-Negotiable</strong> - Each iteration must verify its work</li>
            </ul>
          </div>

          <div class="worked-step">
            <div class="worked-step-label">Step 3: Compose Primitives</div>
            <table class="primitive-table">
              <thead>
                <tr>
                  <th>Principle</th>
                  <th>Primitive Implementation</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Fresh context</td>
                  <td>Bash loop spawning new Claude instances</td>
                </tr>
                <tr>
                  <td>External memory</td>
                  <td><code>progress.txt</code> (append-only), <code>prd.json</code> (task state)</td>
                </tr>
                <tr>
                  <td>Verification</td>
                  <td>Tests + types must pass before marking complete</td>
                </tr>
                <tr>
                  <td>Termination</td>
                  <td><code>&lt;promise&gt;COMPLETE&lt;/promise&gt;</code> signal for loop exit</td>
                </tr>
              </tbody>
            </table>
          </div>

          <div class="worked-step">
            <div class="worked-step-label">Step 4: Validate Composition</div>
            <div class="code-block">
              <button class="copy-btn" onclick="copyCodeBlock(this)">
                <i data-lucide="copy" class="w-3 h-3"></i>
                Copy
              </button>
              <pre><span class="keyword">for</span> (( i=1; i&lt;=$MAX_ITERATIONS; i++ )); <span class="keyword">do</span>
  claude <span class="string">"Review prd.json. Pick ONE task with passes: false.
          Implement it. Run tests.
          If passing, mark passes: true, commit.
          Append learnings to progress.txt.
          If ALL complete, output: &lt;promise&gt;COMPLETE&lt;/promise&gt;"</span>

  <span class="keyword">if</span> grep -q <span class="string">"&lt;promise&gt;COMPLETE&lt;/promise&gt;"</span> output.txt; <span class="keyword">then</span>
    <span class="keyword">break</span>
  <span class="keyword">fi</span>
<span class="keyword">done</span></pre>
            </div>
            <p class="text-text-secondary text-sm">
              <strong>Validation:</strong> Context limits respected? Yes. State recoverable? Yes. Verification steps? Yes. Human can intervene? Yes.
            </p>
          </div>
        </div>

        <div class="worked-example" id="example-cc-mirror">
          <div class="worked-example-title">
            <i data-lucide="git-merge" class="w-5 h-5"></i>
            Example 2: Deriving CC Mirror from Principles
          </div>

          <div class="worked-step">
            <div class="worked-step-label">Step 1: Identify the Constraint</div>
            <p class="text-text-secondary text-sm">
              "I need multiple agents working in parallel without chaos."<br>
              The constraint is: <strong>parallelism without coordination failures.</strong>
            </p>
          </div>

          <div class="worked-step">
            <div class="worked-step-label">Step 2: Apply Relevant Principles</div>
            <ul class="text-text-secondary text-sm list-disc list-inside">
              <li><strong>P4: Separation of Concerns</strong> - Planning and execution must be separate</li>
              <li><strong>P7: Isolation Enables Parallelism</strong> - Workers need isolated contexts</li>
              <li><strong>P2: External State &gt; Internal</strong> - Coordination via files/APIs</li>
              <li><strong>P3: Verification Is Non-Negotiable</strong> - Each worker's output must be checked</li>
            </ul>
          </div>

          <div class="worked-step">
            <div class="worked-step-label">Step 3: Compose Primitives</div>
            <table class="primitive-table">
              <thead>
                <tr>
                  <th>Principle</th>
                  <th>Primitive Implementation</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Separation</td>
                  <td>Orchestrator (Opus) + Workers (Sonnet/Haiku)</td>
                </tr>
                <tr>
                  <td>Isolation</td>
                  <td>Task tool spawns isolated subagents</td>
                </tr>
                <tr>
                  <td>External state</td>
                  <td>TaskCreate/TaskUpdate API for coordination</td>
                </tr>
                <tr>
                  <td>Verification</td>
                  <td>Acceptance criteria in task definitions</td>
                </tr>
              </tbody>
            </table>
          </div>

          <div class="worked-step">
            <div class="worked-step-label">Step 4: Validate - Worker Preamble</div>
            <div class="code-block">
              <button class="copy-btn" onclick="copyCodeBlock(this)">
                <i data-lucide="copy" class="w-3 h-3"></i>
                Copy
              </button>
              <pre><span class="comment">CONTEXT: You are a WORKER agent, not an orchestrator.</span>
<span class="comment">RULES:</span>
<span class="comment">  - Complete ONLY the task described below</span>
<span class="comment">  - Do NOT spawn sub-agents</span>
<span class="comment">  - Do NOT call TaskCreate or TaskUpdate</span>
<span class="comment">TASK: [specific work]</span></pre>
            </div>
          </div>
        </div>

        <div class="worked-example" id="example-worktree">
          <div class="worked-example-title">
            <i data-lucide="git-fork" class="w-5 h-5"></i>
            Example 3: Deriving Git Worktree Parallelism
          </div>

          <div class="worked-step">
            <div class="worked-step-label">Step 1: Identify the Constraint</div>
            <p class="text-text-secondary text-sm">
              "I need multiple features developed simultaneously without file conflicts."<br>
              The constraint is: <strong>parallel work on shared codebase without conflicts.</strong>
            </p>
          </div>

          <div class="worked-step">
            <div class="worked-step-label">Step 2: Apply Relevant Principles</div>
            <ul class="text-text-secondary text-sm list-disc list-inside">
              <li><strong>P7: Isolation Enables Parallelism</strong> - Each agent needs its own directory</li>
              <li><strong>P2: External State &gt; Internal</strong> - Git history is shared, files are isolated</li>
              <li><strong>P6: Fresh Context &gt; Extended</strong> - Each worktree gets fresh agent instances</li>
            </ul>
          </div>

          <div class="worked-step">
            <div class="worked-step-label">Step 4: The Resulting Pattern</div>
            <div class="code-block">
              <button class="copy-btn" onclick="copyCodeBlock(this)">
                <i data-lucide="copy" class="w-3 h-3"></i>
                Copy
              </button>
              <pre><span class="comment"># Create isolated worktrees</span>
git worktree add ../wt-feature-auth feature-auth
git worktree add ../wt-feature-payments feature-payments

<span class="comment"># Run parallel agents</span>
(cd ../wt-feature-auth &amp;&amp; claude <span class="string">"Implement auth"</span>) &amp;
(cd ../wt-feature-payments &amp;&amp; claude <span class="string">"Implement payments"</span>) &amp;
wait

<span class="comment"># Human merges</span>
git checkout main
git merge feature-auth
git merge feature-payments</pre>
            </div>
          </div>
        </div>
      </section>

      <!-- Section 6: PRACTICE PROBLEMS -->
      <section id="practice" data-activity="practice">
        <h2 class="section-title">
          <span class="section-number">6</span>
          Practice Problems
        </h2>

        <p class="text-text-secondary mb-6">
          Apply the derivation process yourself. Use the DIY worksheet for each problem.
        </p>

        <div class="practice-problem">
          <div class="practice-title">
            <i data-lucide="file-text" class="w-5 h-5"></i>
            Problem 1: The Documentation Gap
          </div>
          <div class="practice-constraint">
            <strong>Constraint:</strong> You need to generate comprehensive documentation for a large codebase, but reading the entire codebase would exhaust context.
          </div>
          <div class="practice-hints">
            <strong>Hints:</strong><br>
            - What principle addresses context exhaustion?<br>
            - How can you process the codebase in chunks?<br>
            - How should documentation state accumulate?
          </div>
        </div>

        <div class="practice-problem">
          <div class="practice-title">
            <i data-lucide="shield" class="w-5 h-5"></i>
            Problem 2: The Security Audit
          </div>
          <div class="practice-constraint">
            <strong>Constraint:</strong> You need multiple security perspectives reviewing code (OWASP, crypto, injection, etc.) but a single agent can't hold all expertise.
          </div>
          <div class="practice-hints">
            <strong>Hints:</strong><br>
            - What principle addresses multiple perspectives?<br>
            - How do specialists work without conflicting?<br>
            - How are findings aggregated?
          </div>
        </div>

        <div class="practice-problem">
          <div class="practice-title">
            <i data-lucide="refresh-cw" class="w-5 h-5"></i>
            Problem 3: The Living Specification
          </div>
          <div class="practice-constraint">
            <strong>Constraint:</strong> Requirements change during development. How do you prevent the PRD from becoming stale?
          </div>
          <div class="practice-hints">
            <strong>Hints:</strong><br>
            - What principle addresses state management?<br>
            - When should the spec update?<br>
            - How do you prevent drift between spec and code?
          </div>
        </div>

        <div class="practice-problem">
          <div class="practice-title">
            <i data-lucide="dollar-sign" class="w-5 h-5"></i>
            Problem 4: The Cost Optimizer
          </div>
          <div class="practice-constraint">
            <strong>Constraint:</strong> You're running expensive Opus calls but many tasks don't need that capability. How do you minimize cost while maintaining quality?
          </div>
          <div class="practice-hints">
            <strong>Hints:</strong><br>
            - What principle addresses separation?<br>
            - How do you classify task complexity?<br>
            - What triggers model escalation?
          </div>
        </div>

        <div class="practice-problem">
          <div class="practice-title">
            <i data-lucide="moon" class="w-5 h-5"></i>
            Problem 5: The Overnight Orchestrator
          </div>
          <div class="practice-constraint">
            <strong>Constraint:</strong> You want to run CC Mirror-style multi-agent work overnight, but need to handle failures gracefully and notify you of critical issues.
          </div>
          <div class="practice-hints">
            <strong>Hints:</strong><br>
            - Combine which existing patterns?<br>
            - What triggers human notification?<br>
            - How does work resume after failure?
          </div>
        </div>
      </section>

      <!-- Section 7: TROUBLESHOOTING / GOTCHAS -->
      <section id="gotchas" data-activity="gotchas">
        <h2 class="section-title">
          <span class="section-number">7</span>
          Troubleshooting
        </h2>

        <p class="text-text-secondary mb-6">
          Common issues when deriving patterns, with fixes:
        </p>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Derived Pattern Fails in Practice
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Pattern looks correct on paper but fails when executed</div>
          <div class="gotcha-detail"><strong>Cause:</strong> Usually a missed validation question or incomplete primitive selection</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Re-run the validation checklist rigorously. Check for missing primitives (often: external memory, termination condition). Test with a trivial example before scaling.</div>
        </div>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Can't Identify the Right Principles
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Constraint is clear but unsure which principles apply</div>
          <div class="gotcha-detail"><strong>Cause:</strong> Incomplete understanding of principle implications</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Use this mapping:<br>
            - Long-running work? P1 (Context), P6 (Fresh), P2 (External)<br>
            - Quality degradation? P6 (Fresh), P3 (Verification)<br>
            - Parallel work? P7 (Isolation), P4 (Separation)<br>
            - Coordination needed? P4 (Separation), P2 (External)
          </div>
        </div>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Primitives Don't Compose Cleanly
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Primitives work individually but conflict when combined</div>
          <div class="gotcha-detail"><strong>Cause:</strong> Incompatible primitives or missing "glue" primitive</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Check the compatibility matrix in <code>architecture-composition-rules.md</code>. Add handoff mechanisms between incompatible primitives.</div>
        </div>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Pattern Too Complex
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Derived pattern has 10+ primitives; hard to understand</div>
          <div class="gotcha-detail"><strong>Cause:</strong> Over-engineering; trying to solve too many constraints at once</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Decompose into smaller patterns that compose. Start with minimal viable pattern, add primitives incrementally. Ask: "What's the simplest pattern that addresses the primary constraint?"</div>
        </div>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Reinventing Existing Patterns
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Spend time deriving a pattern that already exists</div>
          <div class="gotcha-detail"><strong>Cause:</strong> Not checking existing pattern catalog first</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Before deriving, search existing patterns. Ask: "Is my constraint similar to one that led to Ralph/CC Mirror/etc.?" Consider adapting an existing pattern.</div>
        </div>

        <div class="checklist">
          <div class="checklist-title">Validation Checklist (Before Deploying Any Derived Pattern)</div>
          <div class="checklist-item">
            <div class="checklist-box"></div>
            <span>Maximum context usage estimated and acceptable</span>
          </div>
          <div class="checklist-item">
            <div class="checklist-box"></div>
            <span>All state persisted to filesystem or git</span>
          </div>
          <div class="checklist-item">
            <div class="checklist-box"></div>
            <span>Can resume from any checkpoint</span>
          </div>
          <div class="checklist-item">
            <div class="checklist-box"></div>
            <span>Failures detected, logged, with retry strategy</span>
          </div>
          <div class="checklist-item">
            <div class="checklist-box"></div>
            <span>Quality gates (tests/types) in workflow</span>
          </div>
          <div class="checklist-item">
            <div class="checklist-box"></div>
            <span>Can pause at any point; state is inspectable</span>
          </div>
          <div class="checklist-item">
            <div class="checklist-box"></div>
            <span>Clear completion criteria; max iterations defined</span>
          </div>
          <div class="checklist-item">
            <div class="checklist-box"></div>
            <span>Graceful shutdown preserves state</span>
          </div>
        </div>
      </section>

      <!-- Section 8: WHEN TO USE / WHEN NOT -->
      <section id="when" data-activity="when">
        <h2 class="section-title">
          <span class="section-number">8</span>
          When to Derive / When Not
        </h2>

        <div class="when-grid">
          <div class="when-use">
            <div class="when-title">
              <i data-lucide="check" class="w-5 h-5"></i>
              DERIVE A NEW PATTERN WHEN
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>Your constraint genuinely differs from existing patterns</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>Existing patterns fail your validation checklist</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>You understand why existing patterns don't fit</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>You can articulate the specific constraint</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>You've mastered principles-core.md first</span>
            </div>
          </div>

          <div class="when-not">
            <div class="when-title">
              <i data-lucide="x" class="w-5 h-5"></i>
              DON'T DERIVE WHEN
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>Existing pattern fits with minor adaptation</span>
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>You haven't tried existing patterns first</span>
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>You can't articulate the specific constraint</span>
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>Derivation feels like "fun" rather than "necessary"</span>
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>You're still learning the 7 principles</span>
            </div>
          </div>
        </div>

        <h3 class="font-semibold text-lg mb-4 mt-8">Quick Reference: Principle to Pattern Mapping</h3>

        <table class="primitive-table">
          <thead>
            <tr>
              <th>When You Need</th>
              <th>Apply Principle</th>
              <th>Consider Pattern</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Long-running autonomy</td>
              <td>Fresh context + External state</td>
              <td>Ralph Loop</td>
            </tr>
            <tr>
              <td>Parallel work</td>
              <td>Isolation + Separation</td>
              <td>CC Mirror, Worktrees</td>
            </tr>
            <tr>
              <td>Quality consistency</td>
              <td>Verification</td>
              <td>CI Green Enforcement</td>
            </tr>
            <tr>
              <td>Multi-perspective</td>
              <td>Separation + Isolation</td>
              <td>Adversarial Speccing</td>
            </tr>
            <tr>
              <td>Persistent memory</td>
              <td>External state</td>
              <td>progress.txt, Claude-Mem</td>
            </tr>
            <tr>
              <td>Human oversight</td>
              <td>External state + Hooks</td>
              <td>Notification patterns</td>
            </tr>
            <tr>
              <td>Cost optimization</td>
              <td>Separation</td>
              <td>Model selection matrix</td>
            </tr>
            <tr>
              <td>Recovery</td>
              <td>External state + Verification</td>
              <td>Checkpointing</td>
            </tr>
          </tbody>
        </table>
      </section>

    