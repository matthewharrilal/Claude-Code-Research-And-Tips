{
  "items": [
    {
      "id": "inv-1",
      "type": "inversion",
      "linkedSection": "essence",
      "title": "What if you just memorized patterns?",
      "content": "<strong>You'd design:</strong> A lookup table - constraint in, pattern out.<br>\n          <strong>Why this fails:</strong> Your real constraint never matches the catalog exactly. Novel situations have no entry.<br>\n          <strong>Hidden insight:</strong> Derivation skill &gt; pattern memorization because constraints evolve faster than catalogs."
    },
    {
      "id": "min-2",
      "type": "minimal",
      "linkedSection": "essence",
      "title": "The irreducible core of derivation",
      "content": "<strong>Step 1:</strong> What's forcing my hand? (Constraint)<br>\n          <strong>Step 2:</strong> What's true about LLMs? (Principles)<br>\n          <strong>Step 3:</strong> What tools exist? (Primitives)<br>\n          <strong>Minimal derivation:</strong> Constraint + one principle + one primitive = simplest possible pattern."
    },
    {
      "id": "war-3",
      "type": "warstory",
      "linkedSection": "essence",
      "title": "Matt Pocock: Why \"context rot\" stuck",
      "content": "The phrase \"context rot\" spread because it names the constraint precisely. Before: \"it gets weird after a while.\" After: a derivable principle (P1) that implies fresh context (P6).<br><br>\n          <em>Naming constraints enables derivation.</em>"
    },
    {
      "id": "con-4",
      "type": "constraint",
      "linkedSection": "core",
      "title": "The 4 steps cascade logically",
      "content": "<strong>ROOT:</strong> Every pattern exists to solve a constraint<br>\n          - If no constraint, no pattern needed<br>\n          - Constraint defines scope of solution<br>\n          - Principles narrow the solution space<br>\n          - Primitives are the only building materials<br>\n          - Validation ensures the composition actually works<br><br>\n          <em>Skip any step and the pattern fails.</em>"
    },
    {
      "id": "ana-5",
      "type": "analogy",
      "linkedSection": "core",
      "title": "Derivation = Engineering Design Process",
      "content": "<strong>Requirements</strong> - Constraint identification<br>\n          <strong>Physics laws</strong> - Core principles (immutable)<br>\n          <strong>Materials library</strong> - Primitives catalog<br>\n          <strong>Testing</strong> - Validation checklist<br><br>\n          If you've done engineering design, you already know how to derive patterns."
    },
    {
      "id": "inv-6",
      "type": "invariant",
      "linkedSection": "core",
      "title": "Every major pattern shares the same derivation structure",
      "content": "Ralph, CC Mirror, Gas Town, Worktree parallelism - all were derived the same way. Different constraints, same process.<br><br>\n          <em>The method is invariant even when outputs differ.</em>"
    },
    {
      "id": "hor-7",
      "type": "horizon",
      "linkedSection": "core",
      "title": "Derivation skill compounds over time",
      "content": "<strong>Month 1:</strong> \"I just need to learn Ralph\"<br>\n          <strong>Month 3:</strong> \"Ralph doesn't fit my use case\"<br>\n          <strong>Month 6:</strong> \"I derived a pattern that actually fits\"<br>\n          <strong>Month 12:</strong> \"I derive patterns faster than I can read docs\"<br><br>\n          <em>Pattern knowledge depreciates. Derivation skill appreciates.</em>"
    },
    {
      "id": "exp-8",
      "type": "expertise",
      "linkedSection": "principles",
      "title": "How deeply do you understand the 7 principles?",
      "content": "<strong>Beginner:</strong> \"What are the 7 principles?\"<br>\n          - Can list them<br>\n          <strong>Intermediate:</strong> \"Why these 7?\"<br>\n          - Understands they're derived from LLM physics<br>\n          <strong>Advanced:</strong> \"Which principles conflict?\"<br>\n          - Fresh context vs. external state (memory loss)<br>\n          <strong>Staff:</strong> \"When do I violate a principle?\"<br>\n          - When the constraint overrides it explicitly<br>\n          <strong>Expert:</strong> \"What's the 8th principle?\"<br>\n          - The ones not yet discovered"
    },
    {
      "id": "grad-9",
      "type": "gradient",
      "linkedSection": "principles",
      "title": "How principle violations compound",
      "content": "<strong>Violate P1 (Context):</strong> Quality degrades gradually, then cliff<br>\n          <strong>Violate P2 (External):</strong> Works until restart, then amnesia<br>\n          <strong>Violate P3 (Verification):</strong> Looks good, accumulates hidden debt<br>\n          <strong>Violate P4 (Separation):</strong> Works small, chaos at scale<br><br>\n          <em>Each violation is invisible until it's catastrophic.</em>"
    },
    {
      "id": "trade-10",
      "type": "tradeoff",
      "linkedSection": "principles",
      "title": "The Fresh Context vs. Memory Dilemma",
      "content": "<strong>P6 says:</strong> Fresh context beats extended sessions<br>\n          <strong>P2 says:</strong> External state persists memory<br>\n          <strong>The tension:</strong> Fresh context = lose context. External state = limited bandwidth.<br><br>\n          <strong>Resolution:</strong> progress.txt as \"compressed memory\" - lossy but bounded."
    },
    {
      "id": "vio-11",
      "type": "violation",
      "linkedSection": "principles",
      "title": "If you ignore P3 (Verification)",
      "content": "<strong>IF:</strong> Skip verification in autonomous pattern<br>\n          <strong>THEN:</strong> Errors enter the codebase undetected<br>\n          <strong>THEN:</strong> Next iteration builds on broken foundation<br>\n          <strong>THEN:</strong> Errors compound exponentially<br>\n          <strong>FINALLY:</strong> 50 iterations of garbage<br><br>\n          <em>P3 is the firewall against compounding failure.</em>"
    },
    {
      "id": "inv-12",
      "type": "inversion",
      "linkedSection": "principles",
      "title": "What if context windows were unlimited?",
      "content": "<strong>You'd design:</strong> Single session per project. No files needed. No restarts.<br>\n          <strong>Why this fails:</strong> P1 would cease to exist. P6 would be unnecessary.<br>\n          <strong>Hidden insight:</strong> Most principles exist because context is finite. If that changes, patterns must be re-derived."
    },
    {
      "id": "comp-13",
      "type": "composition",
      "linkedSection": "primitives",
      "title": "Loop + Task() + Worktree = Factory",
      "content": "<strong>Works:</strong> Ralph loop as outer iteration, Task() for parallel workers, worktrees for isolation.<br>\n          <strong>Danger:</strong> Coordination complexity. Each primitive adds surface area.<br>\n          <strong>When to combine:</strong> Only when constraint demands all three. Start minimal."
    },
    {
      "id": "ana-14",
      "type": "analogy",
      "linkedSection": "primitives",
      "title": "Primitives = Standard Library Functions",
      "content": "<strong>for loop</strong> - iteration<br>\n          <strong>prd.json</strong> - data structure<br>\n          <strong>Task()</strong> - thread spawn<br>\n          <strong>Git worktree</strong> - process isolation<br><br>\n          If you've programmed, you already know the primitives - just different syntax."
    },
    {
      "id": "fron-15",
      "type": "frontier",
      "linkedSection": "primitives",
      "title": "UNSOLVED: Primitive discovery",
      "content": "<strong>The question:</strong> How do we discover new primitives?<br>\n          <strong>Why it's hard:</strong> Primitives emerge from constraints we haven't seen yet.<br>\n          <strong>Current best:</strong> Community experimentation, pattern mining from production."
    },
    {
      "id": "inf-16",
      "type": "inflection",
      "linkedSection": "primitives",
      "title": "When primitives flip from help to hurt",
      "content": "<strong>1-3 primitives:</strong> Clean, understandable<br>\n          <strong>4-6 primitives:</strong> Manageable with documentation<br>\n          <strong>7-9 primitives:</strong> Coordination overhead dominates<br>\n          <strong>10+ primitives:</strong> Pattern too complex to maintain<br><br>\n          <strong>THE INFLECTION:</strong> ~6 primitives<br>\n          <em>Detection: If you can't hold the pattern in your head, it's too complex.</em>"
    },
    {
      "id": "war-17",
      "type": "warstory",
      "linkedSection": "examples",
      "title": "Ryan Carson's Ralph derivation moment",
      "content": "\"I kept extending sessions and Claude got dumber. Then I realized: what if I just... restart? And write everything to files? It was so obvious in hindsight.\"<br><br>\n          <em>Most derivations feel obvious after the fact.</em>"
    },
    {
      "id": "con-18",
      "type": "constraint",
      "linkedSection": "examples",
      "title": "CC Mirror's constraint cascade",
      "content": "<strong>ROOT:</strong> Need parallelism without chaos<br>\n          - Workers can't share state (conflict)<br>\n          - Need coordination (orchestrator)<br>\n          - Orchestrator can't execute (context pollution)<br>\n          - Workers need isolation (Task tool)<br>\n          - Workers need constraints (preambles)<br><br>\n          <em>One constraint, five architectural decisions.</em>"
    },
    {
      "id": "eff-19",
      "type": "effect",
      "linkedSection": "examples",
      "title": "Derivation creates teachable artifacts",
      "content": "When you derive a pattern explicitly, you get documentation for free: the constraint, the principles applied, the primitives chosen, the validation.<br><br>\n          <em>Patterns derived explicitly spread faster than patterns discovered intuitively.</em>"
    },
    {
      "id": "trade-20",
      "type": "tradeoff",
      "linkedSection": "examples",
      "title": "The Worktree Isolation Dilemma",
      "content": "<strong>Full isolation (worktree):</strong> No conflicts, but merge hell later<br>\n          <strong>Partial isolation (branches):</strong> Easier merge, but race conditions<br>\n          <strong>No isolation (same dir):</strong> Simple, but agents step on each other<br><br>\n          <strong>Heuristic:</strong> Match isolation level to dependency between tasks."
    },
    {
      "id": "hor-21",
      "type": "horizon",
      "linkedSection": "examples",
      "title": "How derivation examples age",
      "content": "<strong>Day 1:</strong> \"These examples are cookbook recipes\"<br>\n          <strong>Week 2:</strong> \"I see the pattern in the examples\"<br>\n          <strong>Month 1:</strong> \"I can apply the process to new constraints\"<br>\n          <strong>Month 3:</strong> \"I don't need examples anymore\"<br><br>\n          <em>Examples are scaffolding. Remove them when you can derive independently.</em>"
    },
    {
      "id": "exp-22",
      "type": "expertise",
      "linkedSection": "practice",
      "title": "Practice problem difficulty levels",
      "content": "<strong>P1 (Documentation):</strong> Single principle (P1), straightforward<br>\n          <strong>P2 (Security Audit):</strong> Parallelism + separation (P4, P7)<br>\n          <strong>P3 (Living Spec):</strong> State management tension (P2, P3)<br>\n          <strong>P4 (Cost Optimizer):</strong> Model hierarchy, requires judgment<br>\n          <strong>P5 (Overnight):</strong> Multi-pattern composition, hardest<br><br>\n          <em>Do them in order. Each builds on the last.</em>"
    },
    {
      "id": "inv-23",
      "type": "inversion",
      "linkedSection": "practice",
      "title": "What if you skip practice problems?",
      "content": "<strong>You'd think:</strong> \"I understand the theory, I'll derive when needed.\"<br>\n          <strong>Why this fails:</strong> Derivation is a skill, not knowledge. Skills require practice.<br>\n          <strong>Hidden insight:</strong> Reading about derivation != being able to derive. The gap is practice."
    },
    {
      "id": "vio-24",
      "type": "violation",
      "linkedSection": "practice",
      "title": "If you skip the hints",
      "content": "<strong>IF:</strong> Jump straight to implementation<br>\n          <strong>THEN:</strong> Miss the principle identification step<br>\n          <strong>THEN:</strong> Select wrong primitives<br>\n          <strong>THEN:</strong> Pattern fails validation<br>\n          <strong>FINALLY:</strong> Blame the process instead of the execution<br><br>\n          <em>The hints are the derivation. Don't skip them.</em>"
    },
    {
      "id": "alt-25",
      "type": "alternative",
      "linkedSection": "practice",
      "title": "If practice problems aren't enough",
      "content": "<strong>Want more examples?</strong> - Read mastery-ralph-complete.md, mastery-multi-agent.md<br>\n          <strong>Want composition rules?</strong> - architecture-composition-rules.md<br>\n          <strong>Want to see failures?</strong> - principles-anti-patterns.md<br>\n          <strong>Want the theory?</strong> - principles-core.md"
    },
    {
      "id": "grad-26",
      "type": "gradient",
      "linkedSection": "gotchas",
      "title": "How derivation attempts degrade",
      "content": "<strong>Clean derivation:</strong> Constraint clear, principles identified, primitives minimal<br>\n          <strong>Muddy derivation:</strong> Constraint vague, too many principles \"might apply\"<br>\n          <strong>Failed derivation:</strong> Can't articulate constraint, pattern feels \"clever\"<br>\n          <strong>Inverted derivation:</strong> Started with primitives, backfilled constraint<br><br>\n          <em>If you start with primitives, you're not deriving - you're retrofitting.</em>"
    },
    {
      "id": "war-27",
      "type": "warstory",
      "linkedSection": "gotchas",
      "title": "Over-engineering: The 15-primitive pattern",
      "content": "\"I derived a pattern with loop + Task + worktree + docker + 3 state files + 4 hooks + health checks. It worked! For a week. Then nobody could debug it.\"<br><br>\n          <em>Derivation success != production success. Simplicity wins long-term.</em>"
    },
    {
      "id": "inf-28",
      "type": "inflection",
      "linkedSection": "gotchas",
      "title": "When \"just use existing pattern\" flips",
      "content": "<strong>Adaptation &lt; 20%:</strong> Use existing pattern, tweak<br>\n          <strong>Adaptation 20-50%:</strong> Consider forking pattern<br>\n          <strong>Adaptation 50-70%:</strong> Derive from scratch may be cleaner<br>\n          <strong>Adaptation &gt; 70%:</strong> Definitely derive from scratch<br><br>\n          <strong>THE INFLECTION:</strong> ~50% adaptation<br>\n          <em>Beyond 50%, you're fighting the original pattern more than using it.</em>"
    },
    {
      "id": "comp-29",
      "type": "composition",
      "linkedSection": "gotchas",
      "title": "Derivation + Existing Pattern",
      "content": "<strong>Works:</strong> Derive extension to existing pattern. Ralph + new state file.<br>\n          <strong>Danger:</strong> Loses the \"why\" of original pattern. May break invariants.<br>\n          <strong>Recommendation:</strong> Understand original derivation before extending."
    },
    {
      "id": "inv-30",
      "type": "inversion",
      "linkedSection": "when",
      "title": "What if you always derived from scratch?",
      "content": "<strong>You'd design:</strong> Custom pattern for every project.<br>\n          <strong>Why this fails:</strong> Existing patterns encode community learning. Reinventing wastes that.<br>\n          <strong>Hidden insight:</strong> Derivation is for genuinely novel constraints, not \"I want to be clever.\""
    },
    {
      "id": "trade-31",
      "type": "tradeoff",
      "linkedSection": "when",
      "title": "The Learn vs. Ship Dilemma",
      "content": "<strong>Learn (derive):</strong> Deeper understanding, but slower<br>\n          <strong>Ship (use existing):</strong> Faster now, but hit walls later<br>\n          <strong>Balanced:</strong> Use existing first, derive when walls hit<br><br>\n          <strong>Heuristic:</strong> If you're blocked for &gt;2 hours adapting, start deriving."
    },
    {
      "id": "ana-32",
      "type": "analogy",
      "linkedSection": "when",
      "title": "Derivation = Writing vs. Using Libraries",
      "content": "<strong>Use library:</strong> Existing pattern (Ralph, CC Mirror)<br>\n          <strong>Fork library:</strong> Adapt pattern significantly<br>\n          <strong>Write library:</strong> Derive from scratch<br><br>\n          <em>You don't write stdlib for every project. But you need to know how when stdlib fails.</em>"
    },
    {
      "id": "inv-33",
      "type": "invariant",
      "linkedSection": "when",
      "title": "All patterns share: Constraint + Principles + Primitives",
      "content": "Whether you use Ralph, CC Mirror, Gas Town, or derive something new - the structure is invariant. Constraint identifies the problem. Principles narrow solutions. Primitives implement.<br><br>\n          <em>Understanding this structure is more valuable than knowing any single pattern.</em>"
    },
    {
      "id": "alt-34",
      "type": "alternative",
      "linkedSection": "when",
      "title": "If derivation guide isn't what you need",
      "content": "<strong>Need ready patterns?</strong> - mastery-ralph-complete.md, mastery-multi-agent.md<br>\n          <strong>Need decision support?</strong> - JUDGMENT-GUIDE.md<br>\n          <strong>Need anti-patterns?</strong> - principles-anti-patterns.md<br>\n          <strong>Need complexity ladder?</strong> - architecture-complexity-ladder.md"
    }
  ]
}