{
  "items": [
    {
      "id": "min-1",
      "type": "minimal",
      "linkedSection": "essence",
      "title": "The irreducible primitive set",
      "content": "<code style=\"background: #f4f4f5; padding: 2px 6px; border-radius: 4px; font-size: 12px;\">Loop + State + Control</code><br>\n          <strong>Essential:</strong> Something iterates, something persists, something stops it.<br>\n          <strong>Everything else:</strong> Reliability, safety, efficiency."
    },
    {
      "id": "ana-2",
      "type": "analogy",
      "linkedSection": "essence",
      "title": "Primitives = LEGO Bricks",
      "content": "<strong>Individual bricks:</strong> Simple, limited alone<br>\n          <strong>Combinations:</strong> Complex structures emerge<br>\n          <strong>Standard interfaces:</strong> Any brick connects to any other<br>\n          <strong>Instruction manuals:</strong> Composition patterns like Ralph<br><br>\n          <em>If you understand LEGO, you understand primitives.</em>"
    },
    {
      "id": "inv-3",
      "type": "invariant",
      "linkedSection": "essence",
      "title": "All patterns share INV-003: External state > internal memory",
      "content": "Ralph, Gas Town, CC Mirror, Panopticon - all use external state files, not LLM memory. The primitive is universal because the constraint (context rot) is universal."
    },
    {
      "id": "con-4",
      "type": "constraint",
      "linkedSection": "core",
      "title": "One constraint produces the primitive taxonomy",
      "content": "<strong>ROOT:</strong> LLM context degrades with tokens<br>\n          -&gt; Fresh iterations needed (Loop primitives)<br>\n          -&gt; State must persist externally (State primitives)<br>\n          -&gt; Need to know when done (Control primitives)<br>\n          -&gt; Must verify before marking done (Quality primitives)<br>\n          -&gt; Multi-agent needs coordination (Coordination primitives)<br>\n          -&gt; Learning must cross iterations (Memory primitives)<br>\n          -&gt; Automation needs interception (Hook primitives)"
    },
    {
      "id": "inv-5",
      "type": "inversion",
      "linkedSection": "core",
      "title": "What if you didn't need primitives?",
      "content": "<strong>You'd design:</strong> One perfect pattern for all use cases<br>\n          <strong>Why this fails:</strong> Different constraints (overnight vs real-time, single vs multi-agent, local vs cloud) require different compositions<br>\n          <strong>Hidden constraint:</strong> Variety of use cases forces composability"
    },
    {
      "id": "exp-6",
      "type": "expertise",
      "linkedSection": "core",
      "title": "How deeply do you understand primitives?",
      "content": "<strong>Beginner:</strong> \"What's a primitive?\" -&gt; Reusable building block<br>\n          <strong>Intermediate:</strong> \"Why these 7 categories?\" -&gt; Cover all concerns<br>\n          <strong>Advanced:</strong> \"Are these complete?\" -&gt; No, but sufficient<br>\n          <strong>Staff:</strong> \"When would I create new primitives?\" -&gt; Novel constraints<br>\n          <strong>Expert:</strong> \"Cross-primitive interactions?\" -&gt; State + Loop timing"
    },
    {
      "id": "eff-7",
      "type": "effect",
      "linkedSection": "primitives",
      "title": "At 50+ iterations, loop primitive matters less than state primitive",
      "content": "<strong>Early:</strong> Loop determines speed<br>\n          <strong>Late:</strong> State size determines quality<br>\n          <strong>Threshold:</strong> ~20KB progress.txt<br><br>\n          <em>Optimize for state management, not loop speed.</em>"
    },
    {
      "id": "grad-8",
      "type": "gradient",
      "linkedSection": "primitives",
      "title": "How primitives fail gradually",
      "content": "<strong>Loop:</strong> Runs too long -&gt; costs spike<br>\n          <strong>State:</strong> Gets corrupted -&gt; silent wrong answers<br>\n          <strong>Control:</strong> Signal missed -&gt; infinite loop<br>\n          <strong>Quality:</strong> Gate skipped -&gt; tech debt compounds<br><br>\n          <em>State failures are most dangerous: invisible until cascade.</em>"
    },
    {
      "id": "trade-9",
      "type": "tradeoff",
      "linkedSection": "primitives",
      "title": "JSON State vs. Filesystem State",
      "content": "<strong>JSON (prd.json):</strong> Atomic, queryable, but complex schema<br>\n          <strong>Filesystem (Panopticon):</strong> Simple, isolated, but no queries<br>\n          <strong>Git:</strong> History + diff, but not queryable mid-run<br><br>\n          <em>Heuristic: JSON for task tracking, filesystem for domain isolation, git for code.</em>"
    },
    {
      "id": "comp-10",
      "type": "composition",
      "linkedSection": "primitives",
      "title": "Loop + Quality Gate interaction",
      "content": "<strong>Works:</strong> Quality gate BEFORE marking done prevents bad commits<br>\n          <strong>Danger:</strong> Quality gate AFTER marking done = tech debt in git<br>\n          <strong>Order matters:</strong> test -&gt; pass -&gt; mark done -&gt; commit"
    },
    {
      "id": "war-11",
      "type": "warstory",
      "linkedSection": "primitives",
      "title": "Matt Pocock: The skipped typecheck",
      "content": "\"If you don't do this, you're hamstringing future agent runs with bad code, and they'll need to bisect to find bugs.\"<br><br>\n          One iteration without typecheck -&gt; 10 iterations debugging type errors."
    },
    {
      "id": "vio-12",
      "type": "violation",
      "linkedSection": "primitives",
      "title": "If you use > instead of >> for progress.txt",
      "content": "<strong>IF:</strong> You overwrite instead of append<br>\n          <strong>THEN:</strong> Previous learnings are lost<br>\n          <strong>THEN:</strong> Next iteration repeats solved problems<br>\n          <strong>THEN:</strong> No velocity improvement over time<br>\n          <strong>FINALLY:</strong> Iteration 50 is as slow as iteration 1<br><br>\n          <em>The fix: Always &gt;&gt; for progress.txt. Never &gt;.</em>"
    },
    {
      "id": "hor-13",
      "type": "horizon",
      "linkedSection": "primitives",
      "title": "How primitive value changes over time",
      "content": "<strong>Iteration 1:</strong> \"Loop primitive is core\"<br>\n          <strong>Iteration 10:</strong> \"State primitive is what matters\"<br>\n          <strong>Iteration 30:</strong> \"Memory primitive is why this works\"<br>\n          <strong>Iteration 50:</strong> \"Quality primitive is what keeps it working\"<br><br>\n          <em>What matters shifts as iteration count grows.</em>"
    },
    {
      "id": "ana-14",
      "type": "analogy",
      "linkedSection": "composition",
      "title": "Pattern Composition = Music Composition",
      "content": "<strong>Primitives:</strong> Notes (C, D, E...)<br>\n          <strong>Patterns:</strong> Melodies (Ralph, Gas Town...)<br>\n          <strong>Composition rules:</strong> Music theory<br>\n          <strong>Dissonance:</strong> Incompatible primitives<br><br>\n          <em>You can make new music once you know the notes.</em>"
    },
    {
      "id": "inv-15",
      "type": "invariant",
      "linkedSection": "composition",
      "title": "Ralph and Gas Town share 4 primitive categories",
      "content": "Both use: Loop, State, Quality, Memory<br>\n          Differ in: Coordination (single vs factory), Control (promise vs role-based)<br><br>\n          <em>Understanding shared primitives lets you predict behavior.</em>"
    },
    {
      "id": "comp-16",
      "type": "composition",
      "linkedSection": "composition",
      "title": "Can Ralph primitives compose with CC Mirror primitives?",
      "content": "<strong>Works:</strong> Ralph Loop + CC Mirror TaskCreate = \"Ralph spawns workers\"<br>\n          <strong>Danger:</strong> Two coordination models compete. Workers might use Ralph's single-agent assumptions.<br>\n          <strong>Recommendation:</strong> Keep Ralph for orchestrator, CC Mirror for workers."
    },
    {
      "id": "exp-17",
      "type": "expertise",
      "linkedSection": "composition",
      "title": "Composition understanding depth",
      "content": "<strong>Beginner:</strong> \"Copy whole Ralph\" -&gt; Works<br>\n          <strong>Intermediate:</strong> \"Swap prd.json format\" -&gt; OK if schema matches<br>\n          <strong>Advanced:</strong> \"Add hooks to Ralph\" -&gt; Powerful<br>\n          <strong>Staff:</strong> \"Mix Ralph loop + Gas Town memory\" -&gt; Experimental<br>\n          <strong>Expert:</strong> \"When does composition fail?\" -&gt; State timing conflicts"
    },
    {
      "id": "fron-18",
      "type": "frontier",
      "linkedSection": "composition",
      "title": "UNSOLVED: Automatic composition validation",
      "content": "<strong>The question:</strong> Can we automatically detect incompatible primitive combinations?<br>\n          <strong>Why it's hard:</strong> Interactions are emergent, not obvious from primitives alone<br>\n          <strong>Current practice:</strong> Manual testing, community knowledge, trial and error"
    },
    {
      "id": "con-19",
      "type": "constraint",
      "linkedSection": "path",
      "title": "Selection order is forced",
      "content": "<strong>ROOT:</strong> Must iterate to use fresh context<br>\n          -&gt; Loop must come first<br>\n          -&gt; State follows (what persists between loops)<br>\n          -&gt; Control follows (when to stop looping)<br>\n          -&gt; Quality follows (what must pass)<br>\n          -&gt; Coordination follows (if multi-agent)<br>\n          -&gt; Memory follows (cross-run learning)<br>\n          -&gt; Hooks follow (automation on top)<br><br>\n          <em>Selection order mirrors dependency order.</em>"
    },
    {
      "id": "vio-20",
      "type": "violation",
      "linkedSection": "path",
      "title": "If you add hooks before testing primitives",
      "content": "<strong>IF:</strong> Add hooks before basic primitives work<br>\n          <strong>THEN:</strong> Hooks mask primitive failures<br>\n          <strong>THEN:</strong> You debug hooks when problem is in loop<br>\n          <strong>THEN:</strong> Hours wasted on wrong layer<br>\n          <strong>FINALLY:</strong> Frustration and confusion<br><br>\n          <em>The fix: Bottom-up. Test primitives before adding hooks.</em>"
    },
    {
      "id": "inf-21",
      "type": "inflection",
      "linkedSection": "gotchas",
      "title": "When prd.json complexity flips from help to hurt",
      "content": "<strong>1-5 tasks:</strong> Simple is fine<br>\n          <strong>5-15 tasks:</strong> Schema helps<br>\n          <strong>15-30 tasks:</strong> Dependencies needed<br>\n          <strong>30+ tasks:</strong> Native TaskCreate better<br><br>\n          <strong>THE INFLECTION:</strong> ~30 tasks<br>\n          <em>Detection: JSON gets unwieldy to edit manually.</em>"
    },
    {
      "id": "inv-22",
      "type": "inversion",
      "linkedSection": "gotchas",
      "title": "What if primitives never broke?",
      "content": "<strong>You'd design:</strong> No error handling, no logging, no backups<br>\n          <strong>Why this fails:</strong> Files corrupt, networks fail, LLMs hallucinate<br>\n          <strong>Hidden constraint:</strong> Distributed systems are unreliable. Primitives inherit that unreliability."
    },
    {
      "id": "war-23",
      "type": "warstory",
      "linkedSection": "gotchas",
      "title": "Community pattern: jq validation before each iteration",
      "content": "After multiple corrupted prd.json incidents, community standard emerged: <code>jq . prd.json &gt; /dev/null</code> at loop start. If it fails, stop and alert."
    },
    {
      "id": "grad-24",
      "type": "gradient",
      "linkedSection": "gotchas",
      "title": "How hook misconfiguration degrades",
      "content": "<strong>100%:</strong> Hook fires correctly<br>\n          <strong>80%:</strong> Hook fires but wrong event (subtle bugs)<br>\n          <strong>50%:</strong> Hook doesn't fire (silent failure)<br>\n          <strong>20%:</strong> Hook blocks operations incorrectly (system halt)<br>\n          <strong>0%:</strong> Hook corrupts state (data loss)<br><br>\n          <em>Critical: Silent non-firing is common. Add logging to every hook.</em>"
    },
    {
      "id": "trade-25",
      "type": "tradeoff",
      "linkedSection": "hard",
      "title": "Granularity Dilemma",
      "content": "<strong>THE DILEMMA:</strong><br>\n          - Fine-grained: Maximum flexibility, overwhelming complexity<br>\n          - Coarse-grained: Easy to use, can't customize<br>\n          - Current taxonomy: Middle ground, not perfect for all<br><br>\n          <strong>WHY NO PERFECT ANSWER:</strong> Different users need different granularities<br>\n          <em>Heuristic: Start coarse, decompose when forced.</em>"
    },
    {
      "id": "hor-26",
      "type": "horizon",
      "linkedSection": "hard",
      "title": "How debugging difficulty changes",
      "content": "<strong>Day 1:</strong> \"Easy to see which primitive failed\"<br>\n          <strong>Week 1:</strong> \"Interactions are getting complex\"<br>\n          <strong>Month 1:</strong> \"Hard to reproduce bugs\"<br>\n          <strong>Month 3:</strong> \"Composition is the bottleneck, not primitives\"<br><br>\n          <em>Long-term: Add observability early. You'll need it.</em>"
    },
    {
      "id": "fron-27",
      "type": "frontier",
      "linkedSection": "hard",
      "title": "UNSOLVED: Primitive versioning",
      "content": "<strong>The question:</strong> How do you upgrade primitives without breaking existing compositions?<br>\n          <strong>Why it's hard:</strong> Compositions depend on specific primitive behavior<br>\n          <strong>Current practice:</strong> Copy primitives into project, don't upgrade"
    },
    {
      "id": "alt-28",
      "type": "alternative",
      "linkedSection": "when",
      "title": "If primitives aren't right for you",
      "content": "<strong>Just want to ship?</strong> -&gt; Copy Ralph whole<br>\n          <strong>Need multi-agent now?</strong> -&gt; Use CC Mirror as-is<br>\n          <strong>Learning?</strong> -&gt; Start with mastery-ralph-complete.md<br>\n          <strong>Enterprise?</strong> -&gt; Adopt Gas Town framework"
    },
    {
      "id": "inv-29",
      "type": "inversion",
      "linkedSection": "when",
      "title": "What if everyone designed from primitives?",
      "content": "<strong>You'd have:</strong> Many incompatible custom patterns<br>\n          <strong>Why this fails:</strong> Team consistency requires shared patterns<br>\n          <strong>Hidden constraint:</strong> Primitives are for architects, patterns are for teams"
    },
    {
      "id": "ana-30",
      "type": "analogy",
      "linkedSection": "when",
      "title": "Primitives = Assembly Language",
      "content": "<strong>Assembly:</strong> Maximum control, maximum complexity<br>\n          <strong>High-level patterns:</strong> Less control, much easier<br>\n          <strong>When assembly?:</strong> Performance critical, debugging, understanding<br>\n          <strong>When patterns?:</strong> Most of the time<br><br>\n          <em>Know assembly exists. Use high-level 95% of the time.</em>"
    },
    {
      "id": "war-31",
      "type": "warstory",
      "linkedSection": "when",
      "title": "Team that went too deep too fast",
      "content": "Started with primitives instead of copying Ralph. Spent 2 weeks designing custom composition. Finally realized Ralph would have worked. Lesson: Start with patterns, decompose to primitives only when forced."
    },
    {
      "id": "exp-32",
      "type": "expertise",
      "linkedSection": "when",
      "title": "When to use primitives vs patterns",
      "content": "<strong>Beginner:</strong> Always use patterns (Ralph, CC Mirror)<br>\n          <strong>Intermediate:</strong> Customize patterns slightly<br>\n          <strong>Advanced:</strong> Swap individual primitives<br>\n          <strong>Staff:</strong> Design new compositions<br>\n          <strong>Expert:</strong> Create new primitives when needed"
    }
  ]
}