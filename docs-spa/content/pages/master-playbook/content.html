

      <!-- Section 1: ESSENCE -->
      <section id="essence" data-activity="essence">
        <div class="essence-box">
          <div class="essence-label">Essence (15 words)</div>
          <div class="essence-text">The complete progression from single sessions to factory-scale autonomous development, with judgment for each level.</div>
        </div>

        <p class="text-text-secondary mb-6">
          This is the master entry point for learning Claude Code orchestration. If you're overwhelmed by options, context problems, or don't know which pattern to use - start here. This playbook provides the complete progression from Level 0 (single sessions) to Level 7 (factory-scale autonomous development), with clear milestones and judgment criteria at each stage.
        </p>
      </section>

      <!-- Section 2: CORE ABSTRACTION + IMPLEMENTATION -->
      <section id="core-abstraction" data-activity="core">
        <h2 class="section-title">
          <span class="section-number">2</span>
          The Core Abstraction
        </h2>

        <div class="core-abstraction">
          <div class="core-philosophy">"Everything builds on 8 principles. Understand them, and you can derive any pattern."</div>

          <div class="core-code">
            <button class="copy-btn" onclick="copyCode(this, 'Context is finite. External state persists. Fresh beats extended. Orchestrators coordinate, workers execute.')">
              <i data-lucide="copy" class="w-3 h-3"></i>
              Copy
            </button>
            <code>Context is finite. External state persists. Fresh beats extended. Orchestrators coordinate, workers execute.</code>
          </div>

          <div class="core-anchor">These 4 constraints generate all 8 principles and every pattern in this playbook.</div>
        </div>

        <h3 class="font-semibold text-lg mb-4">The 8 Core Principles</h3>

        <div class="principle-box">
          <div class="principle-number">Principle 1</div>
          <div class="principle-title">Context Is The Primary Constraint</div>
          <div class="principle-content">
            Claude's context window is finite (~200K tokens). Quality degrades as context fills (observable at 60-70%). Long sessions accumulate noise, contradictions, and cruft. Token costs scale linearly with context size. <strong>Every pattern in this playbook ultimately optimizes around context limits.</strong>
          </div>
        </div>

        <div class="principle-box">
          <div class="principle-number">Principle 2</div>
          <div class="principle-title">External State &gt; Internal Memory</div>
          <div class="principle-content">
            Claude's "memory" lives only in the context window. When the session ends, everything is lost. <strong>Store state in files (prd.json, progress.txt), in git (commits as memory), and in external tools.</strong> External state survives session death and doesn't consume context tokens.
          </div>
        </div>

        <div class="principle-box">
          <div class="principle-number">Principle 3</div>
          <div class="principle-title">Fresh Context &gt; Extended Sessions</div>
          <div class="principle-content">
            Long sessions degrade in quality. Context becomes polluted with false starts, corrections, tangents. There's no mechanism to "forget" irrelevant information. <strong>Quality of 20 five-minute sessions &gt; Quality of one 100-minute session.</strong>
          </div>
        </div>

        <div class="principle-box">
          <div class="principle-number">Principle 4</div>
          <div class="principle-title">Orchestrator/Worker Separation (The Iron Law)</div>
          <div class="principle-content">
            <strong>Orchestrators coordinate. Workers execute. Never mix.</strong> Orchestrators create and assign tasks, monitor progress, make decisions - but NEVER write code. Workers receive specific tasks, execute them, and report results - but NEVER spawn other workers. This prevents infinite recursion and keeps orchestrator context lean.
          </div>
        </div>

        <div class="principle-box">
          <div class="principle-number">Principle 5</div>
          <div class="principle-title">Atomic, Verifiable Tasks</div>
          <div class="principle-content">
            "Build the auth system" is too big. "Make it work better" can't be verified. <strong>Break into smallest testable units. Each task fits in one context window. Each has explicit acceptance criteria.</strong> Verification is automated (typecheck, test, screenshot).
          </div>
        </div>

        <div class="principle-box">
          <div class="principle-number">Principle 6</div>
          <div class="principle-title">Quality Gates Before Commit</div>
          <div class="principle-content">
            Never mark work as "done" without verification. Broken code compounds (one bug becomes many). Early failures save rework. <strong>Always: npm run typecheck &amp;&amp; npm run test &amp;&amp; npm run lint &amp;&amp; git commit</strong>
          </div>
        </div>

        <div class="principle-box">
          <div class="principle-number">Principle 7</div>
          <div class="principle-title">Isolation For Parallel Work</div>
          <div class="principle-content">
            Multiple agents editing the same files = merge conflicts. Shared state = race conditions. <strong>Use git worktrees for file isolation, separate branches per feature, domain-specific Claude instances.</strong>
          </div>
        </div>

        <div class="principle-box">
          <div class="principle-number">Principle 8</div>
          <div class="principle-title">Explicit Communication Channels</div>
          <div class="principle-content">
            Agents can't read minds. Assumptions lead to wrong work. <strong>Use progress files agents can read, structured task definitions (JSON), clear acceptance criteria, and hooks for notifications.</strong>
          </div>
        </div>
      </section>

      <!-- Section 3: DESIGN DECISIONS -->
      <section id="why-progression" data-activity="decisions">
        <h2 class="section-title">
          <span class="section-number">3</span>
          Design Decisions
        </h2>

        <div class="decision-box">
          <div class="decision-why">WHY LEVELS (0-7)?</div>
          <div class="decision-reasoning">
            Capability progression isn't smooth - it's stepped. Each level requires mastering the previous one's patterns before the next becomes useful. Jumping levels leads to failure because you don't have the mental models. Level 5 patterns fail if you haven't internalized Level 3 context discipline.
          </div>
          <div class="decision-implication">
            <div class="decision-implication-label">What this means for you</div>
            <div class="text-text-secondary text-sm">
              Identify your current level. Focus on the level JUST above where you are. Don't skip levels. If Level 5 fails, go back to Level 3 and verify you've truly mastered it.
            </div>
          </div>
        </div>

        <div class="decision-box" id="why-principles">
          <div class="decision-why">WHY PRINCIPLES FIRST?</div>
          <div class="decision-reasoning">
            Patterns are implementations of principles. If you memorize patterns without understanding principles, you can't adapt when your constraints differ. Understanding "why fresh context" lets you derive Ralph yourself. Understanding "why orchestrator separation" lets you design any multi-agent system.
          </div>
          <div class="decision-implication">
            <div class="decision-implication-label">What this means for you</div>
            <div class="text-text-secondary text-sm">
              Read Part 1 (Foundations) before jumping to specific patterns. When a pattern doesn't work, trace back to which principle you're violating. Principles are stable; patterns evolve.
            </div>
          </div>
        </div>

        <div class="decision-box" id="why-transformations">
          <div class="decision-why">WHY BEFORE/AFTER TRANSFORMATIONS?</div>
          <div class="decision-reasoning">
            Reading about patterns is abstract. Seeing the same task done both ways makes the value concrete. You need to feel the pain of the "before" to appreciate the "after." Without that contrast, you might think the pattern is unnecessary complexity.
          </div>
          <div class="decision-implication">
            <div class="decision-implication-label">What this means for you</div>
            <div class="text-text-secondary text-sm">
              Part 4 shows transformations for each major pattern. Read these when you're skeptical. Try the "before" approach first if needed - you'll understand why the pattern exists when it fails.
            </div>
          </div>
        </div>
      </section>

      <!-- Section 4: FILE STRUCTURE / CAPABILITY LEVELS -->
      <section id="level-0" data-activity="files">
        <h2 class="section-title">
          <span class="section-number">4</span>
          Capability Levels
        </h2>

        <h3 class="font-semibold text-lg mb-4 flex items-center">
          <span class="level-badge level-0">L0</span>
          Single Session (Where Most Start)
        </h3>

        <p class="text-text-secondary mb-4">
          All work happens in one continuous conversation. Manual approval for every operation. Context degrades after 60% fill. 90 minutes leads to session death or burnout.
        </p>

        <div class="code-block">
          <pre><span class="comment"># Level 0: The pain you know</span>
11:00 PM - Start session, explain project
11:15 PM - Ask for login form, approve changes
11:30 PM - Ask for validation, approve
11:45 PM - Context at 55%, Claude getting confused
12:00 AM - Claude repeats earlier mistakes
12:15 AM - Context at 75%, quality noticeably worse
12:30 AM - Give up, feature incomplete</pre>
        </div>

        <h3 class="font-semibold text-lg mb-4 mt-8 flex items-center" id="level-3">
          <span class="level-badge level-3">L3</span>
          Ralph Loop (Autonomy Begins)
        </h3>

        <p class="text-text-secondary mb-4">
          Fresh context per iteration. External state (prd.json, progress.txt). You write the PRD, then sleep. Wake up to completed feature.
        </p>

        <div class="code-block">
          <button class="copy-btn" onclick="copyCodeBlock(this)">
            <i data-lucide="copy" class="w-3 h-3"></i>
            Copy
          </button>
          <pre><span class="comment">#!/bin/bash - ralph.sh</span>
<span class="variable">MAX_ITERATIONS</span>=<span class="variable">${1:-25}</span>

<span class="keyword">for</span> i <span class="keyword">in</span> $(seq 1 $MAX_ITERATIONS); <span class="keyword">do</span>
  <span class="keyword">echo</span> <span class="string">"=== Iteration $i ==="</span>
  OUTPUT=$(cat prompt.md | claude --dangerously-skip-permissions 2&gt;&amp;1)

  <span class="keyword">if</span> <span class="keyword">echo</span> "$OUTPUT" | grep -q <span class="string">"&lt;promise&gt;COMPLETE&lt;/promise&gt;"</span>; <span class="keyword">then</span>
    <span class="keyword">exit</span> 0
  <span class="keyword">fi</span>
  sleep 2
<span class="keyword">done</span></pre>
        </div>

        <h3 class="font-semibold text-lg mb-4 mt-8 flex items-center" id="level-5">
          <span class="level-badge level-5">L5</span>
          CC Mirror (Multi-Agent)
        </h3>

        <p class="text-text-secondary mb-4">
          Hub-and-spoke orchestration. Opus orchestrator coordinates Sonnet/Haiku workers. Parallel execution. Model tiering for cost optimization.
        </p>

        <div class="code-block">
          <pre><span class="comment"># Orchestrator creates tasks, never writes code</span>
TaskCreate(
  subject: <span class="string">"Implement user registration"</span>,
  description: <span class="string">"Create POST /api/auth/register"</span>,
  acceptanceCriteria: [<span class="string">"Validates email"</span>, <span class="string">"Hashes password"</span>],
  model: <span class="string">"Sonnet"</span>
)

<span class="comment"># Workers execute, report back, never spawn</span></pre>
        </div>

        <h3 class="font-semibold text-lg mb-4 mt-8 flex items-center" id="level-7">
          <span class="level-badge level-7">L7</span>
          Gas Town (Factory Scale)
        </h3>

        <p class="text-text-secondary mb-4">
          Persistent workers with memory. Self-improving systems. Automatic decomposition. Team equivalent: 3-5 mid-level developers. Prerequisites: 100+ hours multi-agent experience, $50-200/day budget tolerance.
        </p>

        <div class="code-block">
          <pre><span class="comment"># Gas Town Architecture</span>
Gas Town Factory
├─ HQ (Management)
│  ├─ Mayor (coordination)
│  ├─ Deacon (monitoring)
│  └─ Dogs (quality gates)
├─ Refinery (auto-decomposition)
└─ Rigs (projects)
   ├─ Witness (observer)
   ├─ Polecats (persistent workers)
   └─ Crew (ephemeral workers)</pre>
        </div>
      </section>

      <!-- Section 5: PATH OF A TASK / PROGRESSION -->
      <section id="path" data-activity="path">
        <h2 class="section-title">
          <span class="section-number">5</span>
          The Progression Path
        </h2>

        <p class="text-text-secondary mb-6">
          Your journey through capability levels, with time investment and expected outcomes:
        </p>

        <table class="progression-table">
          <thead>
            <tr>
              <th>Level</th>
              <th>Pattern</th>
              <th>Human Time</th>
              <th>Token Efficiency</th>
              <th>Time to Master</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><span class="level-badge level-0">L0</span></td>
              <td>Single Session</td>
              <td>90 min</td>
              <td>Low</td>
              <td>Day 1</td>
            </tr>
            <tr>
              <td><span class="level-badge level-1">L1</span></td>
              <td>CLAUDE.md + Commands</td>
              <td>60 min</td>
              <td>+20%</td>
              <td>Week 1</td>
            </tr>
            <tr>
              <td><span class="level-badge level-2">L2</span></td>
              <td>Subagents + Hooks</td>
              <td>45 min</td>
              <td>+30%</td>
              <td>Week 2</td>
            </tr>
            <tr>
              <td><span class="level-badge level-3">L3</span></td>
              <td>Ralph Loop</td>
              <td>10 min</td>
              <td>+50%</td>
              <td>Week 3-4</td>
            </tr>
            <tr>
              <td><span class="level-badge level-4">L4</span></td>
              <td>PRD-driven Reliability</td>
              <td>20 min</td>
              <td>+60%</td>
              <td>Month 1</td>
            </tr>
            <tr>
              <td><span class="level-badge level-5">L5</span></td>
              <td>CC Mirror</td>
              <td>30 min</td>
              <td>+40%</td>
              <td>Month 2</td>
            </tr>
            <tr>
              <td><span class="level-badge level-6">L6</span></td>
              <td>Parallel Worktrees</td>
              <td>15 min</td>
              <td>+70%</td>
              <td>Month 3</td>
            </tr>
            <tr>
              <td><span class="level-badge level-7">L7</span></td>
              <td>Gas Town Factory</td>
              <td>Minimal</td>
              <td>Variable</td>
              <td>Month 6+</td>
            </tr>
          </tbody>
        </table>

        <div class="path-container">
          <div class="path-step">
            <div class="path-number">1</div>
            <div class="path-content"><strong>Level 0 → 1:</strong> Create CLAUDE.md in project root. Add 3-5 slash commands. Break-even: 3-4 sessions. Investment: 30-45 minutes.</div>
          </div>
          <div class="path-step">
            <div class="path-number">2</div>
            <div class="path-content"><strong>Level 1 → 2:</strong> Create specialized subagents (security-reviewer, test-writer). Add formatting hooks. Investment: 2-4 hours.</div>
          </div>
          <div class="path-step">
            <div class="path-number">3</div>
            <div class="path-content"><strong>Level 2 → 3:</strong> Set up Ralph loop with prd.json and progress.txt. First overnight run. Investment: 1-2 hours setup + 15-20 min per feature PRD.</div>
          </div>
          <div class="path-step">
            <div class="path-number">4</div>
            <div class="path-content"><strong>Level 3 → 4:</strong> Add explicit acceptance criteria. Implement learning accumulation. Success rate: 60% → 95%.</div>
          </div>
          <div class="path-step">
            <div class="path-number">5</div>
            <div class="path-content"><strong>Level 4 → 5:</strong> Add CC Mirror orchestration. Implement model tiering (Opus orchestrator, Sonnet/Haiku workers). Parallel task execution.</div>
          </div>
          <div class="path-step">
            <div class="path-number">6</div>
            <div class="path-content"><strong>Level 5 → 6:</strong> Add git worktrees for true isolation. Run parallel Ralph loops. 3 features simultaneously = 1 hour instead of 3.</div>
          </div>
          <div class="path-step">
            <div class="path-number">7</div>
            <div class="path-content"><strong>Level 6 → 7:</strong> Implement Gas Town factory. Persistent workers. Automatic decomposition. Prerequisites: 100+ hours multi-agent experience.</div>
          </div>
        </div>
      </section>

      <!-- Section 6: GOTCHAS -->
      <section id="gotchas" data-activity="gotchas">
        <h2 class="section-title">
          <span class="section-number">6</span>
          Gotchas
        </h2>

        <p class="text-text-secondary mb-6">
          Common mistakes at each level, with concrete signals and fixes:
        </p>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Skipping Levels
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Level 5 patterns fail unexpectedly. Multi-agent chaos.</div>
          <div class="gotcha-detail"><strong>Why:</strong> You haven't internalized Level 3 context discipline. Workers inherit bad habits.</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Go back to Level 3. Run 10 successful Ralph iterations. Verify progress.txt hygiene. Then retry Level 5.</div>
        </div>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Orchestrators That Write Code
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Orchestrator context fills with implementation details. Loses coordination ability.</div>
          <div class="gotcha-detail"><strong>Why:</strong> Violated the Iron Law. Orchestrators must NEVER execute, only coordinate.</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Strict tool restriction. Orchestrator gets only TaskCreate/TaskUpdate/TaskGet + Read (1-2 files max). No Write, Edit, or Bash.</div>
        </div>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Workers Spawning Workers
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Infinite recursion. Costs spiral. Control lost.</div>
          <div class="gotcha-detail"><strong>Why:</strong> Violated the Iron Law from the worker side. Workers must NEVER spawn.</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Workers report back to orchestrator. Only orchestrator spawns. Add explicit "You must NOT spawn subagents" to worker prompts.</div>
        </div>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            $47,000 Problem (Runaway Costs)
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Agent keeps running, costs escalating, no completion in sight.</div>
          <div class="gotcha-detail"><strong>Why:</strong> Missing iteration limits, recursive loops, or missing stop conditions.</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Always set MAX_ITERATIONS. Add cost monitoring hooks. Set up ntfy/push notifications for long runs. Add cost cap check to ralph.sh.</div>
        </div>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Pattern-Shopping Without Principles
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Trying different patterns randomly. Nothing works consistently.</div>
          <div class="gotcha-detail"><strong>Why:</strong> Patterns without principles are recipes without understanding. Can't adapt.</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Return to Part 1. Understand WHY each principle exists. Then patterns become derivable.</div>
        </div>
      </section>

      <!-- Section 7: WHAT'S HARD -->
      <section id="hard" data-activity="hard">
        <h2 class="section-title">
          <span class="section-number">7</span>
          What's Hard
        </h2>

        <p class="text-text-secondary mb-6">
          Fundamental tensions in Claude Code orchestration that can't be fully solved:
        </p>

        <div class="hard-box">
          <div class="hard-title">
            <i data-lucide="flame" class="w-4 h-4"></i>
            Context Rot vs. Memory Loss
          </div>
          <div class="hard-detail"><strong>The tension:</strong> Fresh context avoids rot but loses learnings. progress.txt helps but grows unbounded. No perfect solution exists.</div>
          <div class="hard-detail"><strong>Symptoms:</strong> Quality drops in late iterations (rot), OR early iterations repeat mistakes from archived runs (memory loss).</div>
          <div class="hard-detail"><strong>Mitigation:</strong> Keep progress.txt under 20KB. Start fresh runs from AGENTS.md (permanent), not progress.txt (session). Accept some re-learning as the cost of fresh context.</div>
        </div>

        <div class="hard-box">
          <div class="hard-title">
            <i data-lucide="flame" class="w-4 h-4"></i>
            Judgment Transfer
          </div>
          <div class="hard-detail"><strong>The tension:</strong> This playbook teaches patterns, but choosing between them requires judgment. Judgment only develops through experience. You can't read your way to wisdom.</div>
          <div class="hard-detail"><strong>Symptoms:</strong> Picking wrong patterns for the situation. Overcomplicating simple tasks. Oversimplifying complex ones.</div>
          <div class="hard-detail"><strong>Mitigation:</strong> Start with JUDGMENT-GUIDE.md decision trees. But expect to be wrong. Review each failure: "Which principle did I violate?" Build pattern recognition through iteration.</div>
        </div>

        <div class="hard-box">
          <div class="hard-title">
            <i data-lucide="flame" class="w-4 h-4"></i>
            Cost vs. Quality vs. Speed
          </div>
          <div class="hard-detail"><strong>The tension:</strong> Opus is best but expensive. Sonnet balances. Haiku is cheap but limited. More agents = more parallel but more coordination overhead. Faster iteration = less verification = more bugs.</div>
          <div class="hard-detail"><strong>Symptoms:</strong> Budget anxiety. Quality variance. Unexpected slow-downs from "efficient" choices.</div>
          <div class="hard-detail"><strong>Mitigation:</strong> Tier by task type (Haiku lookups, Sonnet coding, Opus architecture). Verify before commit always. Measure actual costs per feature, not per token.</div>
        </div>

        <div class="hard-box">
          <div class="hard-title">
            <i data-lucide="flame" class="w-4 h-4"></i>
            Determinism vs. Emergence
          </div>
          <div class="hard-detail"><strong>The tension:</strong> You want predictable outcomes. But LLMs are probabilistic. Multi-agent systems compound variance. The "same" run produces different results.</div>
          <div class="hard-detail"><strong>Symptoms:</strong> Flaky tests of agent behavior. "It worked yesterday." Different outcomes on retry.</div>
          <div class="hard-detail"><strong>Mitigation:</strong> Verify outcomes, not processes. Accept that paths vary but destinations should match. Build tolerance for emergence at Level 6+.</div>
        </div>
      </section>

      <!-- Section 8: WHEN TO USE -->
      <section id="when" data-activity="when">
        <h2 class="section-title">
          <span class="section-number">8</span>
          Pattern Selection
        </h2>

        <h3 class="font-semibold text-lg mb-4">Which Pattern For This Task?</h3>

        <div class="code-block">
          <pre><span class="comment"># Decision Tree: Architecture Selection</span>

Is task well-defined with clear acceptance criteria?
├─ No → Stay interactive (Level 0-2), clarify first
└─ Yes → Can it complete in one context window?
         ├─ Yes → Single Ralph iteration (Level 3)
         └─ No → How many parallel features?
                 ├─ 1 feature → Ralph Loop (Level 3-4)
                 ├─ 2-3 features → Parallel Ralph + Worktrees (Level 6)
                 ├─ 3-8 agents → CC Mirror (Level 5)
                 └─ 10+ agents → Gas Town Factory (Level 7)</pre>
        </div>

        <div class="when-grid">
          <div class="when-use">
            <div class="when-title">
              <i data-lucide="check" class="w-5 h-5"></i>
              USE THIS PLAYBOOK WHEN
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>You're overwhelmed by Claude Code options and need a structured progression</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>Your current approach hits context limits or quality degradation</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>You want to understand WHY patterns work, not just HOW</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>You need judgment criteria for choosing between approaches</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>You want to "ship while you sleep"</span>
            </div>
          </div>

          <div class="when-not">
            <div class="when-title">
              <i data-lucide="x" class="w-5 h-5"></i>
              USE SPECIFIC PATTERN DOCS WHEN
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>You know your level and need deep pattern implementation → mastery-ralph-complete.md</span>
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>You need decision support for a specific choice → JUDGMENT-GUIDE.md</span>
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>You need architecture diagrams and comparisons → architecture-complexity-ladder.md</span>
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>You need production checklists → D-FINAL-operations.md</span>
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>You're debugging a specific failure → Troubleshooting section in pattern docs</span>
            </div>
          </div>
        </div>

        <h3 class="font-semibold text-lg mb-4 mt-8">Quick Reference: Level by Pattern</h3>

        <table class="progression-table">
          <thead>
            <tr>
              <th>If you need...</th>
              <th>Level</th>
              <th>Pattern</th>
              <th>Deep dive doc</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Basic productivity</td>
              <td><span class="level-badge level-1">L1</span></td>
              <td>CLAUDE.md + Commands</td>
              <td>-</td>
            </tr>
            <tr>
              <td>Overnight feature shipping</td>
              <td><span class="level-badge level-3">L3</span></td>
              <td>Ralph Loop</td>
              <td>mastery-ralph-complete.md</td>
            </tr>
            <tr>
              <td>Parallel task execution</td>
              <td><span class="level-badge level-5">L5</span></td>
              <td>CC Mirror</td>
              <td>mastery-multi-agent.md</td>
            </tr>
            <tr>
              <td>Multiple features simultaneously</td>
              <td><span class="level-badge level-6">L6</span></td>
              <td>Parallel Ralph + Worktrees</td>
              <td>mastery-context-management.md</td>
            </tr>
            <tr>
              <td>Team-scale development</td>
              <td><span class="level-badge level-7">L7</span></td>
              <td>Gas Town Factory</td>
              <td>mastery-gastown-complete.md</td>
            </tr>
          </tbody>
        </table>
      </section>

    