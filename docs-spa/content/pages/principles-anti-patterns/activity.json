{
  "items": [
    {
      "id": "inv-1",
      "type": "inversion",
      "linkedSection": "essence",
      "title": "What if anti-patterns were just \"different approaches\"?",
      "content": "<strong>You'd design:</strong> Long sessions for \"accumulated context\", workers spawning workers for \"emergent coordination\".<br>\n          <strong>Why this fails:</strong> Transformer attention has hard limits. Workers have no coordination mechanism.<br>\n          <strong>Hidden constraint:</strong> Anti-patterns aren't style choices - they're physics violations."
    },
    {
      "id": "con-2",
      "type": "constraint",
      "linkedSection": "essence",
      "title": "One violated constraint produces FIVE downstream failures",
      "content": "<strong>ROOT:</strong> Context finite (~200K tokens)<br>\n          -&gt; Long sessions degrade quality<br>\n          -&gt; Degraded quality produces bugs<br>\n          -&gt; Bugs require debugging iterations<br>\n          -&gt; Debugging fills more context<br>\n          -&gt; Total context collapse"
    },
    {
      "id": "inv-3",
      "type": "invariant",
      "linkedSection": "essence",
      "title": "Anti-patterns violate INV-001, INV-003, INV-005",
      "content": "<strong>INV-001:</strong> Context is primary constraint (violated by long sessions)<br>\n          <strong>INV-003:</strong> External state &gt; internal memory (violated by trusting Claude's memory)<br>\n          <strong>INV-005:</strong> Verification is mandatory (violated by skipping tests)<br>\n          <em>Every anti-pattern maps to invariant violations.</em>"
    },
    {
      "id": "ana-4",
      "type": "analogy",
      "linkedSection": "core",
      "title": "Anti-patterns = Technical Debt",
      "content": "Context violations -&gt; Memory leaks<br>\n          Orchestration violations -&gt; Thread deadlocks<br>\n          Verification violations -&gt; Missing tests<br>\n          Permission violations -&gt; SQL injection<br><br>\n          <em>If you've debugged production systems, you already understand anti-patterns.</em>"
    },
    {
      "id": "exp-5",
      "type": "expertise",
      "linkedSection": "core",
      "title": "How deep is your anti-pattern understanding?",
      "content": "<strong>Beginner:</strong> \"What are the anti-patterns?\" -&gt; This doc<br>\n          <strong>Intermediate:</strong> \"Why are these bad?\" -&gt; Root cause analysis<br>\n          <strong>Advanced:</strong> \"How do I detect early?\" -&gt; Red flags section<br>\n          <strong>Staff:</strong> \"How do patterns interact?\" -&gt; Compound failures<br>\n          <strong>Expert:</strong> \"What's the meta-pattern?\" -&gt; Constraint violation recognition"
    },
    {
      "id": "war-6",
      "type": "warstory",
      "linkedSection": "core",
      "title": "$300 overnight bill from runaway loop",
      "content": "User ran Ralph without iteration limits. Loop got stuck on failing test, iterated 200+ times. Morning revealed massive API bill and no progress. <strong>Fix:</strong> MAX_ITERATIONS=25 is now standard."
    },
    {
      "id": "grad-7",
      "type": "gradient",
      "linkedSection": "context",
      "title": "How context quality degrades (invisibly)",
      "content": "<strong>100% -&gt; 90%</strong> (40-60K): Subtle drift, you won't notice<br>\n          <strong>90% -&gt; 70%</strong> (60-80K): Repetition, compression<br>\n          <strong>70% -&gt; 50%</strong> (80-100K): Instructions forgotten<br>\n          <strong>50% -&gt; CLIFF</strong> (100K+): Hallucinations, amnesia<br><br>\n          <em>Critical: The gradient is invisible until the cliff.</em>"
    },
    {
      "id": "inf-8",
      "type": "inflection",
      "linkedSection": "context",
      "title": "When to compact (the 60-70% rule)",
      "content": "<strong>0-60%:</strong> Full quality, no action needed<br>\n          <strong>60-70%:</strong> Compact NOW (sweet spot)<br>\n          <strong>70-90%:</strong> Quality degrading, compact urgently<br>\n          <strong>90-95%:</strong> Auto-compact triggers (lossy)<br>\n          <strong>95%+:</strong> Context collapse imminent<br><br>\n          <strong>THE INFLECTION:</strong> ~65% is optimal compact point"
    },
    {
      "id": "vio-9",
      "type": "violation",
      "linkedSection": "context",
      "title": "If you \"just keep going\" past 80K tokens",
      "content": "<strong>IF:</strong> You extend sessions past 80K tokens<br>\n          <strong>THEN:</strong> Early instructions get compressed<br>\n          <strong>THEN:</strong> Claude contradicts earlier work<br>\n          <strong>THEN:</strong> You debug the contradiction<br>\n          <strong>FINALLY:</strong> Debugging fills more context, accelerating collapse<br><br>\n          <em>The fix: Kill and restart. Don't debug context rot.</em>"
    },
    {
      "id": "hor-10",
      "type": "horizon",
      "linkedSection": "context",
      "title": "How context rot feels over time",
      "content": "<strong>30 min:</strong> \"This is going great!\"<br>\n          <strong>60 min:</strong> \"Hmm, it repeated itself\"<br>\n          <strong>90 min:</strong> \"Why did it ignore my last instruction?\"<br>\n          <strong>120 min:</strong> \"It's making things up now\"<br><br>\n          <em>Don't judge session health by the first 30 minutes.</em>"
    },
    {
      "id": "min-11",
      "type": "minimal",
      "linkedSection": "orchestration",
      "title": "The simplest orchestration that works",
      "content": "<code style=\"background: #f4f4f5; padding: 2px 6px; border-radius: 4px; font-size: 12px;\">Orchestrator -&gt; Worker (single level)</code><br><br>\n          <strong>Essential:</strong> One orchestrator, one worker level<br>\n          <strong>Refinement:</strong> Task management, parallel workers<br>\n          <strong>Anti-pattern:</strong> Worker -&gt; Worker -&gt; Worker (recursion)"
    },
    {
      "id": "trade-12",
      "type": "tradeoff",
      "linkedSection": "orchestration",
      "title": "Orchestrator involvement dilemma",
      "content": "<strong>Hands-off:</strong> Workers may drift from goal<br>\n          <strong>Hands-on:</strong> Orchestrator becomes bottleneck<br>\n          <strong>Micro-manage:</strong> Orchestrator does worker's job<br><br>\n          <strong>HEURISTIC:</strong> Orchestrator sets goals, checks results. Never edits files."
    },
    {
      "id": "inv-13",
      "type": "inversion",
      "linkedSection": "orchestration",
      "title": "What if workers COULD spawn subagents?",
      "content": "<strong>You'd design:</strong> \"Emergent coordination\" through recursive spawning<br>\n          <strong>Why this fails:</strong> No shared state, no coordination, exponential cost<br>\n          <strong>Hidden constraint:</strong> Workers have no view of the whole. Only orchestrators do."
    },
    {
      "id": "fron-14",
      "type": "frontier",
      "linkedSection": "orchestration",
      "title": "UNSOLVED: Optimal completion detection",
      "content": "When should an autonomous loop stop? Promise patterns work but are brittle. Test-based detection misses edge cases. Human review gates add latency. No universal solution yet."
    },
    {
      "id": "exp-15",
      "type": "expertise",
      "linkedSection": "tasks",
      "title": "Task decomposition understanding",
      "content": "<strong>Beginner:</strong> \"How big should tasks be?\" -&gt; 30-60 min<br>\n          <strong>Intermediate:</strong> \"What's too small?\" -&gt; When description &gt; code<br>\n          <strong>Advanced:</strong> \"How to split?\" -&gt; By logical boundaries<br>\n          <strong>Staff:</strong> \"Dependencies?\" -&gt; DAG-based ordering<br>\n          <strong>Expert:</strong> \"Parallel?\" -&gt; Independent tasks run together"
    },
    {
      "id": "ana-16",
      "type": "analogy",
      "linkedSection": "tasks",
      "title": "Task sizing = User story sizing",
      "content": "Epic -&gt; Feature branch (too big)<br>\n          Story -&gt; Single iteration (just right)<br>\n          Subtask -&gt; Inline edit (too small)<br><br>\n          <em>If you've done Agile, you already know task sizing.</em>"
    },
    {
      "id": "vio-17",
      "type": "violation",
      "linkedSection": "tasks",
      "title": "If you use vague acceptance criteria",
      "content": "<strong>IF:</strong> \"Make it work\" as criteria<br>\n          <strong>THEN:</strong> Claude interprets \"work\" differently than you<br>\n          <strong>THEN:</strong> You reject the output<br>\n          <strong>THEN:</strong> Claude tries again with same vague goal<br>\n          <strong>FINALLY:</strong> 5+ iterations, no progress, frustration<br><br>\n          <em>The fix: Testable criteria. \"npm test exits 0\" not \"it works\".</em>"
    },
    {
      "id": "eff-18",
      "type": "effect",
      "linkedSection": "tasks",
      "title": "At 50+ tasks, decomposition quality compounds",
      "content": "<strong>Good decomposition:</strong> 50 tasks complete linearly<br>\n          <strong>Poor decomposition:</strong> Dependencies create bottlenecks, rework multiplies<br><br>\n          <em>Task quality at start determines velocity at end.</em>"
    },
    {
      "id": "war-19",
      "type": "warstory",
      "linkedSection": "security",
      "title": "Production .env leaked to Claude context",
      "content": "Developer ran <code>cat .env</code> in Claude session. API keys became part of context. Session exported for debugging included credentials. Keys had to be rotated. <strong>Fix:</strong> .claudeignore for all .env files."
    },
    {
      "id": "con-20",
      "type": "constraint",
      "linkedSection": "security",
      "title": "Why --dangerously-skip-permissions is... dangerous",
      "content": "<strong>ROOT:</strong> No permission checks<br>\n          -&gt; Any command can execute<br>\n          -&gt; Destructive commands included<br>\n          -&gt; One hallucination away from rm -rf<br>\n          -&gt; No recovery from deleted files<br><br>\n          <em>The flag name is the warning.</em>"
    },
    {
      "id": "trade-21",
      "type": "tradeoff",
      "linkedSection": "security",
      "title": "Convenience vs. Security",
      "content": "<strong>Full permissions:</strong> Fast, but one mistake = disaster<br>\n          <strong>No permissions:</strong> Safe, but constant interrupts<br>\n          <strong>Granular whitelist:</strong> Balanced, but requires setup<br><br>\n          <strong>HEURISTIC:</strong> Whitelist safe commands, keep destructive blocked."
    },
    {
      "id": "hor-22",
      "type": "horizon",
      "linkedSection": "security",
      "title": "Cost awareness over time",
      "content": "<strong>Week 1:</strong> \"Opus for everything, I want quality\"<br>\n          <strong>Week 2:</strong> \"Wait, that bill seems high\"<br>\n          <strong>Week 4:</strong> \"$500/month on simple lookups?\"<br>\n          <strong>Week 8:</strong> \"Haiku for exploration, Sonnet for work, Opus for architecture\"<br><br>\n          <em>Model matching is a learned skill.</em>"
    },
    {
      "id": "grad-23",
      "type": "gradient",
      "linkedSection": "detection",
      "title": "How anti-patterns compound",
      "content": "<strong>1 violation:</strong> Minor inefficiency, recoverable<br>\n          <strong>2 violations:</strong> Compounding problems, harder recovery<br>\n          <strong>3 violations:</strong> Session likely unrecoverable<br>\n          <strong>4+ violations:</strong> Stop. Reset. Start fresh.<br><br>\n          <em>Anti-patterns multiply, they don't add.</em>"
    },
    {
      "id": "min-24",
      "type": "minimal",
      "linkedSection": "detection",
      "title": "The simplest red flag checklist",
      "content": "<strong>3 questions before each session:</strong><br>\n          1. Clean git state?<br>\n          2. Dedicated branch?<br>\n          3. .claudeignore configured?<br><br>\n          <em>If any answer is \"no\", fix before starting.</em>"
    },
    {
      "id": "inf-25",
      "type": "inflection",
      "linkedSection": "detection",
      "title": "When debugging becomes the problem",
      "content": "<strong>1-2 retries:</strong> Normal iteration<br>\n          <strong>3-4 retries:</strong> Check task clarity<br>\n          <strong>5+ retries:</strong> Stop. The task or context is the problem.<br><br>\n          <strong>THE INFLECTION:</strong> 5 retries = wrong tool or wrong task<br>\n          <em>After 5 failures, step back and reassess.</em>"
    },
    {
      "id": "alt-26",
      "type": "alternative",
      "linkedSection": "detection",
      "title": "When Claude Code isn't right",
      "content": "<strong>Security-critical?</strong> -&gt; Human expert review<br>\n          <strong>Novel domain?</strong> -&gt; Research-first approach<br>\n          <strong>Race conditions?</strong> -&gt; Dedicated debugging tools<br>\n          <strong>Real-time?</strong> -&gt; Manual implementation"
    },
    {
      "id": "exp-27",
      "type": "expertise",
      "linkedSection": "recovery",
      "title": "Recovery skill progression",
      "content": "<strong>Beginner:</strong> \"How do I stop it?\" -&gt; Ctrl+C<br>\n          <strong>Intermediate:</strong> \"How do I undo?\" -&gt; git checkout<br>\n          <strong>Advanced:</strong> \"How do I prevent?\" -&gt; Checklists<br>\n          <strong>Staff:</strong> \"How do I detect early?\" -&gt; Red flags<br>\n          <strong>Expert:</strong> \"How do I design out?\" -&gt; Architecture"
    },
    {
      "id": "war-28",
      "type": "warstory",
      "linkedSection": "recovery",
      "title": "Infinite loop caught by git stash",
      "content": "Developer's Ralph loop went infinite. Killed it, but files were in inconsistent state. Recovered via <code>git stash</code> from before the run. <strong>Lesson:</strong> Always start from clean git state."
    },
    {
      "id": "inv-29",
      "type": "inversion",
      "linkedSection": "recovery",
      "title": "What if there was no recovery?",
      "content": "<strong>You'd design:</strong> Bulletproof prevention, no second chances<br>\n          <strong>Why this fails:</strong> Perfection is impossible, humans make mistakes<br>\n          <strong>Hidden truth:</strong> Recovery strategies ARE the safety net. Prevention + Recovery = Resilience."
    },
    {
      "id": "comp-30",
      "type": "composition",
      "linkedSection": "recovery",
      "title": "Anti-Patterns + Ralph Pattern",
      "content": "<strong>Works:</strong> Ralph's fresh context prevents context rot anti-pattern.<br>\n          <strong>Synergy:</strong> External state prevents memory loss anti-pattern.<br>\n          <strong>Note:</strong> Ralph doesn't prevent task design anti-patterns - those require human judgment."
    },
    {
      "id": "inv-31",
      "type": "invariant",
      "linkedSection": "recovery",
      "title": "All recovery strategies share one invariant",
      "content": "<strong>INV-008:</strong> Git is the source of truth<br><br>\n          Every recovery (context overflow, file corruption, infinite loops) relies on git for rollback. If your git state was clean before the failure, recovery is possible. If not, recovery is painful."
    }
  ]
}