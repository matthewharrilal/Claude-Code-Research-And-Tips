

      <!-- Section 1: ESSENCE -->
      <section id="essence" data-activity="essence">
        <div class="essence-box">
          <div class="essence-label">Essence (15 words)</div>
          <div class="essence-text">Eight principles explain WHY every Claude Code pattern works. Physics first, engineering follows.</div>
        </div>
      </section>

      <!-- Section 2: CORE ABSTRACTION + IMPLEMENTATION -->
      <section id="core-abstraction" data-activity="core">
        <h2 class="section-title">
          <span class="section-number">2</span>
          The Core Abstraction
        </h2>

        <div class="core-abstraction">
          <div class="core-philosophy">"Understanding principles enables you to create new patterns, adapt existing ones, and diagnose failures."</div>

          <div class="core-code">
            <button class="copy-btn" onclick="copyCode(this, 'When in doubt: externalize, isolate, verify, restart fresh.')">
              <i data-lucide="copy" class="w-3 h-3"></i>
              Copy
            </button>
            <code>When in doubt: externalize, isolate, verify, restart fresh.</code>
          </div>

          <div class="core-anchor">The meta-principle. Everything else derives from it.</div>
        </div>

        <p class="text-text-secondary mb-6">
          These 8 principles are the fundamental WHYs behind every Claude Code pattern. They're not arbitrary rules - they emerge from the physics of LLM context windows, the reality of session boundaries, and the mathematics of compound errors.
        </p>

        <div class="hierarchy-box">
          <pre>                    +----------------------------------+
                    |  PRINCIPLE 1: CONTEXT IS FINITE  |
                    |  (The Primary Constraint)        |
                    +-----------------+----------------+
                                      |
              Everything flows from this limitation
                                      |
        +-----------------------------+-----------------------------+
        |                             |                             |
        v                             v                             v
+-------------------+   +-------------------+   +-------------------+
| PRINCIPLE 2:      |   | PRINCIPLE 3:      |   | PRINCIPLE 4:      |
| External State    |   | Fresh Context     |   | Separation of     |
| &gt; Internal Memory |   | &gt; Extended        |   | Concerns          |
|                   |   |   Sessions        |   | (Orch/Worker)     |
+---------+---------+   +---------+---------+   +---------+---------+
          |                       |                       |
          +-------------------------------------------+
                                  |
                    +-------------+-------------+
                    |                           |
                    v                           v
          +-------------------+      +-------------------+
          | PRINCIPLE 5:      |      | PRINCIPLE 6:      |
          | Atomic, Verifiable|      | Quality Gates     |
          | Task Sizing       |      | Before Commit     |
          +-------------------+      +-------------------+</pre>
        </div>

        <div id="the-8-principles">
          <h3 class="text-lg font-semibold mb-4 mt-8">The Complete Eight</h3>

          <table class="principle-table">
            <thead>
              <tr>
                <th>#</th>
                <th>Principle</th>
                <th>One-Line Summary</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>P1</strong></td>
                <td>Context Is Finite</td>
                <td>All patterns optimize around limited context windows</td>
              </tr>
              <tr>
                <td><strong>P2</strong></td>
                <td>External State &gt; Internal Memory</td>
                <td>Files persist, context evaporates</td>
              </tr>
              <tr>
                <td><strong>P3</strong></td>
                <td>Fresh Context &gt; Extended Sessions</td>
                <td>New instances beat long conversations</td>
              </tr>
              <tr>
                <td><strong>P4</strong></td>
                <td>Separation of Concerns</td>
                <td>Orchestrators coordinate, workers execute</td>
              </tr>
              <tr>
                <td><strong>P5</strong></td>
                <td>Atomic, Verifiable Tasks</td>
                <td>Complete in one iteration, verify before commit</td>
              </tr>
              <tr>
                <td><strong>P6</strong></td>
                <td>Quality Gates Before Commit</td>
                <td>Tests must pass, no broken code inheritance</td>
              </tr>
              <tr>
                <td><strong>P7</strong></td>
                <td>Isolation Prevents Contamination</td>
                <td>Own your space, don't conflict</td>
              </tr>
              <tr>
                <td><strong>P8</strong></td>
                <td>Explicit Communication</td>
                <td>File-based handoffs, not implicit coordination</td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>

      <!-- Section 3: DESIGN DECISIONS (Principles 1-4) -->
      <section id="p1-context" data-activity="decisions">
        <h2 class="section-title">
          <span class="section-number">3</span>
          Design Decisions (P1-P4)
        </h2>

        <div class="decision-box">
          <div class="decision-why">P1: WHY CONTEXT IS THE PRIMARY CONSTRAINT</div>
          <div class="decision-reasoning">
            LLMs degrade with filled context windows. Claude's ~200K tokens (effective ~100K for quality work) is a hard ceiling. At 70-85% fill, you see instruction drift. At 85%+, hallucinations and amnesia. This is transformer physics, not a bug.
          </div>
          <div class="decision-implication">
            <div class="decision-implication-label">What this means for you</div>
            <div class="text-text-secondary text-sm">
              Every pattern, tool, and workflow decision must answer: "How does this affect context consumption?" If it grows unbounded, it will eventually break.
            </div>
          </div>
        </div>

        <div class="quote-block">
          <div class="quote-text">"Context rot: LLMs get stupider with more tokens."</div>
          <div class="quote-author">-- @mattpocockuk</div>
        </div>

        <h4 class="font-semibold mb-3 mt-6">Context Rot Symptoms</h4>
        <table class="principle-table">
          <thead>
            <tr>
              <th>Context Level</th>
              <th>Quality Impact</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>0-50%</td>
              <td>Full capability</td>
            </tr>
            <tr>
              <td>50-70%</td>
              <td>Slight degradation possible</td>
            </tr>
            <tr>
              <td>70-85%</td>
              <td>Noticeable quality loss</td>
            </tr>
            <tr>
              <td>85-95%</td>
              <td>Significant degradation, instructions forgotten</td>
            </tr>
            <tr>
              <td>95%+</td>
              <td>Failure mode - hallucinations, contradictions, amnesia</td>
            </tr>
          </tbody>
        </table>

        <div class="decision-box" id="p2-external">
          <div class="decision-why">P2: WHY EXTERNAL STATE OVER INTERNAL MEMORY</div>
          <div class="decision-reasoning">
            Sessions end. Context clears. Memory evaporates. Any information stored only in the LLM's context will be lost when the session ends, context fills, errors crash, or the user starts fresh. The filesystem IS the memory.
          </div>
          <div class="decision-implication">
            <div class="decision-implication-label">What this means for you</div>
            <div class="text-text-secondary text-sm">
              Never trust context for continuity. Write state immediately. If it's not in a file, it doesn't exist. Use the three core files: <code>progress.txt</code> (append-only learnings), <code>prd.json</code> (task state), <code>CLAUDE.md</code> (project context).
            </div>
          </div>
        </div>

        <div class="quote-block">
          <div class="quote-text">"Memory is external. The agent is stateless."</div>
          <div class="quote-author">-- Ryan Carson</div>
        </div>

        <div class="decision-box" id="p3-fresh">
          <div class="decision-why">P3: WHY FRESH CONTEXT OVER EXTENDED SESSIONS</div>
          <div class="decision-reasoning">
            Context accumulation is entropy. Every operation adds tokens. Every token added slightly degrades future operations. This compounds until quality collapse. Fresh context is regeneration - 0% usage, peak capability, no accumulated noise.
          </div>
          <div class="decision-implication">
            <div class="decision-implication-label">What this means for you</div>
            <div class="text-text-secondary text-sm">
              Design for iteration, not session. Size work to complete within one context window. Accept startup cost - reading state each time is worth quality preservation. Extended sessions guarantee degradation; fresh context guarantees consistent quality.
            </div>
          </div>
        </div>

        <div class="decision-box" id="p4-separation">
          <div class="decision-why">P4: WHY SEPARATE ORCHESTRATOR FROM WORKER</div>
          <div class="decision-reasoning">
            Mixing coordination with execution causes context pollution (orchestrator fills with execution details) and role confusion (agent oscillates between planning and doing, doing neither well). Clear separation enables parallelization, model selection by role, and failure containment.
          </div>
          <div class="decision-implication">
            <div class="decision-implication-label">What this means for you</div>
            <div class="text-text-secondary text-sm">
              Orchestrators: decompose, assign, track, monitor. Workers: execute, report, complete, exit. Use Opus for orchestration (complex reasoning), Sonnet for implementation (following patterns), Haiku for lookups (simple transforms).
            </div>
          </div>
        </div>

        <div class="quote-block">
          <div class="quote-text">"YOU DO NOT WRITE CODE. YOU DO NOT RUN COMMANDS. YOU DO NOT EXPLORE CODEBASES. You are the CONDUCTOR. Your agents play the instruments."</div>
          <div class="quote-author">-- @nummanali (CC Mirror)</div>
        </div>
      </section>

      <!-- Section 4: FILE STRUCTURE (Principles 5-8) -->
      <section id="p5-atomic" data-activity="files">
        <h2 class="section-title">
          <span class="section-number">4</span>
          More Principles (P5-P8)
        </h2>

        <div class="principle-card">
          <div class="principle-header">
            <div class="principle-number">5</div>
            <div class="principle-name">Atomic, Verifiable Task Sizing</div>
          </div>
          <div class="principle-summary">
            Large tasks fail predictably: context overflow, scope creep, unverifiable progress, lost recovery points. Atomic tasks succeed because they fit in one context window, have clear boundaries, can be independently verified, and can be committed atomically.
          </div>

          <h4 class="font-semibold mb-3">The 2-3 Sentence Test</h4>
          <p class="text-text-secondary text-sm mb-4">If you can't describe the task in 2-3 sentences, it's too big.</p>

          <table class="principle-table">
            <thead>
              <tr>
                <th>Size</th>
                <th>Lines</th>
                <th>Files</th>
                <th>Iterations</th>
                <th>Example</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>XS</td>
                <td>1-20</td>
                <td>1</td>
                <td>1</td>
                <td>Add column, fix typo</td>
              </tr>
              <tr>
                <td>S</td>
                <td>20-100</td>
                <td>1-2</td>
                <td>1</td>
                <td>New component, endpoint</td>
              </tr>
              <tr>
                <td>M</td>
                <td>100-300</td>
                <td>2-5</td>
                <td>1-2</td>
                <td>Feature piece, integration</td>
              </tr>
              <tr>
                <td>L</td>
                <td>300-1000</td>
                <td>5-10</td>
                <td>3-5</td>
                <td>Small feature, refactor</td>
              </tr>
              <tr>
                <td>XL</td>
                <td>1000+</td>
                <td>10+</td>
                <td>5+</td>
                <td><strong>MUST DECOMPOSE!</strong></td>
              </tr>
            </tbody>
          </table>
        </div>

        <div class="principle-card" id="p6-gates">
          <div class="principle-header">
            <div class="principle-number">6</div>
            <div class="principle-name">Quality Gates Before Commit</div>
          </div>
          <div class="principle-summary">
            Broken code propagates. If iteration N commits broken code, iteration N+1 inherits a broken baseline and must debug first. This compounds. Working code accumulates - if every commit passes tests, every future iteration starts from a working baseline.
          </div>

          <div class="code-block">
            <button class="copy-btn" onclick="copyCodeBlock(this)">
              <i data-lucide="copy" class="w-3 h-3"></i>
              Copy
            </button>
            <pre><span class="comment"># BEFORE ANY COMMIT:</span>
1. Type checking     <span class="keyword">--&gt;</span> npm run typecheck
2. Unit tests        <span class="keyword">--&gt;</span> npm test
3. Lint              <span class="keyword">--&gt;</span> npm run lint
4. Integration tests <span class="keyword">--&gt;</span> npm run test:integration

<span class="comment"># ALL PASS? --&gt; Commit allowed</span>
<span class="comment"># ANY FAIL? --&gt; Fix BEFORE commit, retry gates</span></pre>
          </div>
        </div>

        <div class="principle-card" id="p7-isolation">
          <div class="principle-header">
            <div class="principle-number">7</div>
            <div class="principle-name">Isolation Prevents Contamination</div>
          </div>
          <div class="principle-summary">
            Shared state causes conflicts - edits overwrite, merge conflicts arise, partial changes break builds. Isolation enables parallelization - no conflicts possible, parallel execution safe, failures contained, recovery straightforward.
          </div>

          <table class="principle-table">
            <thead>
              <tr>
                <th>Strategy</th>
                <th>Mechanism</th>
                <th>Best For</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Directory isolation</td>
                <td>Each agent owns a directory</td>
                <td>Domain specialization</td>
              </tr>
              <tr>
                <td>Branch isolation</td>
                <td>Each agent on own branch</td>
                <td>Feature parallelism</td>
              </tr>
              <tr>
                <td>Worktree isolation</td>
                <td>Git worktrees share repo</td>
                <td>Heavy parallelism</td>
              </tr>
              <tr>
                <td>Container isolation</td>
                <td>Docker with volume mounts</td>
                <td>Production systems</td>
              </tr>
            </tbody>
          </table>
        </div>

        <div class="principle-card" id="p8-explicit">
          <div class="principle-header">
            <div class="principle-number">8</div>
            <div class="principle-name">Explicit Communication Over Implicit</div>
          </div>
          <div class="principle-summary">
            LLMs don't share memory. Each agent instance starts with zero knowledge of others. Implicit coordination fails - agents can't sense what others are doing, know if files are being edited elsewhere, or coordinate timing without signals. File-based explicit communication succeeds.
          </div>

          <div class="code-block">
            <button class="copy-btn" onclick="copyCodeBlock(this)">
              <i data-lucide="copy" class="w-3 h-3"></i>
              Copy
            </button>
            <pre><span class="comment">// handoff-agent1-to-agent2.json</span>
{
  <span class="string">"from"</span>: <span class="string">"agent1"</span>,
  <span class="string">"to"</span>: <span class="string">"agent2"</span>,
  <span class="string">"timestamp"</span>: <span class="string">"2026-01-09T10:30:00Z"</span>,
  <span class="string">"context"</span>: {
    <span class="string">"completed"</span>: [<span class="string">"API schema"</span>, <span class="string">"Database models"</span>],
    <span class="string">"next_steps"</span>: [<span class="string">"Implement REST endpoints"</span>],
    <span class="string">"blockers"</span>: [],
    <span class="string">"notes"</span>: <span class="string">"Using FastAPI, see docs in /api/README.md"</span>
  }
}</pre>
          </div>
        </div>
      </section>

      <!-- Section 5: PATH OF A TASK (Deriving Patterns) -->
      <section id="derivation" data-activity="path">
        <h2 class="section-title">
          <span class="section-number">5</span>
          Deriving New Patterns
        </h2>

        <p class="text-text-secondary mb-6">
          The true power of understanding principles is the ability to derive NEW patterns for novel situations.
        </p>

        <div class="path-container">
          <div class="path-step">
            <div class="path-number">1</div>
            <div class="path-content"><strong>Identify the constraint</strong> - What's the primary challenge?</div>
          </div>
          <div class="path-step">
            <div class="path-number">2</div>
            <div class="path-content"><strong>Map to principles</strong> - Which principles apply?</div>
          </div>
          <div class="path-step">
            <div class="path-number">3</div>
            <div class="path-content"><strong>Check for conflicts</strong> - Do any principles conflict in this case?</div>
          </div>
          <div class="path-step">
            <div class="path-number">4</div>
            <div class="path-content"><strong>Combine mechanisms</strong> - What implementations serve multiple principles?</div>
          </div>
          <div class="path-step">
            <div class="path-number">5</div>
            <div class="path-content"><strong>Validate</strong> - Does the derived pattern satisfy the constraints?</div>
          </div>
        </div>

        <h4 class="font-semibold mb-3">Example: Multi-Model Ensemble</h4>
        <p class="text-text-secondary text-sm mb-4">
          <strong>Scenario:</strong> Need to build a complex feature with both architecture decisions AND implementation.
        </p>

        <table class="principle-table">
          <thead>
            <tr>
              <th>Constraint</th>
              <th>Principle</th>
              <th>Implication</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Complex work</td>
              <td>P1 (Context finite)</td>
              <td>Preserve context for complex reasoning</td>
            </tr>
            <tr>
              <td>Planning + execution</td>
              <td>P4 (Separation)</td>
              <td>Separate planning from execution</td>
            </tr>
            <tr>
              <td>Large feature</td>
              <td>P5 (Atomic tasks)</td>
              <td>Break into completable chunks</td>
            </tr>
            <tr>
              <td>Quality requirement</td>
              <td>P6 (Quality gates)</td>
              <td>Each chunk verified before next</td>
            </tr>
          </tbody>
        </table>

        <p class="text-text-secondary text-sm mt-4 mb-4"><strong>Derived Pattern:</strong></p>
        <div class="code-block">
          <pre>1. Opus agent (planning mode) <span class="keyword">--&gt;</span> Analyze requirements, produce PRD
2. PRD verified by human
3. Sonnet workers (parallel) <span class="keyword">--&gt;</span> Implement each story
4. Each story passes tests before commit
5. Opus agent (review mode) <span class="keyword">--&gt;</span> Verify integration</pre>
        </div>

        <h4 class="font-semibold mb-3 mt-8">Principle Compatibility Matrix</h4>
        <table class="principle-table">
          <thead>
            <tr>
              <th>Principle</th>
              <th>Reinforces</th>
              <th>Tension With</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>P1 (Context)</td>
              <td>P3, P2, P5</td>
              <td>Extended sessions</td>
            </tr>
            <tr>
              <td>P2 (External)</td>
              <td>P3, P8</td>
              <td>In-context memory</td>
            </tr>
            <tr>
              <td>P3 (Fresh)</td>
              <td>P1, P2</td>
              <td>Session continuity</td>
            </tr>
            <tr>
              <td>P4 (Separation)</td>
              <td>P1, P7</td>
              <td>Simple single-agent</td>
            </tr>
            <tr>
              <td>P5 (Atomic)</td>
              <td>P6, P3</td>
              <td>Large monolithic tasks</td>
            </tr>
            <tr>
              <td>P6 (Gates)</td>
              <td>P5, P2</td>
              <td>Speed-first development</td>
            </tr>
            <tr>
              <td>P7 (Isolation)</td>
              <td>P4, P8</td>
              <td>Shared state</td>
            </tr>
            <tr>
              <td>P8 (Explicit)</td>
              <td>P7, P2</td>
              <td>Implicit coordination</td>
            </tr>
          </tbody>
        </table>
      </section>

      <!-- Section 6: GOTCHAS -->
      <section id="gotchas" data-activity="gotchas">
        <h2 class="section-title">
          <span class="section-number">6</span>
          Gotchas
        </h2>

        <p class="text-text-secondary mb-6">
          Common principle violations and how to diagnose them:
        </p>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Principle violation goes unnoticed until failure
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Pattern works for small tasks but fails catastrophically on larger ones</div>
          <div class="gotcha-detail"><strong>Cause:</strong> Subtle principle violations that only manifest at scale</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Use the principle checklist before any multi-session or multi-agent work</div>
        </div>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Fresh context pattern feels inefficient
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Startup overhead each iteration seems wasteful</div>
          <div class="gotcha-detail"><strong>Cause:</strong> Misunderstanding the tradeoff between consistency and speed</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Accept that reading state takes ~5-10 seconds but prevents hours of debugging. Measure: fresh context iterations are MORE efficient over 10+ iterations.</div>
        </div>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Orchestrator keeps "helping" with implementation
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Orchestrator context fills with code; loses coordination capacity</div>
          <div class="gotcha-detail"><strong>Cause:</strong> Unclear role boundaries or orchestrator prompt too permissive</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Add explicit prohibition: "YOU DO NOT WRITE CODE." Restrict orchestrator tools to: TaskCreate, TaskUpdate, Task, AskUserQuestion, Read (1-2 files max).</div>
        </div>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Tasks never seem "atomic" enough
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Tasks keep expanding scope; never complete in one iteration</div>
          <div class="gotcha-detail"><strong>Cause:</strong> Acceptance criteria too vague or task boundaries unclear</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Apply the 2-3 sentence test. If you can't describe it in 2-3 sentences, split it.</div>
        </div>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Quality gates slow things down
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Tests take too long; tempted to skip them</div>
          <div class="gotcha-detail"><strong>Cause:</strong> Misunderstanding the cost of broken code propagation</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Broken code in iteration N means N+1 must debug first. Debugging spirals can consume 5-10x the time saved by skipping tests.</div>
        </div>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Isolation prevents necessary coordination
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Agents can't share information; work duplicated</div>
          <div class="gotcha-detail"><strong>Cause:</strong> Over-isolation without handoff mechanism</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Isolation doesn't mean no communication - it means EXPLICIT communication via files. Use <code>handoff-agent1-to-agent2.json</code> pattern.</div>
        </div>
      </section>

      <!-- Section 7: WHAT'S HARD -->
      <section id="hard" data-activity="hard">
        <h2 class="section-title">
          <span class="section-number">7</span>
          What's Hard
        </h2>

        <p class="text-text-secondary mb-6">
          Fundamental tensions between principles that require judgment, not rules:
        </p>

        <div class="hard-box">
          <div class="hard-title">
            <i data-lucide="flame" class="w-4 h-4"></i>
            P1 vs P4: Context Constraint vs Separation Overhead
          </div>
          <div class="hard-detail"><strong>The tension:</strong> Orchestrator/worker separation (P4) adds context overhead - spawning workers, reading results. But context is precious (P1).</div>
          <div class="hard-detail"><strong>Symptoms:</strong> Simple tasks feel over-engineered with full separation. Complex tasks fail without it.</div>
          <div class="hard-detail"><strong>Mitigation:</strong> Use single-agent for simple tasks (&lt; 30 min). Add orchestrator when task graph &gt; 3 nodes. The threshold is judgment, not formula.</div>
        </div>

        <div class="hard-box">
          <div class="hard-title">
            <i data-lucide="flame" class="w-4 h-4"></i>
            P3 vs P5: Fresh Context vs Task Continuity
          </div>
          <div class="hard-detail"><strong>The tension:</strong> Fresh context (P3) means losing state. Atomic tasks (P5) sometimes need context from the previous step that's hard to externalize.</div>
          <div class="hard-detail"><strong>Symptoms:</strong> Multi-step workflows lose subtle context between iterations. Repeating obvious mistakes.</div>
          <div class="hard-detail"><strong>Mitigation:</strong> Invest in better externalization. progress.txt for learnings. Detailed task descriptions that capture implicit knowledge.</div>
        </div>

        <div class="hard-box">
          <div class="hard-title">
            <i data-lucide="flame" class="w-4 h-4"></i>
            P6 vs Speed: Quality Gates vs Development Velocity
          </div>
          <div class="hard-detail"><strong>The tension:</strong> Running full test suites (P6) takes time. Fast iteration feels productive.</div>
          <div class="hard-detail"><strong>Symptoms:</strong> Temptation to skip tests on "small" changes. Debugging spirals when you don't.</div>
          <div class="hard-detail"><strong>Mitigation:</strong> Invest in fast tests. Parallel test execution. Incremental type checking. The answer is faster gates, not no gates.</div>
        </div>

        <div class="hard-box">
          <div class="hard-title">
            <i data-lucide="flame" class="w-4 h-4"></i>
            P7 vs P8: Isolation vs Communication
          </div>
          <div class="hard-detail"><strong>The tension:</strong> More isolation (P7) means more communication overhead (P8). Less isolation means conflict risk.</div>
          <div class="hard-detail"><strong>Symptoms:</strong> Agents duplicating work (over-isolated). Agents conflicting on files (under-isolated).</div>
          <div class="hard-detail"><strong>Mitigation:</strong> Isolation at directory/branch level. Communication at file level. Clear ownership rules. The boundary matters more than the mechanism.</div>
        </div>
      </section>

      <!-- Section 8: WHEN TO USE / QUICK REFERENCE -->
      <section id="when" data-activity="when">
        <h2 class="section-title">
          <span class="section-number">8</span>
          Quick Reference
        </h2>

        <h4 class="font-semibold mb-4">When Things Break, Check Principles</h4>

        <table class="principle-table">
          <thead>
            <tr>
              <th>Symptom</th>
              <th>Likely Violated</th>
              <th>Fix</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Agent forgets previous work</td>
              <td>P2 (External state)</td>
              <td>Externalize to files</td>
            </tr>
            <tr>
              <td>Quality degrades over time</td>
              <td>P1/P3 (Context/Fresh)</td>
              <td>Reset more frequently</td>
            </tr>
            <tr>
              <td>Workers spawn their own agents</td>
              <td>P4 (Separation)</td>
              <td>Explicit worker preamble</td>
            </tr>
            <tr>
              <td>Tasks never complete</td>
              <td>P5 (Atomic sizing)</td>
              <td>Smaller stories</td>
            </tr>
            <tr>
              <td>Broken code accumulates</td>
              <td>P6 (Quality gates)</td>
              <td>Enforce tests before commit</td>
            </tr>
            <tr>
              <td>Agents conflict on files</td>
              <td>P7 (Isolation)</td>
              <td>Worktrees or ownership</td>
            </tr>
            <tr>
              <td>Agents don't coordinate</td>
              <td>P8 (Explicit comms)</td>
              <td>File-based handoffs</td>
            </tr>
          </tbody>
        </table>

        <div class="checkpoint-box">
          <div class="checkpoint-title">
            <i data-lucide="check-circle" class="w-4 h-4"></i>
            The Principle Checklist
          </div>
          <p class="text-sm text-text-secondary mb-3">Before any multi-session or multi-agent work:</p>
          <div class="checkpoint-item">
            <input type="checkbox" class="mr-2">
            <span>Is state externalized to survive session death? (P2)</span>
          </div>
          <div class="checkpoint-item">
            <input type="checkbox" class="mr-2">
            <span>Is each task completable in one context window? (P5)</span>
          </div>
          <div class="checkpoint-item">
            <input type="checkbox" class="mr-2">
            <span>Are quality gates defined and enforced? (P6)</span>
          </div>
          <div class="checkpoint-item">
            <input type="checkbox" class="mr-2">
            <span>Is orchestrator separated from workers? (P4)</span>
          </div>
          <div class="checkpoint-item">
            <input type="checkbox" class="mr-2">
            <span>Are agents isolated from each other? (P7)</span>
          </div>
          <div class="checkpoint-item">
            <input type="checkbox" class="mr-2">
            <span>Is communication explicit via files? (P8)</span>
          </div>
          <div class="checkpoint-item">
            <input type="checkbox" class="mr-2">
            <span>Is fresh context preferred over extended sessions? (P3)</span>
          </div>
          <div class="checkpoint-item">
            <input type="checkbox" class="mr-2">
            <span>Is context budget tracked and respected? (P1)</span>
          </div>
        </div>

        <div class="when-grid">
          <div class="when-use">
            <div class="when-title">
              <i data-lucide="check" class="w-5 h-5"></i>
              APPLY PRINCIPLES WHEN
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>Building any multi-session workflow</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>Designing multi-agent systems</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>Debugging failed patterns</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>Creating new patterns for novel situations</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>Evaluating tradeoffs in architectural decisions</span>
            </div>
          </div>

          <div class="when-not">
            <div class="when-title">
              <i data-lucide="x" class="w-5 h-5"></i>
              DON'T OVER-APPLY WHEN
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>Single small task (&lt; 30 min) - Simple is fine</span>
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>Exploratory debugging - Context accumulation helps</span>
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>Learning/prototyping - Speed matters more</span>
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>One-off scripts - Don't over-engineer</span>
            </div>
          </div>
        </div>
      </section>

    