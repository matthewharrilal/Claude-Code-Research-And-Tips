

      <!-- Section 1: ESSENCE -->
      <section id="essence" data-activity="essence">
        <div class="essence-box">
          <div class="essence-label">Essence (15 words)</div>
          <div class="essence-text">Two patterns combined unlock capabilities neither provides alone. LEGO blocks, not silver bullets.</div>
        </div>
      </section>

      <!-- Section 2: CORE ABSTRACTION -->
      <section id="core-abstraction" data-activity="core">
        <h2 class="section-title">
          <span class="section-number">2</span>
          The Core Abstraction
        </h2>

        <div class="core-abstraction">
          <div class="core-philosophy">"Patterns are LEGO blocks. Each is useful alone, but the real power comes from combining them into systems greater than their parts."</div>

          <div class="core-code">
            <button class="copy-btn" onclick="copyCode(this, 'Pattern A + Pattern B = Emergent Capability C')">
              <i data-lucide="copy" class="w-3 h-3"></i>
              Copy
            </button>
            <code>Pattern A + Pattern B = Emergent Capability C</code>
          </div>

          <div class="core-anchor">This document explains HOW and WHY combinations unlock new capabilities.</div>
        </div>

        <p class="text-text-secondary mb-6">
          While <code>combinations-matrix.md</code> tells you WHAT works together, this document goes deep on the mechanics. Why does Ralph + Playwright catch bugs that unit tests miss? Why do Subagents + Worktrees enable true parallel development?
        </p>

        <p class="text-text-secondary mb-6">
          The insight: combinations create <strong>emergent capabilities</strong> that neither pattern provides alone. Ralph gives you iteration. Playwright gives you screenshots. Together they give you <em>verified UI development</em> - something fundamentally different from either component.
        </p>

        <p class="text-text-secondary mb-6">
          Use this when planning your first multi-pattern workflow. Start with combinations that match your pain points, not the most impressive-sounding ones.
        </p>
      </section>

      <!-- Section 3: LOOP + TOOL COMBINATIONS -->
      <section id="loop-tool" data-activity="loop-tool">
        <h2 class="section-title">
          <span class="section-number">3</span>
          Loop + Tool Combinations
        </h2>

        <p class="text-text-secondary mb-6">
          Loop patterns (Ralph, continuous iteration) gain new powers when combined with specific tools. The loop provides persistence; the tool provides capability.
        </p>

        <!-- Ralph + Playwright -->
        <div class="combo-card" id="ralph-playwright">
          <div class="combo-header">
            <span class="combo-pattern">Ralph</span>
            <span class="combo-plus">+</span>
            <span class="combo-pattern">Playwright</span>
            <span class="combo-roi very-high">Very High ROI</span>
          </div>
          <div class="combo-enables">
            <strong>What It Enables:</strong> Visual verification in iterative loops. UI changes confirmed via screenshot, not just tests. Real-world feedback prevents "feature complete but broken" syndrome.
          </div>

          <p class="text-text-secondary mb-4">
            <strong>Source:</strong> @weswinder - "opus 4.5 with ralph wiggum and playwright is agi"
          </p>

          <div class="code-block">
            <button class="copy-btn" onclick="copyCodeBlock(this)">
              <i data-lucide="copy" class="w-3 h-3"></i>
              Copy
            </button>
            <pre><span class="comment">// In prd.json acceptance criteria</span>
<span class="string">"acceptanceCriteria"</span>: [
  <span class="string">"Button renders correctly"</span>,
  <span class="string">"npm run typecheck passes"</span>,
  <span class="string">"Playwright screenshot shows button at expected position"</span>
]</pre>
          </div>

          <div class="arch-diagram">Ralph Loop (Main Agent)
    |
    +-- Pick story
    +-- Implement
    +-- Run typecheck/tests
    |
    +-- Spawn Playwright Subagent --&gt; Take screenshot
                                      Return verification
    |
    +-- If verified: commit, mark passes: true</div>

          <p class="text-text-secondary">
            <strong>Critical Optimization (@TendiesOfWisdom):</strong> "Put costly tools like browser control in subagents to protect your main context window tokens."
          </p>
        </div>

        <!-- Ralph + MCP -->
        <div class="combo-card" id="ralph-mcp">
          <div class="combo-header">
            <span class="combo-pattern">Ralph</span>
            <span class="combo-plus">+</span>
            <span class="combo-pattern">MCP Tools</span>
            <span class="combo-roi high">High ROI</span>
          </div>
          <div class="combo-enables">
            <strong>What It Enables:</strong> Database operations verified per iteration. API integrations tested automatically. Each story can verify end-to-end functionality.
          </div>

          <div class="code-block">
            <button class="copy-btn" onclick="copyCodeBlock(this)">
              <i data-lucide="copy" class="w-3 h-3"></i>
              Copy
            </button>
            <pre><span class="comment">// prd.json with MCP verification</span>
{
  <span class="string">"id"</span>: <span class="string">"US-003"</span>,
  <span class="string">"title"</span>: <span class="string">"Add user to database"</span>,
  <span class="string">"acceptanceCriteria"</span>: [
    <span class="string">"User created in PostgreSQL"</span>,
    <span class="string">"MCP verify: SELECT * FROM users WHERE email = 'test@test.com' returns 1 row"</span>,
    <span class="string">"npm run typecheck passes"</span>
  ],
  <span class="string">"passes"</span>: <span class="keyword">false</span>
}</pre>
          </div>

          <div class="arch-diagram">Ralph Iteration
    |
    +-- Implement database change
    +-- Run migration
    |
    +-- MCP SQLite/Postgres --&gt; Verify data state
    |
    +-- Tests pass --&gt; Commit</div>
        </div>

        <!-- Ralph + Claude-Mem -->
        <div class="combo-card" id="ralph-claude-mem">
          <div class="combo-header">
            <span class="combo-pattern">Ralph</span>
            <span class="combo-plus">+</span>
            <span class="combo-pattern">Claude-Mem</span>
            <span class="combo-roi high">High ROI</span>
          </div>
          <div class="combo-enables">
            <strong>What It Enables:</strong> Semantic memory augments file-based memory. Avoid repeating mistakes from previous sessions (not just iterations). Pattern recognition across projects.
          </div>

          <div class="code-block">
            <button class="copy-btn" onclick="copyCodeBlock(this)">
              <i data-lucide="copy" class="w-3 h-3"></i>
              Copy
            </button>
            <pre><span class="comment"># Before each Ralph iteration, inject relevant memories</span>
claude <span class="string">"Load relevant context from memory for authentication patterns, then: $(cat prompt.md)"</span></pre>
          </div>

          <div class="arch-diagram">Claude-Mem (Background Service)
    |
    +-- Captures: All tool calls, decisions, patterns
    +-- Stores: SQLite + Chroma Vector DB
           |
           v
Ralph Loop (Iteration N)
    |
    +-- Query: "Authentication patterns from last week"
    +-- Inject: Relevant memories into context
    +-- Execute: Current story with enriched context
    +-- Log: New learnings back to Claude-Mem</div>

          <p class="text-text-secondary">
            <strong>Avoids Dead Ends:</strong> Memory surfaces "Last time this approach failed because..." - reducing iteration count by learning from past sessions.
          </p>
        </div>

        <!-- Ralph + HUD -->
        <div class="combo-card" id="ralph-hud">
          <div class="combo-header">
            <span class="combo-pattern">Ralph</span>
            <span class="combo-plus">+</span>
            <span class="combo-pattern">Claude HUD</span>
            <span class="combo-roi high">Medium-High ROI</span>
          </div>
          <div class="combo-enables">
            <strong>What It Enables:</strong> Real-time visibility into Ralph's progress. Context usage tracking prevents overflow mid-story. Early warning when iteration is going wrong.
          </div>

          <div class="code-block">
            <button class="copy-btn" onclick="copyCodeBlock(this)">
              <i data-lucide="copy" class="w-3 h-3"></i>
              Copy
            </button>
            <pre><span class="comment"># Terminal 1: Run Ralph</span>
./ralph.sh 25

<span class="comment"># Terminal 2 (visible): HUD shows</span>
[Opus 4.5] ████████░░ 35% | 1 MCPs | 5m
✓ Read x4 | ✓ Edit x2 | ⟳ Bash (npm test)
Todo: 3/7 complete</pre>
          </div>

          <p class="text-text-secondary">
            <strong>Key Insight:</strong> If context hits 80%+ before story complete, the story is too big - split it.
          </p>
        </div>
      </section>

      <!-- Section 4: ORCHESTRATION + VERIFICATION -->
      <section id="orch-verify" data-activity="orch-verify">
        <h2 class="section-title">
          <span class="section-number">4</span>
          Orchestration + Verification Combinations
        </h2>

        <p class="text-text-secondary mb-6">
          Multi-agent orchestration patterns need verification and isolation mechanisms to prevent chaos.
        </p>

        <!-- CC Mirror + Hooks -->
        <div class="combo-card" id="ccmirror-hooks">
          <div class="combo-header">
            <span class="combo-pattern">CC Mirror</span>
            <span class="combo-plus">+</span>
            <span class="combo-pattern">Hooks</span>
            <span class="combo-roi high">High ROI</span>
          </div>
          <div class="combo-enables">
            <strong>What It Enables:</strong> PostToolUse hooks enforce formatting on ALL agent outputs. PreToolUse hooks can block dangerous operations. Multi-agent work stays consistent.
          </div>

          <div class="code-block">
            <button class="copy-btn" onclick="copyCodeBlock(this)">
              <i data-lucide="copy" class="w-3 h-3"></i>
              Copy
            </button>
            <pre><span class="comment">// ~/.claude/settings.json</span>
{
  <span class="string">"hooks"</span>: {
    <span class="string">"PostToolUse"</span>: [
      {
        <span class="string">"matcher"</span>: <span class="string">"Edit"</span>,
        <span class="string">"hooks"</span>: [{ <span class="string">"type"</span>: <span class="string">"command"</span>, <span class="string">"command"</span>: <span class="string">"prettier --write $FILE"</span> }]
      }
    ],
    <span class="string">"PreToolUse"</span>: [
      {
        <span class="string">"matcher"</span>: <span class="string">"Bash"</span>,
        <span class="string">"hooks"</span>: [{ <span class="string">"type"</span>: <span class="string">"command"</span>, <span class="string">"command"</span>: <span class="string">"~/.claude/hooks/security-gate.sh"</span> }]
      }
    ]
  }
}</pre>
          </div>

          <div class="arch-diagram">CC Mirror Orchestrator
    |
    +-- Spawns Worker Agent 1 --&gt; Edits file.ts
    |                              |
    |                              +-- PostToolUse Hook: prettier --write
    |
    +-- Spawns Worker Agent 2 --&gt; Edits file.py
    |                              |
    |                              +-- PostToolUse Hook: black --quiet
    |
    +-- All outputs consistently formatted</div>
        </div>

        <!-- Subagents + Worktrees -->
        <div class="combo-card" id="subagents-worktrees">
          <div class="combo-header">
            <span class="combo-pattern">Subagents</span>
            <span class="combo-plus">+</span>
            <span class="combo-pattern">Git Worktrees</span>
            <span class="combo-roi very-high">Very High ROI</span>
          </div>
          <div class="combo-enables">
            <strong>What It Enables:</strong> True isolation: Each agent works in separate worktree. No file conflicts between parallel agents. Git-based coordination (shared history, separate working copies).
          </div>

          <div class="code-block">
            <button class="copy-btn" onclick="copyCodeBlock(this)">
              <i data-lucide="copy" class="w-3 h-3"></i>
              Copy
            </button>
            <pre><span class="comment"># Spawn isolated agent in worktree</span>
spawn_isolated_agent() {
  <span class="keyword">local</span> task_id=$1
  <span class="keyword">local</span> branch=<span class="string">"agent-$task_id"</span>

  git worktree add ../worktrees/$branch -b $branch
  (cd ../worktrees/$branch &amp;&amp; claude <span class="string">"Implement feature X"</span>) &amp;
}

<span class="comment"># Merge results</span>
merge_agent_work() {
  <span class="keyword">local</span> branch=$1
  git merge ../worktrees/$branch
  git worktree remove ../worktrees/$branch
}</pre>
          </div>

          <div class="arch-diagram">Main Repo (.git/)
    |
    +-- Worktree A (/auth-agent/)
    |   +-- Agent 1: Implements auth
    |
    +-- Worktree B (/payment-agent/)
    |   +-- Agent 2: Implements payments
    |
    +-- Worktree C (/ui-agent/)
        +-- Agent 3: Implements UI

All share git history, no conflicts during work.
Human merges at end.</div>
        </div>

        <!-- Gas Town + Beads -->
        <div class="combo-card" id="gastown-beads">
          <div class="combo-header">
            <span class="combo-pattern">Gas Town</span>
            <span class="combo-plus">+</span>
            <span class="combo-pattern">Beads</span>
            <span class="combo-roi very-high">Very High ROI (at scale)</span>
          </div>
          <div class="combo-enables">
            <strong>What It Enables:</strong> Git-backed data storage for all agents. Universal context management across many agents. No external database needed - everything in git.
          </div>

          <div class="code-block">
            <button class="copy-btn" onclick="copyCodeBlock(this)">
              <i data-lucide="copy" class="w-3 h-3"></i>
              Copy
            </button>
            <pre><span class="comment"># Gas Town uses Beads for storage</span>
gt init  <span class="comment"># Creates ~/.gt with Beads integration</span>
gt rig add /path/to/project

<span class="comment"># Agents access shared context via Beads</span>
<span class="comment"># All state persisted in git</span></pre>
          </div>

          <div class="arch-diagram">Gas Town (Orchestrator)
    |
    +-- Mayor (coordination)
    +-- Deacon (monitoring)
    +-- Refinery (task decomposition)
    |
    +-- All backed by Beads --&gt; Git-based data plane
                               ~225K lines of Go
                               Universal context</div>
        </div>
      </section>

      <!-- Section 5: MEMORY + LEARNING -->
      <section id="memory-learning" data-activity="memory-learning">
        <h2 class="section-title">
          <span class="section-number">5</span>
          Memory + Learning Combinations
        </h2>

        <p class="text-text-secondary mb-6">
          Memory patterns compound when combined properly. Short-term + long-term. Structured + semantic.
        </p>

        <!-- progress.txt + AGENTS.md -->
        <div class="combo-card" id="progress-agents">
          <div class="combo-header">
            <span class="combo-pattern">progress.txt</span>
            <span class="combo-plus">+</span>
            <span class="combo-pattern">AGENTS.md</span>
            <span class="combo-roi very-high">Very High ROI</span>
          </div>
          <div class="combo-enables">
            <strong>What It Enables:</strong> Short-term memory (progress.txt) informs current session. Long-term memory (AGENTS.md) compounds across all sessions. Patterns discovered in iteration 3 help iteration 13.
          </div>

          <div class="code-block">
            <button class="copy-btn" onclick="copyCodeBlock(this)">
              <i data-lucide="copy" class="w-3 h-3"></i>
              Copy
            </button>
            <pre><span class="comment"># progress.txt (ephemeral, session-scoped)</span>
## Codebase Patterns
- Migrations: Use IF NOT EXISTS
- React: useRef&lt;Timeout | null&gt;(null)

## 2026-01-09 - US-003
- Implemented auth middleware
- Learned: Always check token expiry

<span class="comment">---</span>

<span class="comment"># AGENTS.md (permanent, in repo)</span>
## Authentication Module
When modifying auth:
- Tokens expire after 24h
- Refresh tokens in separate table
- Always hash with bcrypt, never SHA</pre>
          </div>

          <div class="arch-diagram">Compounding Effect:

Iteration 1: Learns migration pattern
  --&gt; Appends to progress.txt

Iteration 5: Reads pattern, avoids mistake
  --&gt; Updates AGENTS.md with key insight

Future Session: Agent reads AGENTS.md
  --&gt; Applies learning immediately</div>
        </div>

        <!-- Git + Claude-Mem -->
        <div class="combo-card" id="git-claude-mem">
          <div class="combo-header">
            <span class="combo-pattern">Git History</span>
            <span class="combo-plus">+</span>
            <span class="combo-pattern">Claude-Mem</span>
            <span class="combo-roi high">High ROI</span>
          </div>
          <div class="combo-enables">
            <strong>What It Enables:</strong> Structured memory (git) + semantic memory (Claude-Mem). "Why did we change this file?" becomes queryable. Debug by asking "What happened to auth last week?"
          </div>

          <div class="code-block">
            <button class="copy-btn" onclick="copyCodeBlock(this)">
              <i data-lucide="copy" class="w-3 h-3"></i>
              Copy
            </button>
            <pre><span class="comment"># Git provides structured history</span>
git log --oneline --since=<span class="string">"1 week ago"</span> -- src/auth/

<span class="comment"># Claude-Mem provides semantic recall</span>
claude <span class="string">"Search memory for: authentication changes reasoning"</span></pre>
          </div>

          <div class="arch-diagram">Git History
    |
    +-- Commit: "feat: add JWT refresh"
    +-- Commit: "fix: token expiry bug"
    +-- Structured, exact, searchable
           |
           v
Claude-Mem Vector DB
    |
    +-- Observation: "Refresh tokens needed because..."
    +-- Pattern: "Always verify token in middleware"
    +-- Semantic, fuzzy, contextual</div>
        </div>
      </section>

      <!-- Section 6: SYNERGY MATRIX -->
      <section id="synergies" data-activity="synergies">
        <h2 class="section-title">
          <span class="section-number">6</span>
          Synergy Categories
        </h2>

        <p class="text-text-secondary mb-6">
          Not all combinations are equal. Understanding synergy type helps you prioritize.
        </p>

        <div class="synergy-category" id="synergy-categories">
          <div class="synergy-title">Multiplicative Synergies (1+1 = 5)</div>
          <div class="synergy-desc">These combinations create capabilities neither pattern has alone:</div>
          <ul class="synergy-items list-disc pl-5">
            <li><strong>Ralph + Playwright</strong> - Verification impossible without browser, persistence impossible without Ralph</li>
            <li><strong>Worktrees + Subagents</strong> - Isolation impossible without worktrees, parallelism impossible without subagents</li>
            <li><strong>progress.txt + AGENTS.md</strong> - Short-term learning useless without long-term, long-term empty without short-term</li>
          </ul>
        </div>

        <div class="synergy-category additive">
          <div class="synergy-title">Additive Synergies (1+1 = 2)</div>
          <div class="synergy-desc">These combinations improve both patterns but don't create new capabilities:</div>
          <ul class="synergy-items list-disc pl-5">
            <li><strong>Claude HUD + Ralph</strong> - Both work alone, together they're better</li>
            <li><strong>Hooks + CC Mirror</strong> - Hooks work anywhere, CC Mirror works without hooks</li>
            <li><strong>Mobile + Poke</strong> - Both solve problems independently, together they're seamless</li>
          </ul>
        </div>

        <div class="synergy-category enabling">
          <div class="synergy-title">Enabling Synergies (1+0 = 1)</div>
          <div class="synergy-desc">One pattern enables the other to function:</div>
          <ul class="synergy-items list-disc pl-5">
            <li><strong>tmux + rpai</strong> - rpai requires tmux to function</li>
            <li><strong>Git + Claude-Mem</strong> - Both need history, but can work independently</li>
            <li><strong>MCP + Any Workflow</strong> - MCP enables tool access, workflows use it</li>
          </ul>
        </div>

        <!-- High Impact Table -->
        <h3 class="font-semibold text-lg mb-4 mt-8" id="high-impact">High-Impact Pairings</h3>

        <table class="matrix-table">
          <thead>
            <tr>
              <th>Pattern A</th>
              <th>Pattern B</th>
              <th>Combined Result</th>
              <th>ROI</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Ralph</td>
              <td>Playwright</td>
              <td>Verified UI loops</td>
              <td><span class="combo-roi very-high">Very High</span></td>
            </tr>
            <tr>
              <td>Ralph</td>
              <td>Claude-Mem</td>
              <td>Cross-session learning</td>
              <td><span class="combo-roi high">High</span></td>
            </tr>
            <tr>
              <td>CC Mirror</td>
              <td>Hooks</td>
              <td>Quality gates for all agents</td>
              <td><span class="combo-roi high">High</span></td>
            </tr>
            <tr>
              <td>Subagents</td>
              <td>Worktrees</td>
              <td>True parallel isolation</td>
              <td><span class="combo-roi very-high">Very High</span></td>
            </tr>
            <tr>
              <td>progress.txt</td>
              <td>AGENTS.md</td>
              <td>Short + long-term memory</td>
              <td><span class="combo-roi very-high">Very High</span></td>
            </tr>
            <tr>
              <td>Mobile</td>
              <td>Poke Hooks</td>
              <td>Async development</td>
              <td><span class="combo-roi very-high">Very High</span></td>
            </tr>
            <tr>
              <td>Panopticon</td>
              <td>Cron</td>
              <td>Continuous automation</td>
              <td><span class="combo-roi very-high">Very High</span></td>
            </tr>
            <tr>
              <td>Planning</td>
              <td>Model Selection</td>
              <td>Cost-optimized quality</td>
              <td><span class="combo-roi very-high">Very High</span></td>
            </tr>
          </tbody>
        </table>
      </section>

      <!-- Section 7: GOTCHAS -->
      <section id="gotchas" data-activity="gotchas">
        <h2 class="section-title">
          <span class="section-number">7</span>
          Gotchas
        </h2>

        <p class="text-text-secondary mb-6">
          Real problems with pattern combinations, with concrete fixes:
        </p>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Ralph + Playwright Screenshots Not Verifying
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Ralph loop claims UI verification passed, but screenshots show broken layouts.</div>
          <div class="gotcha-detail"><strong>Cause:</strong> Playwright taking screenshots before page fully renders, or verification prompt not specific enough.</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Add explicit wait conditions before screenshots. Make acceptance criteria more specific: "Screenshot shows button with text 'Submit' at y &lt; 500px"</div>
        </div>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Claude-Mem Injecting Irrelevant Context
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Ralph iterations receive memories from unrelated past sessions, wasting context tokens.</div>
          <div class="gotcha-detail"><strong>Cause:</strong> Claude-Mem's semantic search matching on general terms, not specific story/task.</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Query with story ID explicitly: <code>search(query="US-003 authentication", type="pattern")</code>. Tag memories with project identifiers during capture.</div>
        </div>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Worktree Subagents Diverging Too Far
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> When merging worktree branches back to main, conflicts are massive because agents made incompatible architectural decisions.</div>
          <div class="gotcha-detail"><strong>Cause:</strong> Agents worked in isolation without shared architectural constraints.</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Create shared AGENTS.md with architectural rules all worktrees read. Use periodic "sync points" where agents check in before major decisions.</div>
        </div>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            progress.txt + AGENTS.md Getting Out of Sync
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Learnings in progress.txt contradict guidance in AGENTS.md, causing inconsistent agent behavior.</div>
          <div class="gotcha-detail"><strong>Cause:</strong> progress.txt is append-only and may contain outdated patterns that were later refined.</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Periodically distill progress.txt into AGENTS.md (human-in-loop). Use clear sections in AGENTS.md that override progress.txt.</div>
        </div>
      </section>

      <!-- Section 8: ANTI-PATTERNS -->
      <section id="anti-patterns" data-activity="anti-patterns">
        <h2 class="section-title">
          <span class="section-number">8</span>
          Anti-Patterns to Avoid
        </h2>

        <p class="text-text-secondary mb-6">
          These combinations look reasonable but conflict fundamentally:
        </p>

        <div class="hard-box">
          <div class="hard-title">
            <i data-lucide="flame" class="w-4 h-4"></i>
            Ralph (fresh context) + Large shared context
          </div>
          <div class="hard-detail"><strong>Why It Fails:</strong> Ralph's power IS the fresh context. Loading large shared context defeats the entire purpose. You're paying the cost of restarts without the benefit of fresh context.</div>
        </div>

        <div class="hard-box">
          <div class="hard-title">
            <i data-lucide="flame" class="w-4 h-4"></i>
            Parallel agents + Single branch
          </div>
          <div class="hard-detail"><strong>Why It Fails:</strong> Merge conflicts are inevitable. Agents overwrite each other's work. What looks like progress becomes regression. Use worktrees for true isolation.</div>
        </div>

        <div class="hard-box">
          <div class="hard-title">
            <i data-lucide="flame" class="w-4 h-4"></i>
            Heavy MCP tools + Main context
          </div>
          <div class="hard-detail"><strong>Why It Fails:</strong> Token explosion. Browser context, database queries, API responses all consume tokens. Put heavy tools in subagents to protect main context.</div>
        </div>

        <div class="hard-box">
          <div class="hard-title">
            <i data-lucide="flame" class="w-4 h-4"></i>
            Many Opus subagents + Cost constraints
          </div>
          <div class="hard-detail"><strong>Why It Fails:</strong> Budget blown in minutes. Opus is powerful but expensive. Use Sonnet for implementation, Opus only for planning. Use model selection deliberately.</div>
        </div>

        <h3 class="font-semibold text-lg mb-4 mt-8">Overhead Traps</h3>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Too Many Monitoring Tools
          </div>
          <div class="gotcha-detail">rpai + HUD + custom logging = more monitoring than work. Pick ONE primary visibility tool.</div>
        </div>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Over-Orchestration
          </div>
          <div class="gotcha-detail">CC Mirror + Gas Town + custom coordinator = chaos. Don't stack orchestration patterns. Pick the one that matches your scale.</div>
        </div>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Memory Overload
          </div>
          <div class="gotcha-detail">Claude-Mem + progress.txt + AGENTS.md + git notes = context bloat. Memory systems should complement, not compete.</div>
        </div>
      </section>

      <!-- Section 9: WHEN TO COMBINE -->
      <section id="when" data-activity="when">
        <h2 class="section-title">
          <span class="section-number">9</span>
          When to Combine / When Not
        </h2>

        <div class="when-grid">
          <div class="when-use">
            <div class="when-title">
              <i data-lucide="check" class="w-5 h-5"></i>
              COMBINE PATTERNS WHEN
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>Each pattern solves a different problem (no overlap)</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>Combined capability is genuinely needed (not hypothetical)</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>You understand both patterns individually first</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>The combination unlocks multiplicative value (not just additive)</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>You have verified the basic pattern works in your environment</span>
            </div>
          </div>

          <div class="when-not">
            <div class="when-title">
              <i data-lucide="x" class="w-5 h-5"></i>
              DON'T COMBINE WHEN
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>You haven't mastered the base patterns yet</span>
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>Patterns have conflicting philosophies (fresh vs. extended context)</span>
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>Overhead of combination exceeds benefit</span>
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>You're optimizing for hypothetical future scale</span>
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>A single pattern would solve your actual problem</span>
            </div>
          </div>
        </div>

        <h3 class="font-semibold text-lg mb-4">Implementation Priority</h3>

        <div class="path-container">
          <div class="path-step">
            <div class="path-number">1</div>
            <div class="path-content"><strong>Start Here (Quick Wins):</strong> Hooks + Auto-Formatting (5 minutes), Claude HUD (5 minutes), Sub-Agents Directory (browse and copy)</div>
          </div>
          <div class="path-step">
            <div class="path-number">2</div>
            <div class="path-content"><strong>Build Foundation:</strong> Ralph + progress.txt + AGENTS.md, Mobile + Poke Hooks, Worktrees + Basic Subagents</div>
          </div>
          <div class="path-step">
            <div class="path-number">3</div>
            <div class="path-content"><strong>Scale Up:</strong> CC Mirror Full Orchestration, Panopticon Architecture, Gas Town (when you need factory-scale)</div>
          </div>
        </div>
      </section>

    