<!--
═══════════════════════════════════════════════════════════════════════════════
INLINE THREADING HEADER — Phase 2B
File: docs-spa/content/pages/mastery-ccmirror-complete/content.html
Tier: C | Batch: 12 | Generated: 2026-02-06

1. WHY THIS EXISTS
Rendered HTML content page for the mastery-ccmirror-complete synthesis document.

3. STATUS
ACTIVE

5. BUILT ON
Extracted from synthesis/mastery-ccmirror-complete.md by content extraction scripts.

8. CONSUMED BY
docs-spa/app/(docs)/synthesis/mastery-ccmirror-complete/page.tsx renders this content via dangerouslySetInnerHTML.

═══════════════════════════════════════════════════════════════════════════════
END INLINE THREADING HEADER
═══════════════════════════════════════════════════════════════════════════════
-->

      <!-- Section 1: ESSENCE -->
      <section id="essence" data-activity="essence">
        <div class="essence-box">
          <div class="essence-label">Essence (15 words)</div>
          <div class="essence-text">CC Mirror unlocks Claude Code's hidden multi-agent orchestration: parallel workers, task dependencies, zero infrastructure.</div>
        </div>
      </section>

      <!-- Section 2: CORE ABSTRACTION + IMPLEMENTATION -->
      <section id="core-abstraction" data-activity="core">
        <h2 class="section-title">
          <span class="section-number">2</span>
          The Core Abstraction
        </h2>

        <div class="core-abstraction">
          <div class="core-philosophy">"Anthropic built multi-agent orchestration into Claude Code. They just disabled it."</div>

          <div class="core-code">
            <button class="copy-btn" onclick="copyCode(this, 'npx cc-mirror quick --provider mirror --name mclaude')">
              <i data-lucide="copy" class="w-3 h-3"></i>
              Copy
            </button>
            <code>npx cc-mirror quick --provider mirror --name mclaude</code>
          </div>

          <div class="core-anchor">That's the unlock. 3 commands to multi-agent orchestration.</div>
        </div>

        <p class="text-text-secondary mb-6">
          Numman Ali reverse-engineered Claude Code's minified JavaScript and discovered a complete multi-agent system: <code class="bg-bg-muted px-2 py-1 rounded text-sm">TaskCreate</code>, <code class="bg-bg-muted px-2 py-1 rounded text-sm">TaskList</code>, <code class="bg-bg-muted px-2 py-1 rounded text-sm">TaskUpdate</code>, <code class="bg-bg-muted px-2 py-1 rounded text-sm">TaskGet</code>. Dependencies with <code class="bg-bg-muted px-2 py-1 rounded text-sm">blocks</code>/<code class="bg-bg-muted px-2 py-1 rounded text-sm">blockedBy</code>. All built, all disabled.
        </p>

        <p class="text-text-secondary mb-6">
          CC Mirror patches the binary, creates isolated variants, and injects the orchestration skill. The result: native multi-agent coordination without external frameworks, custom infrastructure, or complex setup.
        </p>

        <div class="iron-law-box" id="iron-law">
          <div class="iron-law-title">
            <i data-lucide="shield-alert" class="w-5 h-5"></i>
            The Iron Law
          </div>
          <div class="iron-law-text">
            YOU DO NOT WRITE CODE. YOU DO NOT RUN COMMANDS. YOU DO NOT EXPLORE CODEBASES.
            <br><br>
            You are the CONDUCTOR. Your agents play the instruments.
          </div>
        </div>

        <p class="text-text-secondary mb-6">
          Violating the Iron Law causes context pollution (orchestrator loses strategic view), verification bypass (same agent writes and approves), and uncontrolled recursion (workers spawning workers). The orchestrator coordinates. Workers execute. Never mix.
        </p>
      </section>

      <!-- Section 3: DESIGN DECISIONS -->
      <section id="why-hub-spoke" data-activity="decisions">
        <h2 class="section-title">
          <span class="section-number">3</span>
          Design Decisions
        </h2>

        <div class="decision-box">
          <div class="decision-why">WHY HUB-AND-SPOKE?</div>
          <div class="decision-reasoning">
            A central orchestrator coordinates specialized workers because someone needs to maintain the task graph, track dependencies, and prevent chaos. Peer-to-peer would require consensus protocols. Hub-and-spoke is simple and predictable.
          </div>
          <div class="decision-implication">
            <div class="decision-implication-label">What this means for you</div>
            <div class="text-text-secondary text-sm">
              The orchestrator is your single point of control. It reads 1-2 files max, spawns workers, collects results. If you find the orchestrator doing implementation work, you're violating the Iron Law.
            </div>
          </div>
        </div>

        <div class="decision-box" id="why-task-api">
          <div class="decision-why">WHY TASK API (NOT CUSTOM STATE)?</div>
          <div class="decision-reasoning">
            Anthropic already built <code>TaskCreate</code>, <code>TaskUpdate</code>, <code>TaskGet</code>, <code>TaskList</code> with dependency management (<code>blocks</code>/<code>blockedBy</code>). Why recreate what exists? The hidden API handles ownership, blocking, and team visibility natively.
          </div>
          <div class="decision-implication">
            <div class="decision-implication-label">What this means for you</div>
            <div class="text-text-secondary text-sm">
              Use the Task API for everything. Don't build custom state machines. When you mark Task A as blocking Task B, the system automatically prevents B from being claimed until A resolves.
            </div>
          </div>
        </div>

        <div class="decision-box" id="why-worker-isolation">
          <div class="decision-why">WHY WORKER ISOLATION?</div>
          <div class="decision-reasoning">
            Each worker gets a fresh context. No shared memory between workers. This prevents context pollution: Worker A's debugging doesn't pollute Worker B's clean implementation context.
          </div>
          <div class="decision-implication">
            <div class="decision-implication-label">What this means for you</div>
            <div class="text-text-secondary text-sm">
              Workers communicate through files, not shared state. If workers need to share information, write to a file. The filesystem is your inter-agent memory.
            </div>
          </div>
        </div>
      </section>

      <!-- Section 4: ARCHITECTURE -->
      <section id="architecture" data-activity="architecture">
        <h2 class="section-title">
          <span class="section-number">4</span>
          Architecture
        </h2>

        <div class="architecture-diagram">
          <div class="diagram-title">Hub-and-Spoke Model</div>
          <div class="diagram-content">              +------------------+
              |   ORCHESTRATOR   |
              |   (Conductor)    |
              +--------+---------+
                       |
                       | Task() with run_in_background=True
                       |
       +---------------+---------------+
       |               |               |
       v               v               v
  +---------+   +---------+   +---------+
  | Worker1 |   | Worker2 |   | Worker3 |
  | (Coder) |   | (Tester)|   | (Docs)  |
  +---------+   +---------+   +---------+
        |             |             |
        +-------------+-------------+
                      |
               Shared Filesystem
               (handoff files)</div>
        </div>

        <h3 class="font-semibold text-lg mb-4" id="coordination-patterns">Coordination Patterns</h3>

        <p class="text-text-secondary mb-4">
          CC Mirror supports three coordination patterns, each suited to different task shapes:
        </p>

        <div class="mb-6">
          <h4 class="font-semibold text-md mb-2 text-accent">Pattern 1: Fan-Out (Parallel Dispatch)</h4>
          <p class="text-text-secondary text-sm mb-3">
            Multiple workers receive independent tasks simultaneously. No dependencies between them.
          </p>
          <div class="code-block">
            <pre><span class="comment"># Orchestrator spawns 3 workers in parallel</span>
TaskCreate: <span class="string">"Design API architecture"</span> (no blockers)
TaskCreate: <span class="string">"Create project structure"</span> (no blockers)
TaskCreate: <span class="string">"Write README"</span> (no blockers)

<span class="comment"># All three run simultaneously</span>
Worker A -&gt; claims and executes #1
Worker B -&gt; claims and executes #2
Worker C -&gt; claims and executes #3</pre>
          </div>
        </div>

        <div class="mb-6">
          <h4 class="font-semibold text-md mb-2 text-accent">Pattern 2: Pipeline (Sequential Handoffs)</h4>
          <p class="text-text-secondary text-sm mb-3">
            Tasks with explicit dependencies flow sequentially. Each task unlocks the next.
          </p>
          <div class="code-block">
            <pre>TaskCreate: <span class="string">"Design data models"</span> (P1, no deps)
TaskCreate: <span class="string">"Implement API endpoints"</span> (P2, blockedBy: P1)
TaskCreate: <span class="string">"Write integration tests"</span> (P3, blockedBy: P2)

<span class="comment"># Automatic dependency resolution</span>
Worker A completes P1 -&gt; P2 becomes claimable
Worker B completes P2 -&gt; P3 becomes claimable</pre>
          </div>
        </div>

        <div class="mb-6">
          <h4 class="font-semibold text-md mb-2 text-accent">Pattern 3: Map-Reduce (Parallel + Aggregation)</h4>
          <p class="text-text-secondary text-sm mb-3">
            Fan-out work, collect results, synthesize. The orchestrator aggregates worker outputs.
          </p>
          <div class="code-block">
            <pre><span class="comment"># MAP PHASE: Parallel research</span>
TaskCreate: <span class="string">"Research auth libraries"</span>
TaskCreate: <span class="string">"Research payment APIs"</span>
TaskCreate: <span class="string">"Research database options"</span>

<span class="comment"># Workers complete in parallel, write findings to files</span>

<span class="comment"># REDUCE PHASE: Orchestrator synthesizes</span>
Read all research outputs
Make architectural decision
TaskCreate: <span class="string">"Implement chosen stack"</span></pre>
          </div>
        </div>
      </section>

      <!-- Section 5: IMPLEMENTATION -->
      <section id="quick-start" data-activity="implementation">
        <h2 class="section-title">
          <span class="section-number">5</span>
          Implementation
        </h2>

        <h3 class="font-semibold text-lg mb-4">Quick Start (3 Commands)</h3>

        <div class="code-block">
          <button class="copy-btn" onclick="copyCodeBlock(this)">
            <i data-lucide="copy" class="w-3 h-3"></i>
            Copy
          </button>
          <pre><span class="comment"># Step 1: Create isolated variant</span>
npx cc-mirror quick --provider mirror --name mclaude

<span class="comment"># Step 2: Launch it</span>
mclaude

<span class="comment"># Step 3: In the terminal</span>
<span class="string">"Load the orchestration skill and initiate"</span></pre>
        </div>

        <h3 class="font-semibold text-lg mb-4 mt-8" id="task-api">Task API Reference</h3>

        <div class="code-block">
          <pre><span class="comment"># TaskCreate - Create with subject, description, acceptance criteria</span>
{
  <span class="string">"subject"</span>: <span class="string">"Implement authentication middleware"</span>,
  <span class="string">"description"</span>: <span class="string">"Create Express middleware for JWT verification"</span>,
  <span class="string">"acceptanceCriteria"</span>: [
    <span class="string">"Middleware validates JWT signature"</span>,
    <span class="string">"Returns 401 on invalid/expired token"</span>,
    <span class="string">"npm run typecheck passes"</span>
  ],
  <span class="string">"priority"</span>: 1,
  <span class="string">"blockedBy"</span>: [<span class="string">"task-id-001"</span>],
  <span class="string">"blocks"</span>: [<span class="string">"task-id-003"</span>]
}

<span class="comment"># TaskList - Filter: status='open', no owner, not blocked</span>
<span class="comment"># TaskGet - Full context: description, comments, dependencies</span>
<span class="comment"># TaskUpdate - Claim (set owner), add comments, resolve, link references</span></pre>
        </div>

        <h3 class="font-semibold text-lg mb-4 mt-8">Tool Ownership Division</h3>

        <div class="tool-grid">
          <div class="tool-card orchestrator">
            <div class="tool-card-title">Orchestrator Uses Directly</div>
            <div class="tool-list">
              <code>Read</code> (1-2 files max)<br>
              <code>TaskCreate</code>, <code>TaskUpdate</code>, <code>TaskGet</code>, <code>TaskList</code><br>
              <code>AskUserQuestion</code><br>
              <code>Task</code> (to spawn workers)
            </div>
          </div>
          <div class="tool-card worker">
            <div class="tool-card-title">Workers Use Directly</div>
            <div class="tool-list">
              <code>Read</code>, <code>Write</code>, <code>Edit</code>, <code>Bash</code><br>
              <code>Glob</code>, <code>Grep</code>, <code>WebFetch</code>, <code>WebSearch</code><br>
              <strong>PROHIBITED:</strong> <code>Task*</code>, spawn sub-agents
            </div>
          </div>
        </div>

        <p class="text-text-secondary text-sm mb-6">
          <strong>Delegation threshold:</strong> If the orchestrator needs to read more than 2 files, spawn a worker instead.
        </p>

        <h3 class="font-semibold text-lg mb-4 mt-8">Model Selection by Task Complexity</h3>

        <div class="model-cards">
          <div class="model-card">
            <div class="model-card-title">Haiku</div>
            <div class="model-card-desc">Errand runner: fetch files, grep, simple lookups</div>
            <div class="model-card-count">5-10 in parallel</div>
          </div>
          <div class="model-card">
            <div class="model-card-title">Sonnet</div>
            <div class="model-card-desc">Capable worker: implementation, patterns, tests</div>
            <div class="model-card-count">2-5 in parallel</div>
          </div>
          <div class="model-card">
            <div class="model-card-title">Opus</div>
            <div class="model-card-desc">Complex reasoning: architecture, ambiguous tasks</div>
            <div class="model-card-count">1 (sequential)</div>
          </div>
        </div>

        <h3 class="font-semibold text-lg mb-4 mt-8" id="worker-preambles">Worker Preamble Template</h3>

        <div class="code-block">
          <button class="copy-btn" onclick="copyCodeBlock(this)">
            <i data-lucide="copy" class="w-3 h-3"></i>
            Copy
          </button>
          <pre>CONTEXT: You are a WORKER agent, not an orchestrator.

RULES:
- Complete ONLY the task described below
- Use tools directly (Read, Write, Edit, Bash, etc.)
- Do NOT spawn sub-agents
- Do NOT call TaskCreate or TaskUpdate
- Report your results with absolute file paths

TASK:
[Your specific task here]</pre>
        </div>
      </section>

      <!-- Section 6: PATH OF A TASK -->
      <section id="path" data-activity="path">
        <h2 class="section-title">
          <span class="section-number">6</span>
          The Path of a Task
        </h2>

        <p class="text-text-secondary mb-6">
          Follow a task through the CC Mirror system to see how the pieces connect:
        </p>

        <div class="path-container">
          <div class="path-step">
            <div class="path-number">1</div>
            <div class="path-content">User describes goal to orchestrator: <code>"Build auth for our API"</code></div>
          </div>
          <div class="path-step">
            <div class="path-number">2</div>
            <div class="path-content">Orchestrator decomposes into tasks with <code>TaskCreate</code>, setting dependencies</div>
          </div>
          <div class="path-step">
            <div class="path-number">3</div>
            <div class="path-content">Orchestrator spawns workers with <code>Task(run_in_background=True)</code></div>
          </div>
          <div class="path-step">
            <div class="path-number">4</div>
            <div class="path-content">Worker receives preamble + task, claims via <code>TaskUpdate(owner=agent_id)</code></div>
          </div>
          <div class="path-step">
            <div class="path-number">5</div>
            <div class="path-content">Worker executes using <code>Read</code>, <code>Write</code>, <code>Edit</code>, <code>Bash</code></div>
          </div>
          <div class="path-step">
            <div class="path-number">6</div>
            <div class="path-content">Worker runs verification (typecheck, tests) per acceptance criteria</div>
          </div>
          <div class="path-step">
            <div class="path-number">7</div>
            <div class="path-content">Worker marks task resolved, adds comments with findings</div>
          </div>
          <div class="path-step">
            <div class="path-number">8</div>
            <div class="path-content">System automatically unblocks dependent tasks</div>
          </div>
          <div class="path-step">
            <div class="path-number">9</div>
            <div class="path-content">Orchestrator receives completion signal, checks for next unblocked tasks</div>
          </div>
          <div class="path-step">
            <div class="path-number">10</div>
            <div class="path-content">Process repeats until all tasks resolved or failure escalated</div>
          </div>
        </div>
      </section>

      <!-- Section 7: GOTCHAS -->
      <section id="gotchas" data-activity="gotchas">
        <h2 class="section-title">
          <span class="section-number">7</span>
          Gotchas
        </h2>

        <p class="text-text-secondary mb-6">
          Real problems you'll hit with CC Mirror, with concrete fixes:
        </p>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Workers touching same files - conflicts
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Multiple workers modify same file. Edits overwrite each other.</div>
          <div class="gotcha-detail"><strong>Cause:</strong> Task decomposition didn't isolate file ownership.</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Add explicit file ownership to task descriptions: "Ownership: src/auth/*.ts. DO NOT MODIFY: src/components/*" Or use git worktrees for true isolation.</div>
        </div>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Context collapse - orchestrator degraded
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Orchestrator forgets task state. Makes inconsistent decisions. Quality drops.</div>
          <div class="gotcha-detail"><strong>Threshold:</strong> &gt;70% context usage, or 15+ workers spawned in session</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Enable auto-compact beta feature. Run <code>/compact</code> proactively. Monitor with <code>/context</code>.</div>
        </div>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            CC Mirror skill not loading
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> Claude says it doesn't know about orchestration features. TaskCreate not recognized.</div>
          <div class="gotcha-detail"><strong>Cause:</strong> <code>cc_mirror_mode: true</code> not set, or skill file not in correct location.</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Run <code>npx cc-mirror doctor</code>. Verify skill file exists at <code>~/.claude/skills/orchestration/</code>. Re-run quick install if needed.</div>
        </div>

        <div class="gotcha-box">
          <div class="gotcha-title">
            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
            Hidden API features disappeared after update
          </div>
          <div class="gotcha-detail"><strong>Symptom:</strong> CC Mirror was working, then Claude Code updated, now broken.</div>
          <div class="gotcha-detail"><strong>Cause:</strong> Anthropic changed minified JS. CC Mirror patch no longer applies.</div>
          <div class="gotcha-detail"><strong>Fix:</strong> Run <code>npx cc-mirror update</code>. Check GitHub issues. This is a beta feature - expect breakage on major Claude Code updates.</div>
        </div>
      </section>

      <!-- Section 8: WHAT'S HARD -->
      <section id="hard" data-activity="hard">
        <h2 class="section-title">
          <span class="section-number">8</span>
          What's Hard
        </h2>

        <p class="text-text-secondary mb-6">
          Fundamental tensions in CC Mirror, not bugs to fix:
        </p>

        <div class="hard-box">
          <div class="hard-title">
            <i data-lucide="flame" class="w-4 h-4"></i>
            Beta/Disabled Feature Risk
          </div>
          <div class="hard-detail"><strong>The tension:</strong> CC Mirror enables features Anthropic disabled. They may change or remove them without notice. Relying on reverse-engineered internals is inherently fragile.</div>
          <div class="hard-detail"><strong>Symptoms:</strong> Breaking changes on Claude Code updates. No official support. Community-dependent fixes.</div>
          <div class="hard-detail"><strong>Mitigation:</strong> Pin Claude Code versions for critical projects. Have fallback to standard Task() tool. Accept that production stability requires caution.</div>
        </div>

        <div class="hard-box">
          <div class="hard-title">
            <i data-lucide="flame" class="w-4 h-4"></i>
            Parallel Worker Coordination
          </div>
          <div class="hard-detail"><strong>The tension:</strong> Parallel agents cause merge conflicts. Same file modified by multiple workers. No built-in locking mechanism.</div>
          <div class="hard-detail"><strong>Symptoms:</strong> Corrupted output. Workers overwriting each other. Non-deterministic results.</div>
          <div class="hard-detail"><strong>Mitigation:</strong> Branch isolation (each agent on own branch, human merges). File-level assignment in task descriptions. Git worktrees for true parallel isolation. Or serialize agents per-file.</div>
        </div>

        <div class="hard-box">
          <div class="hard-title">
            <i data-lucide="flame" class="w-4 h-4"></i>
            Production Gaps
          </div>
          <div class="hard-detail"><strong>The tension:</strong> CC Mirror is "fine for demos/generic" but production needs: state control, business logic gates, custom observability, evals.</div>
          <div class="hard-detail"><strong>Symptoms:</strong> No cost tracking per task. No custom logging. No evaluation framework. No checkpointing/recovery.</div>
          <div class="hard-detail"><strong>Mitigation:</strong> Use for prototypes, personal projects, learning. For production, add custom instrumentation or use Gas Town for full control.</div>
        </div>
      </section>

      <!-- Section 9: WHEN TO USE -->
      <section id="when" data-activity="when">
        <h2 class="section-title">
          <span class="section-number">9</span>
          When to Use / When Not
        </h2>

        <div class="when-grid">
          <div class="when-use">
            <div class="when-title">
              <i data-lucide="check" class="w-5 h-5"></i>
              USE CC MIRROR WHEN
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>Tasks have clear decomposition (can split into independent units)</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>Need parallel execution with dependency ordering</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>Want quick setup without infrastructure (3 commands)</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>Projects benefit from task persistence across sessions</span>
            </div>
            <div class="when-item">
              <i data-lucide="check" class="w-4 h-4 flex-shrink-0"></i>
              <span>Budget allows for parallel workers (~80% of use cases)</span>
            </div>
          </div>

          <div class="when-not">
            <div class="when-title">
              <i data-lucide="x" class="w-5 h-5"></i>
              DON'T USE CC MIRROR WHEN
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>Need sequential iteration (overnight) -&gt; Use Ralph Loop</span>
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>Need 10+ named persistent agents -&gt; Use Gas Town</span>
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>Mission-critical production without fallbacks -&gt; Standard Task()</span>
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>Need custom observability/evals -&gt; Build custom or Gas Town</span>
            </div>
            <div class="when-item">
              <i data-lucide="x" class="w-4 h-4 flex-shrink-0"></i>
              <span>Not comfortable with beta features -&gt; Standard Claude Code</span>
            </div>
          </div>
        </div>

        <h3 class="font-semibold text-lg mb-4">Pattern Comparison</h3>

        <table class="comparison-table">
          <thead>
            <tr>
              <th>Aspect</th>
              <th>CC Mirror</th>
              <th>Ralph Loop</th>
              <th>Gas Town</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>Type</strong></td>
              <td>Multi-agent parallel</td>
              <td>Single-agent iterative</td>
              <td>Factory-scale orchestration</td>
            </tr>
            <tr>
              <td><strong>Setup Time</strong></td>
              <td>&lt;5 minutes</td>
              <td>&lt;10 minutes</td>
              <td>Hours+</td>
            </tr>
            <tr>
              <td><strong>Complexity</strong></td>
              <td>Low</td>
              <td>Low</td>
              <td>High (Stage 7+)</td>
            </tr>
            <tr>
              <td><strong>Use Cases</strong></td>
              <td>80% generic parallel</td>
              <td>Overnight features</td>
              <td>20% complex production</td>
            </tr>
            <tr>
              <td><strong>Dependencies</strong></td>
              <td>blocks/blockedBy native</td>
              <td>Manual ordering</td>
              <td>Inbox-based async</td>
            </tr>
            <tr>
              <td><strong>Persistence</strong></td>
              <td>Task-based (sessions)</td>
              <td>File-based (prd.json)</td>
              <td>Named agents (Polecats)</td>
            </tr>
          </tbody>
        </table>
      </section>

    