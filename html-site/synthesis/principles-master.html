<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Core Principles - Claude Code Knowledge Base</title>
  <link rel="stylesheet" href="../css/style.css">
</head>
<body>
  <div class="wide-container">
    <!-- Breadcrumb Navigation -->
    <nav class="nav-breadcrumb">
      <a href="../index.html">Home</a>
      <span>/</span>
      <a href="synthesis-index.html">Synthesis</a>
      <span>/</span>
      <span>Principles</span>
    </nav>

    <!-- You Are Here Context Box -->
    <div class="you-are-here" style="background: linear-gradient(135deg, #f0ebe3 0%, #fefcf3 100%); border-left: 4px solid #2a7d7d; border-radius: 8px; padding: 1.5rem; margin-bottom: 2rem;">
      <h3 style="color: #2a7d7d; margin-top: 0; font-size: 0.9em; text-transform: uppercase; letter-spacing: 0.5px;">You Are Here</h3>
      <p style="margin-bottom: 0;"><strong><span style="font-weight: 700;">Prin</span>ciples</strong> - The fundamental WHYs behind every pattern. Understanding these principles lets you derive new patterns for novel situations and diagnose failures when things go wrong.</p>
    </div>

    <h1><span style="font-weight: 700;">Core</span> Principles of Agent Engineering</h1>

    <p class="conversational-lead">
      These <strong>8 <span style="font-weight: 700;">prin</span>ciples</strong> are the bedrock from which all patterns derive. They explain <em>why</em> patterns work, not just <em>how</em> to implement them.
    </p>

    <!-- Table of Contents -->
    <div class="toc">
      <div class="toc-title">The Eight Principles</div>
      <ul>
        <li><a href="#core">Core Principles Overview</a></li>
        <li><a href="#p1">P1: Context Is The Primary Constraint</a></li>
        <li><a href="#p2">P2: External State > Internal Memory</a></li>
        <li><a href="#p3">P3: Fresh Context > Extended Sessions</a></li>
        <li><a href="#p4">P4: Separation of Concerns</a></li>
        <li><a href="#p5">P5: Atomic, Verifiable Tasks</a></li>
        <li><a href="#p6">P6: Quality Gates Before Commit</a></li>
        <li><a href="#p7">P7: Isolation Prevents Contamination</a></li>
        <li><a href="#p8">P8: Explicit Communication</a></li>
        <li><a href="#anti-patterns">Anti-Patterns</a></li>
        <li><a href="#derivation">Deriving New Patterns</a></li>
        <li><a href="#learning-loops">Learning Loops</a></li>
      </ul>
    </div>

    <hr class="section-divider">

    <!-- Core Section -->
    <section id="core">
      <h2>The <span style="font-weight: 700;">Prin</span>ciple Hierarchy</h2>

      <div class="ascii-diagram">
                    +------------------------------------+
                    |  PRINCIPLE 1: CONTEXT IS FINITE    |
                    |  (The Primary Constraint)          |
                    +------------------+-----------------+
                                       |
               Everything flows from this limitation
                                       |
        +------------------------------+------------------------------+
        |                              |                              |
        v                              v                              v
+-------------------+      +-------------------+      +-------------------+
| PRINCIPLE 2:      |      | PRINCIPLE 3:      |      | PRINCIPLE 4:      |
| External State    |      | Fresh Context     |      | Separation of     |
| > Internal Memory |      | > Extended        |      | Concerns          |
|                   |      |   Sessions        |      | (Orch/Worker)     |
+--------+----------+      +--------+----------+      +--------+----------+
         |                          |                          |
         +-------------+------------+--------------------------+
                       |
          +------------+------------+
          |                         |
          v                         v
+-------------------+     +-------------------+
| PRINCIPLE 5:      |     | PRINCIPLE 6:      |
| Atomic, Verifiable|     | Quality Gates     |
| Task Sizing       |     | Before Commit     |
+-------------------+     +-------------------+
      </div>
    </section>

    <hr class="section-divider">

    <!-- Principle 1 -->
    <section id="p1">
      <h2><span style="font-weight: 700;">P1:</span> Context Is The Primary Constraint</h2>

      <div class="problem-statement">
        LLMs degrade with filled context windows. This is not a minor inconvenience - it is THE fundamental constraint that shapes all agent engineering patterns.
      </div>

      <blockquote>
        "Context rot: LLMs get stupider with more tokens"<br>
        <cite>-- @mattpocockuk</cite>
      </blockquote>

      <h3>Implications</h3>
      <p>Every pattern, every tool, every workflow decision must answer: <strong>"How does this affect context consumption?"</strong></p>
      <ul>
        <li>If it consumes context, is the benefit worth it?</li>
        <li>If it persists across iterations, should it?</li>
        <li>If it compounds (grows over time), how do we bound it?</li>
      </ul>

      <h3>Derived Patterns</h3>
      <table>
        <thead><tr><th>Pattern</th><th>How It Addresses Context</th></tr></thead>
        <tbody>
          <tr><td>Ralph Loops (fresh context)</td><td>Kill and restart - zero accumulation</td></tr>
          <tr><td>File-based state</td><td>Externalize - don't store in context</td></tr>
          <tr><td>Git as memory</td><td>History lives outside context</td></tr>
          <tr><td>Subagent delegation</td><td>Expensive ops in isolated contexts</td></tr>
          <tr><td>.claudeignore</td><td>Prevent irrelevant files from loading</td></tr>
          <tr><td>CLAUDE.md brevity</td><td>Fixed context cost, minimize it</td></tr>
        </tbody>
      </table>
    </section>

    <hr class="section-divider">

    <!-- Principle 2 -->
    <section id="p2">
      <h2><span style="font-weight: 700;">P2:</span> External State > Internal Memory</h2>

      <div class="problem-statement">
        Sessions end. Context clears. Memory evaporates. Any information stored only in the LLM's context will be lost.
      </div>

      <p><strong>Therefore:</strong> All state that must persist beyond a single operation must be externalized to durable storage.</p>

      <div class="ascii-diagram">
+----------------------------------------------------------+
|                    THE AGENT                              |
|  +------------------------------------------------------+ |
|  |                CONTEXT WINDOW                         | |
|  |                                                       | |
|  |   [Ephemeral: dies when session ends]                | |
|  |   - Current reasoning                                | |
|  |   - Active task details                              | |
|  |   - Recent tool outputs                              | |
|  +------------------------------------------------------+ |
+----------------------------------------------------------+
                           |
                    Read   |   Write
                           v
+----------------------------------------------------------+
|                 EXTERNAL STATE                            |
|  +---------------+  +---------------+  +--------------+   |
|  |   FILESYSTEM  |  |      GIT      |  |  DATABASE    |   |
|  |               |  |               |  |              |   |
|  | progress.txt  |  | Commits       |  | claude-mem   |   |
|  | prd.json      |  | Branches      |  | SQLite       |   |
|  | CLAUDE.md     |  | History       |  | Checkpoints  |   |
|  +---------------+  +---------------+  +--------------+   |
|                                                           |
|  [Persistent: survives sessions, crashes, resets]         |
+----------------------------------------------------------+
      </div>

      <h3>The Three Core Files Pattern</h3>
      <table>
        <thead><tr><th>File</th><th>Purpose</th><th>Format</th><th>Rule</th></tr></thead>
        <tbody>
          <tr><td><code>progress.txt</code></td><td>Memory across iterations</td><td>Markdown</td><td>APPEND ONLY</td></tr>
          <tr><td><code>prd.json</code></td><td>Task state tracking</td><td>JSON</td><td>passes: true/false</td></tr>
          <tr><td><code>CLAUDE.md</code></td><td>Project context</td><td>Markdown</td><td>Under 500 tokens</td></tr>
        </tbody>
      </table>
    </section>

    <hr class="section-divider">

    <!-- Principle 3 -->
    <section id="p3">
      <h2><span style="font-weight: 700;">P3:</span> Fresh Context > Extended Sessions</h2>

      <div class="problem-statement">
        Context accumulation is entropy. Every operation adds tokens. This compounds until quality collapse. Fresh context is regeneration.
      </div>

      <div class="callout callout-insight">
        <div class="callout-title">The Mathematical Reality</div>
        <p><strong>Extended Session Quality:</strong> Q(t) = Q_max * decay(context_usage(t))</p>
        <p><strong>Fresh Context Quality:</strong> Q(t) = Q_max (constant per iteration)</p>
        <p>Extended sessions guarantee degradation. Fresh context guarantees consistent quality.</p>
      </div>

      <h3>Why Not Compaction?</h3>
      <p><strong>Compaction is lossy.</strong> When you compact, you summarize. When you summarize, you lose detail. Fresh context via Ralph loops is lossless - files preserve full detail, git preserves full history.</p>

      <h3>When Extended Sessions Are Acceptable</h3>
      <ul>
        <li>Single, small tasks (< 30 min)</li>
        <li>Exploratory work where loss is acceptable</li>
        <li>Debugging where context accumulation aids investigation</li>
      </ul>
      <p>Even then, monitor context usage and reset before 70%.</p>
    </section>

    <hr class="section-divider">

    <!-- Principle 4 -->
    <section id="p4">
      <h2><span style="font-weight: 700;">P4:</span> Separation of Concerns (Orchestrator/Worker)</h2>

      <div class="problem-statement">
        Mixing coordination with execution causes context pollution and role confusion. The agent oscillates between planning and doing, doing neither well.
      </div>

      <blockquote>
        "YOU DO NOT WRITE CODE. YOU DO NOT RUN COMMANDS. YOU DO NOT EXPLORE CODEBASES. You are the CONDUCTOR. Your agents play the instruments."<br>
        <cite>-- @nummanali (CC Mirror)</cite>
      </blockquote>

      <table class="comparison-table">
        <thead><tr><th>Role</th><th>DOES</th><th>DOES NOT</th></tr></thead>
        <tbody>
          <tr>
            <td><strong>Orchestrator</strong></td>
            <td>Decompose tasks, assign workers, track dependencies, synthesize results</td>
            <td>Write code, run commands, explore codebase, debug errors</td>
          </tr>
          <tr>
            <td><strong>Workers</strong></td>
            <td>Execute specific tasks, use tools directly, report results</td>
            <td>Spawn sub-agents, manage task graphs, make coordination decisions</td>
          </tr>
        </tbody>
      </table>

      <h3>Model Selection by Role</h3>
      <table>
        <thead><tr><th>Role</th><th>Model</th><th>Rationale</th></tr></thead>
        <tbody>
          <tr><td>Orchestrator</td><td>Opus</td><td>Complex reasoning, coordination decisions</td></tr>
          <tr><td>Complex worker</td><td>Opus</td><td>Architecture, ambiguous tasks</td></tr>
          <tr><td>Standard worker</td><td>Sonnet</td><td>Implementation, testing, following patterns</td></tr>
          <tr><td>Simple worker</td><td>Haiku</td><td>File lookup, grep, simple transforms</td></tr>
        </tbody>
      </table>
    </section>

    <hr class="section-divider">

    <!-- Principle 5 -->
    <section id="p5">
      <h2><span style="font-weight: 700;">P5:</span> Atomic, Verifiable Task Sizing</h2>

      <div class="problem-statement">
        Large tasks fail for predictable reasons: context overflow, scope creep, impossible verification, lost recovery. Atomic tasks succeed because they fit in one context window, have clear boundaries, and can be independently verified.
      </div>

      <div class="callout callout-success">
        <div class="callout-title">The Golden Rule</div>
        <p>"Each story must be completable in ONE iteration (~one context window)"</p>
      </div>

      <h3>The 2-3 Sentence Test</h3>
      <p><strong>If you can't describe the task in 2-3 sentences, it's too big.</strong></p>
      <ul>
        <li><strong>Good:</strong> "Add investorType column to users table with default value 'cold'. Create migration. Run npm typecheck."</li>
        <li><strong>Bad:</strong> "Implement the investor management system with types, filtering, and reporting."</li>
      </ul>

      <h3>Task Sizing Reference</h3>
      <table>
        <thead><tr><th>Size</th><th>Lines of Code</th><th>Files</th><th>Iterations</th><th>Example</th></tr></thead>
        <tbody>
          <tr><td>XS</td><td>1-20</td><td>1</td><td>1</td><td>Add column, fix typo</td></tr>
          <tr><td>S</td><td>20-100</td><td>1-2</td><td>1</td><td>New component, endpoint</td></tr>
          <tr><td>M</td><td>100-300</td><td>2-5</td><td>1-2</td><td>Feature piece, integration</td></tr>
          <tr><td>L</td><td>300-1000</td><td>5-10</td><td>3-5</td><td>Small feature, refactor</td></tr>
          <tr><td>XL</td><td>1000+</td><td>10+</td><td>5+</td><td><strong>MUST DECOMPOSE!</strong></td></tr>
        </tbody>
      </table>
    </section>

    <hr class="section-divider">

    <!-- Principle 6 -->
    <section id="p6">
      <h2><span style="font-weight: 700;">P6:</span> Quality Gates Before Commit</h2>

      <div class="problem-statement">
        Broken code propagates. If iteration N commits broken code, iteration N+1 inherits a broken baseline and must debug before doing its work. Working code accumulates - progress is monotonic.
      </div>

      <blockquote>
        "Claude's tendency to mark features complete without proper testing... did much better at verifying end-to-end once explicitly prompted to use browser automation tools"<br>
        <cite>-- Anthropic Best Practices</cite>
      </blockquote>

      <div class="ascii-diagram">
+-------------------------------------------------------+
|                    QUALITY GATES                       |
+-------------------------------------------------------+
|                                                        |
|  BEFORE ANY COMMIT:                                   |
|                                                        |
|  1. Type checking     --> npm run typecheck            |
|  2. Unit tests        --> npm test                     |
|  3. Lint              --> npm run lint                 |
|  4. Integration tests --> npm run test:integration     |
|                                                        |
|  ALL PASS? --> Commit allowed                         |
|  ANY FAIL? --> Fix BEFORE commit, retry gates         |
|                                                        |
+-------------------------------------------------------+
      </div>

      <div class="callout callout-warning">
        <div class="callout-title">The Typecheck Mandate</div>
        <p><strong>ALWAYS include a verification command as final criterion:</strong></p>
        <pre><code>"acceptanceCriteria": [
  "...",
  "npm run typecheck passes",
  "npm run test passes"
]</code></pre>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Principle 7 -->
    <section id="p7">
      <h2><span style="font-weight: 700;">P7:</span> Isolation Prevents Contamination</h2>

      <div class="problem-statement">
        Shared state causes conflicts. When multiple agents operate on the same files: edits overwrite, merge conflicts arise, partial changes break builds. Isolation enables safe parallel execution.
      </div>

      <table>
        <thead><tr><th>Strategy</th><th>Mechanism</th><th>Best For</th></tr></thead>
        <tbody>
          <tr><td>Directory isolation</td><td>Each agent owns a directory</td><td>Domain specialization</td></tr>
          <tr><td>Branch isolation</td><td>Each agent works on own branch</td><td>Feature parallelism</td></tr>
          <tr><td>Worktree isolation</td><td>Git worktrees share repo, isolate checkouts</td><td>Heavy parallelism</td></tr>
          <tr><td>Container isolation</td><td>Docker containers with volume mounts</td><td>Production systems</td></tr>
        </tbody>
      </table>
    </section>

    <hr class="section-divider">

    <!-- Principle 8 -->
    <section id="p8">
      <h2><span style="font-weight: 700;">P8:</span> Explicit Communication Over Implicit</h2>

      <div class="problem-statement">
        LLMs don't share memory. Each agent instance starts with zero knowledge of others. Implicit coordination fails. Explicit communication via files succeeds.
      </div>

      <table>
        <thead><tr><th>Mechanism</th><th>Use Case</th><th>Example</th></tr></thead>
        <tbody>
          <tr><td>File-based handoffs</td><td>Agent-to-agent context transfer</td><td>handoff-agent1-to-agent2.json</td></tr>
          <tr><td>Git commits</td><td>Progress signaling</td><td>Commit message as communication</td></tr>
          <tr><td>Progress.txt</td><td>Learning propagation</td><td>Append-only log</td></tr>
          <tr><td>Task status files</td><td>Coordination state</td><td>prd.json with passes/fails</td></tr>
        </tbody>
      </table>

      <h3>The Promise Pattern</h3>
      <p>Explicit completion signals:</p>
      <pre><code>If all tasks complete, output: &lt;promise&gt;COMPLETE&lt;/promise&gt;</code></pre>
      <p>The controlling loop greps for this signal. No ambiguity.</p>
    </section>

    <hr class="section-divider">

    <!-- Anti-Patterns Section -->
    <section id="anti-patterns">
      <h2><span style="font-weight: 700;">Anti</span>-Patterns</h2>

      <p>What NOT to do - common mistakes and their fixes.</p>

      <table class="comparison-table">
        <thead><tr><th>Symptom</th><th>Likely Violated Principle</th><th>Fix</th></tr></thead>
        <tbody>
          <tr><td>Agent forgets previous work</td><td>P2 (External state)</td><td>Externalize to files</td></tr>
          <tr><td>Quality degrades over time</td><td>P1/P3 (Context/Fresh)</td><td>Reset more frequently</td></tr>
          <tr><td>Workers spawn their own agents</td><td>P4 (Separation)</td><td>Explicit worker preamble</td></tr>
          <tr><td>Tasks never complete</td><td>P5 (Atomic sizing)</td><td>Smaller stories</td></tr>
          <tr><td>Broken code accumulates</td><td>P6 (Quality gates)</td><td>Enforce tests before commit</td></tr>
          <tr><td>Agents conflict on files</td><td>P7 (Isolation)</td><td>Worktrees or ownership</td></tr>
          <tr><td>Agents don't coordinate</td><td>P8 (Explicit comms)</td><td>File-based handoffs</td></tr>
        </tbody>
      </table>

      <div class="related-pages" style="margin-top: 2rem;">
        <h4>Source Document</h4>
        <p>Full anti-patterns analysis: <code>synthesis/principles-anti-patterns.md</code> (~31K words)</p>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Derivation Section -->
    <section id="derivation">
      <h2><span style="font-weight: 700;">Der</span>iving New Patterns</h2>

      <p>The true power of understanding principles is the ability to <strong>derive new patterns</strong> for novel situations.</p>

      <h3>The Derivation Process</h3>
      <ol>
        <li><strong>Identify the constraint</strong> - What's the primary challenge?</li>
        <li><strong>Map to principles</strong> - Which principles apply?</li>
        <li><strong>Check for conflicts</strong> - Do any principles conflict in this case?</li>
        <li><strong>Combine mechanisms</strong> - What implementations serve multiple principles?</li>
        <li><strong>Validate</strong> - Does the derived pattern satisfy the constraints?</li>
      </ol>

      <div class="related-pages" style="margin-top: 2rem;">
        <h4>Source Document</h4>
        <p>Complete derivation guide with examples: <code>synthesis/principles-derivation-guide.md</code> (~26K words)</p>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Learning Loops Section -->
    <section id="learning-loops">
      <h2><span style="font-weight: 700;">Lear</span>ning Loops</h2>

      <p>How to build systems that compound knowledge over time.</p>

      <div class="callout callout-success">
        <div class="callout-title">Two Places for Learnings</div>
        <p><strong>progress.txt</strong> - Session memory for Ralph iterations (ephemeral)</p>
        <p><strong>AGENTS.md</strong> - Permanent docs for humans and future agents (persistent)</p>
      </div>

      <h3>What to add to AGENTS.md</h3>
      <ul>
        <li>"When modifying X, also update Y"</li>
        <li>"This module uses pattern Z"</li>
        <li>"Tests require dev server running"</li>
      </ul>

      <h3>What NOT to add</h3>
      <ul>
        <li>Story-specific details</li>
        <li>Temporary notes</li>
        <li>Info already in progress.txt</li>
      </ul>

      <div class="related-pages" style="margin-top: 2rem;">
        <h4>Source Document</h4>
        <p>Complete learning loops guide: <code>synthesis/principles-learning-loops.md</code> (~19K words)</p>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Summary -->
    <div class="quick-ref">
      <div class="quick-ref-title">Summary: The Eight Principles</div>
      <ol>
        <li><strong>Context Is The Primary Constraint</strong> - All patterns optimize around finite context windows</li>
        <li><strong>External State > Internal Memory</strong> - Files persist, context evaporates</li>
        <li><strong>Fresh Context > Extended Sessions</strong> - New instances beat long conversations</li>
        <li><strong>Separation of Concerns</strong> - Orchestrators coordinate, workers execute</li>
        <li><strong>Atomic, Verifiable Tasks</strong> - Complete in one iteration, verify before commit</li>
        <li><strong>Quality Gates Before Commit</strong> - Tests must pass, no broken code inheritance</li>
        <li><strong>Isolation Prevents Contamination</strong> - Own your space, don't conflict</li>
        <li><strong>Explicit Communication</strong> - File-based handoffs, not implicit coordination</li>
      </ol>
      <p><strong>The Meta-Principle:</strong> When in doubt, externalize, isolate, verify, and restart fresh.</p>
    </div>

    <!-- Footer Navigation -->
    <div class="footer-nav">
      <a href="mastery-master.html">Previous: Mastery Guides</a>
      <a href="compare-master.html">Next: Comparisons</a>
    </div>

  </div>
</body>
</html>
