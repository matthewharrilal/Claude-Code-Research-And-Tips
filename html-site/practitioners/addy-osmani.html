<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Addy Osmani - Conductor to Orchestrator | Practitioner Wisdom</title>
  <meta data-pagefind-meta="chapter" content="Practitioners">
  <meta data-pagefind-meta="section" content="Practitioner Profiles">
  <meta name="description" content="Addy Osmani's Conductor vs Orchestrator framework for AI agent development. From synchronous single-agent to asynchronous multi-agent workflows.">
  <meta name="keywords" content="claude code, addy osmani, conductor pattern, orchestrator pattern, agentic coding, ai agents, multi-agent systems">
  <link rel="stylesheet" href="../css/style.css">
  <link rel="stylesheet" href="../css/search.css">
  <style>
    .bionic { font-weight: 700; }

    .you-are-here {
      background: linear-gradient(135deg, #f0ebe3 0%, #fefcf3 100%);
      border-left: 4px solid #2a7d7d;
      border-radius: 8px;
      padding: 1.5rem;
      margin-bottom: 2rem;
    }

    .checkpoint {
      background: #f0ebe3;
      border-left: 4px solid #6b9b7a;
      border-radius: 8px;
      padding: 1.5rem;
      margin: 2rem 0;
    }

    .checkpoint-header {
      color: #6b9b7a;
      font-weight: 600;
      margin-bottom: 0.5rem;
    }

    .troubleshoot {
      border: 1px solid #c97065;
      border-radius: 8px;
      margin: 1rem 0;
    }

    .troubleshoot summary {
      background: #fef6f5;
      padding: 1rem;
      cursor: pointer;
      color: #c97065;
      font-weight: 600;
    }

    .troubleshoot > div {
      padding: 1rem;
      background: white;
    }

    .milestone {
      background: linear-gradient(90deg, #6b9b7a 0%, #2a7d7d 100%);
      color: white;
      padding: 1rem 1.5rem;
      border-radius: 8px;
      text-align: center;
      margin: 2rem 0;
    }

    .divider-procedure { border-top: 3px solid #2a7d7d; margin: 2rem 0; padding-top: 1rem; }
    .divider-checkpoint { border-top: 3px solid #6b9b7a; margin: 2rem 0; padding-top: 1rem; }
    .divider-context { border-top: 3px solid #5c4b3a; margin: 2rem 0; padding-top: 1rem; }

    .code-block {
      background: #f0ebe3;
      border-radius: 6px;
      padding: 1rem;
      position: relative;
      font-family: 'SF Mono', Monaco, monospace;
      margin: 1rem 0;
      overflow-x: auto;
    }

    .copy-btn {
      position: absolute;
      top: 0.5rem;
      right: 0.5rem;
      background: #2a7d7d;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 0.25rem 0.5rem;
      cursor: pointer;
      font-size: 0.8rem;
    }

    .copy-btn:hover {
      background: #3a9d9d;
    }

    .pioneer-badge {
      background: linear-gradient(135deg, #c49052 0%, #2a7d7d 100%);
      color: white;
      display: inline-block;
      padding: 0.5rem 1rem;
      border-radius: 20px;
      font-weight: 600;
      margin-bottom: 1rem;
    }

    .principle-card {
      background: white;
      border: 2px solid var(--border);
      border-radius: 12px;
      padding: 1.5rem;
      margin: 1rem 0;
      transition: box-shadow 0.2s;
    }

    .principle-card:hover {
      box-shadow: 0 4px 12px rgba(92, 75, 58, 0.15);
    }

    .principle-number {
      background: var(--accent);
      color: white;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      margin-right: 0.75rem;
    }

    .workflow-visual {
      background: var(--code-bg);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 2rem;
      text-align: center;
      font-family: 'SF Mono', Monaco, monospace;
      font-size: 0.9em;
      line-height: 2;
      overflow-x: auto;
    }

    .profile-card {
      background: white;
      border: 2px solid var(--border);
      border-radius: 12px;
      padding: 1.5rem;
      margin: 1.5rem 0;
    }

    .profile-card h4 {
      margin-top: 0;
      color: var(--heading);
    }

    .quote-highlight {
      background: linear-gradient(90deg, #f0ebe3 0%, #fefcf3 100%);
      border-left: 4px solid #c49052;
      padding: 1.5rem;
      border-radius: 8px;
      margin: 1.5rem 0;
      font-style: italic;
    }

    .quote-highlight cite {
      display: block;
      margin-top: 0.75rem;
      font-style: normal;
      font-weight: 600;
      color: var(--text-muted);
    }

    .comparison-table {
      width: 100%;
      border-collapse: collapse;
      margin: 1.5rem 0;
    }

    .comparison-table th,
    .comparison-table td {
      padding: 0.75rem 1rem;
      text-align: left;
      border-bottom: 1px solid var(--border);
    }

    .comparison-table th {
      background: var(--code-bg);
      font-weight: 600;
      color: var(--heading);
    }

    .comparison-table tr:hover td {
      background: #fefcf3;
    }

    .source-badge {
      display: inline-block;
      background: #e8f4f4;
      color: #2a7d7d;
      font-size: 0.75rem;
      padding: 2px 8px;
      border-radius: 4px;
      margin-left: 0.5rem;
      font-weight: 500;
    }
  </style>
</head>
<body>
<!-- Search Modal -->
<div class="search-modal" id="searchModal" aria-hidden="true">
  <div class="search-overlay" onclick="closeSearch()"></div>
  <div class="search-content">
    <div class="search-header">
      <div class="search-input-wrapper">
        <span class="search-icon-input">üîç</span>
        <input type="text" id="searchInput" placeholder="Search documentation..." autocomplete="off" />
        <kbd class="search-kbd">ESC</kbd>
      </div>
    </div>
    <div class="search-filters">
      <button class="filter-btn active" data-filter="all">All</button>
      <button class="filter-btn" data-filter="ch1">Chapter 1</button>
      <button class="filter-btn" data-filter="ch2">Chapter 2</button>
      <button class="filter-btn" data-filter="ch3">Chapter 3</button>
      <button class="filter-btn" data-filter="ch4">Chapter 4</button>
      <button class="filter-btn" data-filter="ref">Reference</button>
    </div>
    <div class="search-results" id="searchResults">
      <div class="search-empty"><p>Start typing to search... (Press Cmd+K anytime)</p></div>
    </div>
    <div class="search-footer">
      <span>Up/Down Navigate</span><span>Enter Select</span><span>ESC Close</span>
    </div>
  </div>
</div>

  <div class="container">

    <!-- Breadcrumb Navigation -->
    <nav class="nav-breadcrumb">
      <a href="../index.html">Home</a>
      <span>/</span>
      <a href="index.html">Practitioners</a>
      <span>/</span>
      <strong>Addy Osmani</strong>
      <button class="search-trigger" onclick="openSearch()" aria-label="Search" style="float: right; margin-bottom: 1rem;">
        <span class="search-icon">Cmd+K</span>
        <span class="search-text">Search</span>
      </button>
    </nav>

    <!-- You Are Here Context Box -->
    <div class="you-are-here">
      <strong><span class="bionic">You</span> Are <span class="bionic">Her</span>e:</strong> You're learning from an engineering leader who has formalized the <span class="bionic">evo</span>lution from single-agent to multi-agent AI workflows. Addy Osmani's <span class="bionic">Con</span>ductor vs <span class="bionic">Orc</span>hestrator framework describes the shift from synchronous, hands-on AI pair programming to asynchronous, parallel agent coordination.
      <br><br>
      <strong><span class="bionic">Wha</span>t This <span class="bionic">Ena</span>bles:</strong> Understanding when to use each pattern lets you choose the right interaction model. Conductors for interactive sessions requiring judgment. Orchestrators for parallelized, well-defined tasks where you front-load specifications and back-load review.
    </div>

    <div class="pioneer-badge">ORCHESTRATION ARCHITECT</div>

    <h1><span class="bionic">Add</span>y <span class="bionic">Osm</span>ani: From <span class="bionic">Con</span>ductor to <span class="bionic">Orc</span>hestrator</h1>

    <p class="conversational-lead">
      "Our jobs are shifting from 'How do I code this?' to 'How do I get the right code built?' - a subtle but profound change." <span class="source-badge">Verified</span>
    </p>

    <!-- Table of Contents -->
    <div class="toc">
      <div class="toc-title">On This Page</div>
      <ul>
        <li><a href="#who">Who Is Addy Osmani?</a></li>
        <li><a href="#framework">The Conductor vs Orchestrator Framework</a></li>
        <li><a href="#70-problem">The 70% Problem</a></li>
        <li><a href="#techniques">Key Techniques</a></li>
        <li><a href="#tools">Tool Categories</a></li>
        <li><a href="#implement">Implement The Patterns</a></li>
        <li><a href="#troubleshooting">Troubleshooting</a></li>
        <li><a href="#related">Related Content</a></li>
      </ul>
    </div>

    <hr class="section-divider">

    <!-- Section 1: Who Is Addy Osmani -->
    <section id="who">
      <h2><span class="bionic">Who</span> Is <span class="bionic">Add</span>y <span class="bionic">Osm</span>ani?</h2>

      <div class="story-context">
        Addy Osmani is a Director of Engineering at Google Cloud AI, with 14+ years at Google including significant time leading Chrome Developer Experience. He writes extensively about AI-assisted development through his <strong>Elevate</strong> newsletter on Substack, applying systems thinking and engineering discipline to the emerging patterns of agentic coding.
      </div>

      <div class="profile-card">
        <h4><span class="bionic">Add</span>y <span class="bionic">Osm</span>ani</h4>
        <ul>
          <li><strong>Role:</strong> Director of Engineering, Google Cloud AI</li>
          <li><strong>Background:</strong> 14+ years at Google, Chrome DevEx leadership</li>
          <li><strong>Twitter:</strong> <a href="https://twitter.com/addyosmani">@addyosmani</a></li>
          <li><strong>Newsletter:</strong> <a href="https://addyo.substack.com">Elevate (Substack)</a></li>
          <li><strong>Blog:</strong> <a href="https://addyosmani.com">addyosmani.com</a></li>
          <li><strong>Key Contribution:</strong> Conductor vs Orchestrator framework, "70% Problem" analysis</li>
        </ul>
      </div>

      <h3>Why <span class="bionic">Lis</span>ten to Him?</h3>
      <p>
        Addy brings <span class="bionic">dec</span>ades of experience building developer tools at scale. His frameworks aren't theoretical - they emerge from observing how engineers actually use AI coding tools and where patterns succeed or fail. His "Elevate" newsletter consistently provides some of the most rigorous analysis of AI-assisted development in the industry.
      </p>
    </section>

    <div class="divider-context"></div>

    <!-- Section 2: The Framework -->
    <section id="framework">
      <h2><span class="bionic">The</span> Conductor vs <span class="bionic">Orc</span>hestrator Framework</h2>

      <p>
        Addy frames the evolution of AI-assisted development as a shift in the engineer's role - from active participant to strategic coordinator. This is the central insight of his "Conductors to Orchestrators" framework.
      </p>

      <div class="principle-card">
        <h3><span class="principle-number">1</span>The <span class="bionic">Con</span>ductor Pattern</h3>

        <p>A conductor "works closely with a single AI agent on a specific task, much like a conductor guiding a soloist through a performance." <span class="source-badge">Verified</span></p>

        <div class="quote-highlight">
          "The engineer remains in the loop at each step, dynamically steering the agent's behavior, tweaking prompts, intervening when needed, and iterating in real-time."
          <cite>- Addy Osmani, "Conductors to Orchestrators" (2025)</cite>
        </div>

        <p><strong>Conductor Characteristics:</strong></p>
        <ul>
          <li><span class="bionic">Syn</span>chronous, real-time interaction</li>
          <li>"A <span class="bionic">tig</span>ht feedback loop with one agent, verifying or modifying each suggestion"</li>
          <li><span class="bionic">Low</span> agent autonomy - waits for user prompts each step</li>
          <li>"Most of this interaction is <span class="bionic">eph</span>emeral: once code is written and the session ends, the AI's role is done"</li>
          <li>Human <span class="bionic">eng</span>aged nearly 100% of the time the AI is working</li>
        </ul>

        <p><strong>Conductor Tools:</strong> Claude Code CLI, Cursor (in-editor), Gemini CLI, Cline, Roo Code</p>
      </div>

      <div class="principle-card">
        <h3><span class="principle-number">2</span>The <span class="bionic">Orc</span>hestrator Pattern</h3>

        <p>An orchestrator "oversees the entire symphony of multiple AI agents working in parallel on different parts of a project." <span class="source-badge">Verified</span></p>

        <div class="quote-highlight">
          "The human's effort is front-loaded (writing a good task description or spec for the agent, setting up the right context) and back-loaded (reviewing the final code and testing it), but not much is needed in the middle."
          <cite>- Addy Osmani, "Conductors to Orchestrators" (2025)</cite>
        </div>

        <p><strong>Orchestrator Characteristics:</strong></p>
        <ul>
          <li><span class="bionic">Asy</span>nchronous, parallel workflow</li>
          <li>"Moves AI assistance from <span class="bionic">for</span>eground to background"</li>
          <li><span class="bionic">Hig</span>h agent autonomy - "plan and execute multi-step coding tasks with minimal intervention"</li>
          <li>"<span class="bionic">Tra</span>cked, persistent workflow" via version control and CI pipelines</li>
          <li>Focus on "<span class="bionic">coo</span>rdination, quality control, and integration"</li>
        </ul>

        <p><strong>Orchestrator Tools:</strong> GitHub Copilot Coding Agent, Google Jules, OpenAI Codex, Cursor 2.0 Background Agents, Claude Squad, Conductor (Melty Labs)</p>
      </div>

      <!-- Comparison Table -->
      <h3><span class="bionic">Dir</span>ect Comparison</h3>

      <table class="comparison-table">
        <thead>
          <tr>
            <th>Aspect</th>
            <th>Conductor</th>
            <th>Orchestrator</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Control Level</strong></td>
            <td>Micro-level guidance</td>
            <td>Macro-level task definition</td>
          </tr>
          <tr>
            <td><strong>Agent Autonomy</strong></td>
            <td>Low (prompt-dependent)</td>
            <td>High (self-directed execution)</td>
          </tr>
          <tr>
            <td><strong>Timing</strong></td>
            <td>Synchronous, real-time</td>
            <td>Asynchronous, background work</td>
          </tr>
          <tr>
            <td><strong>Documentation</strong></td>
            <td>Ephemeral (often unrecorded)</td>
            <td>Persistent (git branches, PRs)</td>
          </tr>
          <tr>
            <td><strong>Human Effort</strong></td>
            <td>Constant engagement (100%)</td>
            <td>Front-loaded specs, back-loaded review</td>
          </tr>
          <tr>
            <td><strong>Parallelization</strong></td>
            <td>Sequential, one agent</td>
            <td>Concurrent, multiple agents</td>
          </tr>
        </tbody>
      </table>

      <div class="workflow-visual">
<strong>CONDUCTOR:</strong> Human actively engaged throughout
Human <---> AI Agent <---> Human <---> AI Agent <---> Human
       (prompt)      (respond)   (prompt)     (respond)   (accept)

<strong>ORCHESTRATOR:</strong> Human front-loads and back-loads
Human --> [Agent 1] ------
      --> [Agent 2] ------ --> Human reviews all
      --> [Agent 3] ------
 (specs)   (parallel work)      (integration)
      </div>

      <div class="checkpoint">
        <div class="checkpoint-header">Decision Point</div>
        <p><strong>Choose Conductor when:</strong> Tasks require judgment, novelty, or real-time adaptation. Interactive pair programming sessions.</p>
        <p><strong>Choose Orchestrator when:</strong> Workflows are well-defined, parallelism helps, and you can specify upfront. Migrations, bulk changes, multi-module work.</p>
      </div>
    </section>

    <div class="divider-procedure"></div>

    <!-- Section 3: The 70% Problem -->
    <section id="70-problem">
      <h2><span class="bionic">The</span> 70% Problem</h2>

      <p>
        One of Addy's most cited insights is the "<span class="bionic">70%</span> Problem" - a framework for understanding AI coding limitations.
      </p>

      <div class="principle-card">
        <h3>The Core Thesis</h3>

        <p>Non-engineers can reach 70% completion quickly using AI tools, but the final 30% - production-ready, maintainable, robust code - "still requires real engineering knowledge." <span class="source-badge">Verified</span></p>

        <div class="quote-highlight">
          "AI tools help experienced developers more than beginners because expertise enables developers to guide AI output effectively. Seniors use AI to accelerate what they already know, while juniors struggle with dependency on AI for learning fundamentals."
          <cite>- Addy Osmani, "The 70% Problem" (2025)</cite>
        </div>

        <p><strong>The "Two Steps Back" Pattern:</strong></p>
        <ol>
          <li>User fixes a bug</li>
          <li>AI suggests a problematic change</li>
          <li>This breaks something else</li>
          <li>Iterative failures multiply</li>
        </ol>

        <p>This is why Addy emphasizes that "the goal isn't to write more code faster. It's to build better software." <span class="source-badge">Verified</span></p>
      </div>

      <div class="principle-card">
        <h3>Agentic Development Definition</h3>

        <p>Addy defines "agentic" development as systems that can "plan, execute, and iterate on solutions with increasing autonomy" - rather than simply responding to prompts. <span class="source-badge">Verified</span></p>

        <p><strong>Three emerging capabilities:</strong></p>
        <ol>
          <li><strong>From responders to collaborators:</strong> Tools that can "proactively identify potential issues, launch test suites, inspect UI elements, propose fixes, and validate solutions"</li>
          <li><strong>Multimodal integration:</strong> Combining "visual understanding, verbal conversations, and environment interaction"</li>
          <li><strong>Autonomous but guided:</strong> AI becoming "an increasingly capable collaborator that can take initiative while respecting human guidance"</li>
        </ol>
      </div>
    </section>

    <div class="divider-checkpoint"></div>

    <!-- Section 4: Key Techniques -->
    <section id="techniques">
      <h2><span class="bionic">Key</span> <span class="bionic">Tech</span>niques</h2>

      <div class="principle-card">
        <h3><span class="principle-number">1</span>Three <span class="bionic">Wor</span>king Approaches</h3>

        <p>Addy identifies three practical patterns that work: <span class="source-badge">Verified</span></p>

        <ul>
          <li><strong>"AI First Draft":</strong> Generate, review, refactor, test, document</li>
          <li><strong>"Constant Conversation":</strong> Separate chats per task, frequent commits</li>
          <li><strong>"Trust But Verify":</strong> Manual review of critical paths, automated edge-case testing</li>
        </ul>
      </div>

      <div class="principle-card">
        <h3><span class="principle-number">2</span>Specification <span class="bionic">Qua</span>lity Matters</h3>

        <p>In the orchestrator model, the quality of your upfront specification directly determines output quality. Vague instructions produce poor results. This is why "the human engineer's role becomes one of oversight and orchestration" - you define the goal clearly, then review the output critically. <span class="source-badge">Verified</span></p>
      </div>

      <div class="principle-card">
        <h3><span class="principle-number">3</span>Human <span class="bionic">Jud</span>gment Remains Critical</h3>

        <div class="quote-highlight">
          "Human judgment remains vital: deciding what to build, ensuring correctness, handling ambiguity, and injecting creativity or domain knowledge where AI might fall short."
          <cite>- Addy Osmani, "Conductors to Orchestrators" (2025)</cite>
        </div>

        <p>Addy emphasizes that human review of AI-generated code is "critical" as the final failsafe. Engineers remain responsible for license compliance, security, and bias in AI-generated code.</p>
      </div>

      <div class="principle-card">
        <h3><span class="principle-number">4</span>Current <span class="bionic">Sta</span>te Assessment</h3>

        <p>On enterprise adoption, Addy notes: "What I hear when I talk to enterprise companies is a lot of skepticism around the readiness of these patterns for large decade-old code bases. And I'm excited there are folks poking at these problems. I think eventually the tooling will get to a good place." <span class="source-badge">Verified</span></p>

        <p>Orchestration currently works well for:</p>
        <ul>
          <li>Fixing UI bugs</li>
          <li>Adding small features</li>
          <li>Migrations and dependency upgrades</li>
          <li>Small-to-medium sized projects</li>
        </ul>
      </div>
    </section>

    <div class="divider-context"></div>

    <!-- Section 5: Tools -->
    <section id="tools">
      <h2><span class="bionic">Too</span>l Categories</h2>

      <p>Addy categorizes AI coding tools by their interaction model:</p>

      <div class="principle-card">
        <h3>Conductor Tools (Single Agent, Synchronous)</h3>
        <ul>
          <li><strong>Claude Code</strong> - CLI/editor integration</li>
          <li><strong>Cursor</strong> - In-editor chat</li>
          <li><strong>Gemini CLI</strong> - Terminal-based</li>
          <li><strong>VSCode Agents, Cline, Roo Code</strong> - Editor extensions</li>
        </ul>
      </div>

      <div class="principle-card">
        <h3>Orchestrator Tools (Multi-Agent, Asynchronous)</h3>
        <ul>
          <li><strong>GitHub Copilot Coding Agent</strong></li>
          <li><strong>Google Jules</strong></li>
          <li><strong>OpenAI Codex</strong> (cloud agent)</li>
          <li><strong>Cursor 2.0 Background Agents</strong></li>
          <li><strong>Claude Squad</strong> (open-source)</li>
          <li><strong>Conductor</strong> (Melty Labs)</li>
        </ul>
      </div>
    </section>

    <div class="divider-procedure"></div>

    <!-- Section 6: Implementation Guide -->
    <section id="implement">
      <h2><span class="bionic">Imp</span>lement The <span class="bionic">Pat</span>terns</h2>

      <h3><span class="bionic">Qui</span>ck Wins (< 15 minutes)</h3>

      <div class="checkpoint">
        <div class="checkpoint-header">Implementation Checkpoint: Identify Your Current Pattern</div>
        <ol>
          <li>Review your last 3 AI coding sessions</li>
          <li>Note: Did you stay engaged throughout (Conductor) or define tasks upfront and review results (Orchestrator)?</li>
          <li>Count interruptions: High interruption = Conductor-style, low = Orchestrator-style</li>
        </ol>
        <p><strong>You should see:</strong> A clear pattern emerging - most developers default to Conductor, which is fine for most work.</p>
      </div>

      <h3><span class="bionic">Con</span>ductor Pattern Example</h3>

      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
# Conductor pattern: Interactive session with real-time feedback
# You stay engaged throughout

claude

> I need to add form validation to the signup page.
> Start by showing me the current form structure.

# Claude reads files, you review, then guide:
> Good. Now add email validation. Use the same
> pattern as the login form for consistency.

# After each step, you verify before continuing:
> That looks right. Now add password strength
> checking. Minimum 8 chars, one number, one special.

# Session ends when feature is complete
      </div>

      <h3><span class="bionic">Orc</span>hestrator Pattern Example</h3>

      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
# Orchestrator pattern: Detailed spec upfront, review at end
# Front-load specification, back-load review

# Create detailed task specification
cat > migration-spec.md << 'EOF'
# Task: Migrate authentication from JWT to session-based

## Acceptance Criteria
- [ ] Replace JWT middleware with session middleware
- [ ] Update all auth endpoints
- [ ] Migrate user tokens in database
- [ ] Update tests
- [ ] No breaking changes to API contract

## Context Files
- src/auth/jwt-middleware.ts (current implementation)
- src/routes/auth.ts (endpoints to update)
- tests/auth.test.ts (must pass after migration)

## Constraints
- Use express-session with Redis store
- Maintain backward compatibility for 2 weeks
EOF

# Hand off to agent (background process)
claude --task "Execute migration-spec.md in a new branch"

# ... do other work while agent executes ...

# Back-load: Review results
git diff main..feature/session-auth
npm test
      </div>

      <h3><span class="bionic">Med</span>ium Lift (1-2 hours)</h3>
      <ol>
        <li>Create specification templates for common orchestrator tasks</li>
        <li>Set up a "staging branch" workflow for agent-generated PRs</li>
        <li>Establish review checklist for agent-generated code</li>
        <li>Configure notifications for when background agents complete</li>
      </ol>

      <h3><span class="bionic">Dee</span>p Investment (over time)</h3>
      <ol>
        <li>Build a library of proven task specifications</li>
        <li>Develop team conventions for human-AI handoff points</li>
        <li>Create integration tests that agents must pass</li>
        <li>Establish metrics: success rate by task type, review time</li>
      </ol>

      <div class="checkpoint">
        <div class="checkpoint-header">Transition Checkpoint: Moving to Orchestrator</div>
        <p>Before attempting orchestrator patterns, verify:</p>
        <ol>
          <li>You have a well-defined, repeatable task type</li>
          <li>You can write a specification with clear acceptance criteria</li>
          <li>You have a review process for agent-generated code</li>
          <li>The task doesn't require real-time judgment or domain knowledge only you have</li>
        </ol>
        <p><strong>You should see:</strong> Tasks that fit these criteria - migrations, dependency updates, boilerplate generation - become candidates for orchestration.</p>
      </div>
    </section>

    <div class="divider-checkpoint"></div>

    <!-- Section 7: Troubleshooting -->
    <section id="troubleshooting">
      <h2><span class="bionic">Tro</span>ubleshooting</h2>

      <details class="troubleshoot">
        <summary>Problem: "Orchestrator produces wrong results despite good spec"</summary>
        <div>
          <p><strong>Symptoms:</strong> Agent completes task but output misses key requirements. Multiple review-and-retry cycles needed.</p>
          <p><strong>Causes:</strong></p>
          <ul>
            <li>Spec was clear to you but ambiguous to agent</li>
            <li>Missing context about codebase conventions</li>
            <li>Implicit requirements not stated</li>
          </ul>
          <div class="code-block">
            <button class="copy-btn" onclick="copyCode(this)">Copy</button>
# Improve your specification with explicit context:

## Add codebase conventions section
cat >> task-spec.md << 'EOF'

## Codebase Conventions (MUST FOLLOW)
- Error handling: Always use AppError class from src/utils/errors.ts
- Logging: Use structured logger from src/utils/logger.ts
- Naming: camelCase for functions, PascalCase for classes
- Tests: Follow existing patterns in tests/__examples__/
EOF

# Include "good example" reference
## Reference Implementation
See src/features/users/update-profile.ts for the pattern to follow.
          </div>
          <p><strong>Prevention:</strong> Include a "Reference Implementation" section pointing to an existing file that demonstrates the desired pattern.</p>
        </div>
      </details>

      <details class="troubleshoot">
        <summary>Problem: "Conductor sessions feel exhausting/slow"</summary>
        <div>
          <p><strong>Symptoms:</strong> Constant back-and-forth feels like babysitting. You could have coded it faster yourself.</p>
          <p><strong>Causes:</strong></p>
          <ul>
            <li>Task is actually well-defined enough for orchestration</li>
            <li>Over-steering when agent needs freedom</li>
            <li>Not using Plan Mode to align upfront</li>
          </ul>
          <p><strong>Solutions:</strong></p>
          <ol>
            <li><strong>Use Plan Mode:</strong> Press Shift+Tab twice to enter Plan Mode. Hash out the approach, THEN let agent execute.</li>
            <li><strong>Batch your guidance:</strong> Instead of correcting each line, wait for a complete attempt, then give consolidated feedback.</li>
            <li><strong>Consider switching patterns:</strong> If the task is routine, write a spec and use orchestrator approach instead.</li>
          </ol>
          <p><strong>If you skip this:</strong> You'll burn out on AI-assisted development and miss the productivity gains.</p>
        </div>
      </details>

      <details class="troubleshoot">
        <summary>Problem: "Pattern mismatch - wrong tool for the job"</summary>
        <div>
          <p><strong>Symptoms:</strong></p>
          <ul>
            <li>Using Orchestrator on novel task ‚Üí agent spirals, produces garbage</li>
            <li>Using Conductor on routine task ‚Üí feels tedious, slow</li>
          </ul>
          <p><strong>The Decision Matrix:</strong></p>
          <table class="comparison-table">
            <tr><th>Task Type</th><th>Pattern</th></tr>
            <tr><td>Novel feature, unclear requirements</td><td>Conductor</td></tr>
            <tr><td>Bug fix requiring investigation</td><td>Conductor</td></tr>
            <tr><td>Refactoring with known target state</td><td>Either</td></tr>
            <tr><td>Migration with clear before/after</td><td>Orchestrator</td></tr>
            <tr><td>Dependency updates</td><td>Orchestrator</td></tr>
            <tr><td>Boilerplate generation from template</td><td>Orchestrator</td></tr>
          </table>
          <p><strong>Recovery:</strong> If you're mid-task and realize you're using the wrong pattern, it's okay to switch. Export the context/learnings and restart with the appropriate approach.</p>
        </div>
      </details>

      <details class="troubleshoot">
        <summary>Problem: "The 70% wall - can't get to production quality"</summary>
        <div>
          <p><strong>Symptoms:</strong> AI gets you 70% of the way fast, but the last 30% takes forever. Edge cases, error handling, tests all need heavy human work.</p>
          <p><strong>Causes:</strong> This is Addy's "70% Problem" in action - AI excels at common patterns but struggles with:</p>
          <ul>
            <li>Your specific business logic edge cases</li>
            <li>Integration with existing error handling</li>
            <li>Tests that cover real failure modes</li>
            <li>Production-grade security considerations</li>
          </ul>
          <div class="code-block">
            <button class="copy-btn" onclick="copyCode(this)">Copy</button>
# Strategy: Front-load the hard 30% in your prompts

# Instead of: "Add user authentication"
# Write:

> Add user authentication with these requirements:
>
> ## Edge Cases to Handle
> - Rate limit: 5 attempts per minute, then 15min lockout
> - Session timeout: 30 mins inactive, with warning at 25
> - Concurrent sessions: Max 3, kick oldest on 4th
>
> ## Security Requirements
> - CSRF protection on all state-changing endpoints
> - Password hashing: argon2id with salt
> - Audit log: All auth events to security_events table
>
> ## Tests Required
> - Happy path: login, logout, session refresh
> - Attack vectors: brute force, session fixation
> - Edge cases: expired token, concurrent login
          </div>
          <p><strong>Prevention:</strong> The more specific your prompt about the "hard parts," the more the AI can address them upfront rather than leaving them as your cleanup work.</p>
        </div>
      </details>

      <details class="troubleshoot">
        <summary>Problem: "Multi-agent coordination failures"</summary>
        <div>
          <p><strong>Symptoms:</strong> Running multiple orchestrator agents in parallel, but they conflict, duplicate work, or produce incompatible code.</p>
          <p><strong>Causes:</strong></p>
          <ul>
            <li>Agents modifying overlapping files</li>
            <li>No isolation strategy (branches, directories)</li>
            <li>Inconsistent specifications across agents</li>
          </ul>
          <p><strong>Solutions:</strong></p>
          <ol>
            <li><strong>Isolation by branch:</strong> Each agent works on a separate feature branch</li>
            <li><strong>Isolation by scope:</strong> Define non-overlapping file ownership per agent</li>
            <li><strong>Sequential phases:</strong> Agent 1 completes, then Agent 2 starts with updated state</li>
          </ol>
          <div class="code-block">
            <button class="copy-btn" onclick="copyCode(this)">Copy</button>
# Multi-agent isolation strategy

# Agent 1: Frontend (owns src/components/*, src/pages/*)
git checkout -b agent1/frontend-update
claude --task "Update UI components per spec-ui.md"

# Agent 2: Backend (owns src/api/*, src/services/*)
git checkout -b agent2/backend-update
claude --task "Update API endpoints per spec-api.md"

# Agent 3: Tests (owns tests/*)
# Wait for 1 & 2 to complete, then run against merged code
git merge agent1/frontend-update agent2/backend-update
claude --task "Update tests to cover new functionality"
          </div>
          <p><strong>Prevention:</strong> Define clear ownership boundaries before spawning parallel agents. Use git worktrees for true isolation.</p>
        </div>
      </details>

      <h3><span class="bionic">Eme</span>rgency Recovery</h3>

      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
# Orchestrator agent produced bad code in your branch
git reset --hard HEAD~1          # Undo last commit
git checkout main -- path/to/file  # Restore specific file

# Multiple agents created conflicting changes
git checkout main                # Return to clean state
git branch -D feature/agent-mess # Delete the broken branch

# Agent still running and causing problems
pkill -f "claude"                # Stop all Claude processes
ps aux | grep claude             # Verify they're gone

# Need to restart with clean context
exit                             # End current session
claude                           # Fresh start

# Lost track of what agents changed
git diff main..HEAD --stat       # See all changes
git log --oneline -20            # See recent commits
      </div>
    </section>

    <div class="milestone">Conductor to Orchestrator Framework Complete - You understand the evolution of AI-assisted development roles</div>

    <!-- Section 6: Related -->
    <section id="related">
      <h2><span class="bionic">Rel</span>ated <span class="bionic">Con</span>tent</h2>

      <h3>Related Practitioners</h3>
      <ul>
        <li><a href="steve-yegge.html">Steve Yegge</a> - Gas Town as advanced Orchestrator pattern</li>
        <li><a href="reuven-cohen.html">Reuven Cohen</a> - Claude-Flow swarm architecture</li>
        <li><a href="boris-cherny.html">Boris Cherny</a> - Conductor-style verification loops</li>
        <li><a href="pocock-carson.html">Pocock & Carson</a> - Ralph pattern bridges Conductor and Orchestrator</li>
      </ul>

      <h3>Chapter Integration</h3>
      <ul>
        <li><a href="../patterns/orchestration/gas-town.html">Gas Town</a> - Orchestrator pattern deep dive</li>
        <li><a href="../patterns/taxonomy/orchestration.html">Orchestration Taxonomy</a> - Pattern classification</li>
        <li><a href="../foundations/architecture/complexity-ladder.html">Complexity Ladder</a> - Level 5-6 patterns</li>
      </ul>

      <h3>Source Links (Verified)</h3>
      <ul>
        <li><a href="https://twitter.com/addyosmani">Addy Osmani on Twitter</a></li>
        <li><a href="https://addyo.substack.com">Elevate Newsletter (Substack)</a></li>
        <li><a href="https://addyosmani.com/blog/future-agentic-coding/">Conductors to Orchestrators (Blog)</a></li>
        <li><a href="https://addyo.substack.com/p/the-70-problem-hard-truths-about">The 70% Problem (Substack)</a></li>
      </ul>
    </section>

    <div class="divider-context"></div>

    <!-- What's Next Section -->
    <section id="whats-next">
      <h2><span class="bionic">Wha</span>t's Next?</h2>

      <p>Now that you understand the Conductor vs Orchestrator framework, you have several paths forward:</p>

      <div class="principle-card">
        <h3>If You're Ready for Orchestrator Patterns</h3>
        <p>Study <a href="steve-yegge.html"><strong>Steve Yegge's Gas Town</strong></a> - the most sophisticated orchestrator implementation, with 8 specialized agents working in parallel.</p>
      </div>

      <div class="principle-card">
        <h3>If You Want to Master Conductor First</h3>
        <p>Read <a href="boris-cherny.html"><strong>Boris Cherny's workflow</strong></a> - the canonical conductor pattern from the Claude Code creator. Focus on verification loops and Plan Mode.</p>
      </div>

      <div class="principle-card">
        <h3>If You're Bridging Both Patterns</h3>
        <p>Explore <a href="pocock-carson.html"><strong>Pocock & Carson's Ralph pattern</strong></a> - it elegantly bridges conductor-style verification with orchestrator-style autonomy.</p>
      </div>
    </section>

    <!-- Footer Navigation -->
    <nav class="footer-nav">
      <a href="ashley-ha.html" class="nav-prev">
        <span class="nav-direction">Previous</span>
        <span class="nav-title">Ashley Ha</span>
      </a>
      <a href="steve-yegge.html" class="nav-next">
        <span class="nav-direction">Next</span>
        <span class="nav-title">Steve Yegge</span>
      </a>
    </nav>

  </div>

  <script>
    function copyCode(button) {
      const codeBlock = button.parentElement;
      const code = codeBlock.querySelector('pre code') || codeBlock.querySelector('pre') || codeBlock;
      const text = code.textContent || code.innerText;

      navigator.clipboard.writeText(text).then(function() {
        button.textContent = 'Copied!';
        setTimeout(function() {
          button.textContent = 'Copy';
        }, 2000);
      }).catch(function(err) {
        console.error('Failed to copy: ', err);
        button.textContent = 'Failed';
        setTimeout(function() {
          button.textContent = 'Copy';
        }, 2000);
      });
    }
  </script>
  <script src="../js/search.js"></script>
</body>
</html>
