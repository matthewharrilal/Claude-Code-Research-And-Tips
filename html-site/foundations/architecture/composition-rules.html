<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pattern Composition Rules - Claude Code Architecture</title>
  <link rel="stylesheet" href="../../css/style.css">
  <style>
    .bionic { font-weight: 700; }

    .you-are-here {
      background: linear-gradient(135deg, #f0ebe3 0%, #fefcf3 100%);
      border-left: 4px solid var(--accent);
      border-radius: 8px;
      padding: 24px;
      margin-bottom: 32px;
    }

    .you-are-here h2 {
      margin: 0 0 12px 0;
      padding: 0;
      border: none;
      font-size: 1.1em;
      color: var(--accent);
    }

    .checkpoint {
      background: #f0ebe3;
      border-left: 4px solid var(--success);
      border-radius: 8px;
      padding: 20px 24px;
      margin: 24px 0;
    }

    .checkpoint-header {
      color: var(--success);
      font-weight: 600;
      font-size: 0.9em;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 8px;
    }

    .composition-diagram {
      background: var(--code-bg);
      border-radius: 12px;
      padding: 24px;
      margin: 24px 0;
      font-family: 'SF Mono', monospace;
      font-size: 0.85em;
      line-height: 1.5;
      overflow-x: auto;
      white-space: pre;
    }

    .formula-box {
      background: white;
      border: 2px solid var(--accent);
      border-radius: 12px;
      padding: 20px 24px;
      margin: 20px 0;
    }

    .formula-box h4 {
      margin: 0 0 16px 0;
      color: var(--accent);
    }

    .formula-code {
      background: var(--code-bg);
      border-radius: 8px;
      padding: 16px;
      font-family: 'SF Mono', monospace;
      font-size: 0.9em;
      margin: 12px 0;
    }

    .operator-card {
      background: var(--bg-secondary);
      border-radius: 12px;
      padding: 24px;
      margin: 24px 0;
      border-left: 4px solid var(--heading);
    }

    .operator-symbol {
      font-family: 'SF Mono', monospace;
      font-size: 1.3em;
      font-weight: 700;
      color: var(--accent);
      background: var(--code-bg);
      padding: 4px 12px;
      border-radius: 6px;
      display: inline-block;
      margin-bottom: 12px;
    }

    .anti-pattern-box {
      background: #fdf0ef;
      border: 1px solid var(--error);
      border-left: 4px solid var(--error);
      border-radius: 0 12px 12px 0;
      padding: 20px 24px;
      margin: 20px 0;
    }

    .anti-pattern-box h4 {
      color: var(--error);
      margin: 0 0 12px 0;
    }

    .copy-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 4px;
      padding: 4px 10px;
      font-size: 0.75em;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .code-block-wrapper {
      position: relative;
    }

    .code-block-wrapper:hover .copy-btn {
      opacity: 1;
    }

    .milestone {
      background: linear-gradient(90deg, #6b9b7a 0%, #2a7d7d 100%);
      color: white;
      padding: 16px 24px;
      border-radius: 8px;
      text-align: center;
      margin: 32px 0;
      font-weight: 600;
    }

    .compatibility-grid {
      font-family: 'SF Mono', monospace;
      font-size: 0.85em;
      background: var(--code-bg);
      border-radius: 8px;
      padding: 16px;
      margin: 20px 0;
      overflow-x: auto;
    }

    .tier-box {
      background: white;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px;
      margin: 16px 0;
    }

    .tier-label {
      font-size: 0.8em;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      padding: 4px 10px;
      border-radius: 12px;
      display: inline-block;
      margin-bottom: 12px;
    }

    .tier-1 .tier-label { background: #e8f4f4; color: var(--accent); }
    .tier-2 .tier-label { background: #fdf6e9; color: var(--warning); }
    .tier-3 .tier-label { background: #f0d0c8; color: var(--error); }

    .decision-tree {
      background: var(--bg-secondary);
      border-radius: 12px;
      padding: 24px;
      margin: 24px 0;
    }

    .decision-tree pre {
      background: none;
      border: none;
      padding: 0;
      margin: 0;
      font-size: 0.9em;
    }
  </style>
</head>
<body>
  <div class="container">

    <!-- Breadcrumb Navigation -->
    <nav class="nav-breadcrumb">
      <a href="../../index.html">Home</a>
      <span>/</span>
      <a href="../index.html">Foundations</a>
      <span>/</span>
      <a href="index.html">Architecture</a>
      <span>/</span>
      <strong>Composition Rules</strong>
    </nav>

    <!-- You Are Here Box -->
    <div class="you-are-here">
      <h2>You Are Here</h2>
      <p><strong><span class="bionic">Com</span>position <span class="bionic">Rul</span>es</strong> define how primitives combine into working patterns. Knowing the primitives is necessary but not sufficient - you need to understand which combinations work, which fail, and why. This page is your guide to building valid orchestration architectures.</p>
      <p><strong>Pre-requisite:</strong> <a href="primitives.html">Primitives</a> (the building blocks). <strong>Next:</strong> <a href="domain-isolation.html">Domain Isolation</a> (a specific composition pattern in depth).</p>
    </div>

    <h1><span class="bionic">Pat</span>tern <span class="bionic">Com</span>position <span class="bionic">Rul</span>es</h1>

    <p class="conversational-lead">Document how primitives COMPOSE into complex orchestration patterns for Claude Code. Compiled from 50+ extraction files documenting real-world orchestration patterns.</p>

    <!-- Table of Contents -->
    <nav class="toc">
      <h3 class="toc-title">On This Page</h3>
      <ul>
        <li><a href="#primitive-inventory">Primitive Inventory</a></li>
        <li><a href="#composition-equations">Composition Equations</a></li>
        <li><a href="#composition-operators">Composition Operators</a></li>
        <li><a href="#valid-compositions">Valid Compositions</a></li>
        <li><a href="#anti-patterns">Invalid Compositions (Anti-patterns)</a></li>
        <li><a href="#examples">Composition Examples</a></li>
        <li><a href="#decision-tree">Composition Decision Tree</a></li>
      </ul>
    </nav>

    <hr class="section-divider">

    <!-- Primitive Inventory -->
    <section id="primitive-inventory">
      <h2><span class="bionic">Pri</span>mitive <span class="bionic">Inv</span>entory</h2>

      <h3>Core Primitives</h3>
      <table>
        <thead>
          <tr><th>Primitive</th><th>Type</th><th>Function</th></tr>
        </thead>
        <tbody>
          <tr><td><strong>Bash Loop</strong></td><td>Control Flow</td><td><code>while :; do ... done</code> - Repeats until condition</td></tr>
          <tr><td><strong>Fresh Context</strong></td><td>Memory Strategy</td><td>New Claude instance per iteration</td></tr>
          <tr><td><strong>JSON Tasks</strong></td><td>State Management</td><td><code>prd.json</code> with <code>passes: true/false</code></td></tr>
          <tr><td><strong>File State</strong></td><td>Persistence</td><td><code>progress.txt</code> for append-only learnings</td></tr>
          <tr><td><strong>Git Memory</strong></td><td>Durability</td><td>Commits persist across context resets</td></tr>
          <tr><td><strong>Stop Hook</strong></td><td>Control Flow</td><td>Intercepts session exit, restarts</td></tr>
          <tr><td><strong>Completion Promise</strong></td><td>Termination</td><td><code>&lt;promise&gt;COMPLETE&lt;/promise&gt;</code> signals done</td></tr>
        </tbody>
      </table>

      <h3>Agent Primitives</h3>
      <table>
        <thead>
          <tr><th>Primitive</th><th>Type</th><th>Function</th></tr>
        </thead>
        <tbody>
          <tr><td><strong>Orchestrator</strong></td><td>Role</td><td>Coordinates without tools, delegates</td></tr>
          <tr><td><strong>Worker</strong></td><td>Role</td><td>Executes with tools, no spawning</td></tr>
          <tr><td><strong>Subagent</strong></td><td>Spawning</td><td><code>Task()</code> call for isolated context work</td></tr>
          <tr><td><strong>TaskCreate/Update</strong></td><td>Coordination</td><td>Native task management with dependencies</td></tr>
          <tr><td><strong>BlockedBy</strong></td><td>Dependency</td><td>Task dependency graph</td></tr>
        </tbody>
      </table>

      <h3>Infrastructure Primitives</h3>
      <table>
        <thead>
          <tr><th>Primitive</th><th>Type</th><th>Function</th></tr>
        </thead>
        <tbody>
          <tr><td><strong>Isolated Directory</strong></td><td>Isolation</td><td>Separate filesystem per domain</td></tr>
          <tr><td><strong>Git Worktree</strong></td><td>Isolation</td><td>Parallel branches without conflicts</td></tr>
          <tr><td><strong>tmux Pane</strong></td><td>Visibility</td><td>Visual monitoring of parallel agents</td></tr>
          <tr><td><strong>Docker Container</strong></td><td>Isolation</td><td>Full process isolation</td></tr>
          <tr><td><strong>Hooks</strong></td><td>Automation</td><td>Event-driven shell commands</td></tr>
        </tbody>
      </table>
    </section>

    <hr class="section-divider">

    <!-- Composition Equations -->
    <section id="composition-equations">
      <h2><span class="bionic">Com</span>position <span class="bionic">Equ</span>ations</h2>

      <div class="formula-box">
        <h4>Ralph = Loop + JSON Tasks + File State + Git Memory</h4>
        <div class="composition-diagram">RALPH PATTERN
+-- Bash while loop         # Repeats until completion
+-- prd.json                # Task tracking (passes: true/false)
+-- progress.txt            # Learnings across iterations
+-- Git commits             # Durability per iteration
+-- Fresh context           # Clean slate each iteration
+-- Completion promise      # Explicit termination signal</div>
        <div class="formula-code">Ralph = while(!complete) {
  FreshContext()
  + ReadState(prd.json, progress.txt, git.log)
  + Execute(next_task)
  + Verify(tests, typecheck)
  + UpdateState(prd.json, progress.txt)
  + Commit()
  + CheckCompletion()
}</div>
        <p><strong>Why it works:</strong> External memory (files, git) compensates for context reset. Each iteration benefits from accumulated learnings without context rot.</p>
      </div>

      <div class="formula-box">
        <h4>CC Mirror = Orchestrator + Workers + Task API</h4>
        <div class="composition-diagram">CC MIRROR PATTERN
+-- Central Orchestrator    # No tools, pure coordination
|   +-- Uses: TaskCreate, TaskUpdate, Task()
+-- Worker Agents           # Tools only, no spawning
|   +-- Uses: Read, Write, Edit, Bash
+-- Task Dependency Graph   # blockedBy/addBlocks
+-- Native CLI Monitor      # Arrow keys navigate agents
+-- Auto-compact            # Context management</div>
        <div class="formula-code">CC_Mirror = Orchestrator(TaskAPI) {
  TaskCreate(tasks[])
  + SetDependencies(blockedBy[])
  + for task in unblocked:
      Worker(task, tools=[Read,Write,Edit,Bash])
  + TaskUpdate(status)
}</div>
        <p><strong>Why it works:</strong> Clear separation between coordination (orchestrator) and execution (workers). Workers can't spawn, preventing recursion. Task dependencies auto-schedule work.</p>
      </div>

      <div class="formula-box">
        <h4>Gas Town = Factory + Specialized Roles + tmux</h4>
        <div class="composition-diagram">GAS TOWN PATTERN
+-- Town (~/.gt)            # HQ managing all rigs
+-- Rig                     # Individual project repo
+-- 7 Worker Roles
|   +-- Mayor               # Town-level coordination
|   +-- Deacon              # Monitoring/handshakes
|   +-- Dogs                # Quality gates
|   +-- Refinery            # Task decomposition
|   +-- Polecat             # Named persistent workers
|   +-- Witness             # Per-rig observer
|   +-- Crew                # Ephemeral workers
+-- Beads                   # Git-backed data plane
+-- MCP Agent Mail          # Email-like inter-agent comms
+-- tmux                    # Primary UI
+-- Human Overseer          # Inbox for decisions</div>
        <p><strong>Why it works:</strong> Role specialization prevents overload. Factory can scale workers indefinitely. Beads provides shared context. Human stays in loop via inbox.</p>
      </div>

      <div class="formula-box">
        <h4>Panopticon = Isolated Directories + Cron + Subagents</h4>
        <div class="composition-diagram">PANOPTICON PATTERN
+-- 8 Isolated Directories  # Domain separation
|   +-- ~/nox               # Company/product
|   +-- ~/metrics           # Analytics
|   +-- ~/email             # Communications
|   +-- ~/growth            # Marketing
|   +-- ~/trades            # Finance
|   +-- ~/health            # Wellness
|   +-- ~/writing           # Content
|   +-- ~/personal          # Life admin
+-- Cron Jobs               # Scheduled data pulls
+-- Subagents               # Short-lived task execution
+-- File Handoffs           # Inter-domain communication
+-- Checkpointing           # Text notifications on completion
+-- GUI Fallback            # Mouse/keyboard injection when no API</div>
        <p><strong>Why it works:</strong> Domain isolation prevents context pollution. Cron provides automation. File handoffs enable cross-domain awareness without context bloat.</p>
        <p>See <a href="domain-isolation.html">Domain Isolation</a> for full details.</p>
      </div>

      <div class="formula-box">
        <h4>Parallel Ralph = Git Worktrees + Multiple Loops</h4>
        <div class="composition-diagram">PARALLEL RALPH PATTERN
+-- Main Repository         # Shared git database
+-- Git Worktrees           # Isolated working directories
|   +-- wt-feature-a        # Ralph loop 1
|   +-- wt-feature-b        # Ralph loop 2
|   +-- wt-feature-c        # Ralph loop 3
+-- Parallel Execution      # Concurrent loops
+-- Merge Strategy          # Human reviews, resolves conflicts
+-- Shared PRD              # Coordinated task division</div>
        <div class="formula-code">Parallel_Ralph = for feature in features:
  git_worktree_add(feature)
  + Fork {
      Ralph(feature, worktree=wt-feature)
    }
+ Wait_All()
+ Merge(worktrees)</div>
        <p><strong>Why it works:</strong> Git worktrees provide true isolation. No file conflicts during parallel work. Shared git history for context.</p>
      </div>
    </section>

    <div class="checkpoint">
      <div class="checkpoint-header">Checkpoint: Composition Equations</div>
      <p>You should now be able to:</p>
      <ul>
        <li>Identify which primitives make up Ralph, CC Mirror, Gas Town, and Panopticon</li>
        <li>Understand WHY each composition works (what compensates for what)</li>
        <li>See the trade-offs in each approach</li>
      </ul>
    </div>

    <hr class="section-divider">

    <!-- Composition Operators -->
    <section id="composition-operators">
      <h2><span class="bionic">Com</span>position <span class="bionic">Ope</span>rators</h2>

      <div class="operator-card">
        <span class="operator-symbol">A -> B</span>
        <h4>Sequential (A then B)</h4>
        <p><strong>Pattern:</strong> Complete A before starting B.</p>
        <div class="code-block-wrapper">
          <button class="copy-btn" onclick="copyCode(this)">Copy</button>
          <pre><code># Example: Ralph iteration
Read_State() -> Execute_Task() -> Verify() -> Commit() -> Update_State()

# Bash implementation
task_a && task_b && task_c</code></pre>
        </div>
        <p><strong>When to use:</strong> Dependencies between operations. State must be consistent. Order matters.</p>
      </div>

      <div class="operator-card">
        <span class="operator-symbol">A || B</span>
        <h4>Parallel (A and B simultaneously)</h4>
        <p><strong>Pattern:</strong> Execute A and B concurrently.</p>
        <div class="code-block-wrapper">
          <button class="copy-btn" onclick="copyCode(this)">Copy</button>
          <pre><code># Example: Gas Town Polecats
Polecat_Alice || Polecat_Bob || Polecat_Carol

# Bash implementation
(task_a) & (task_b) & wait

# Git worktrees
for feature in a b c; do
  (cd wt-$feature && ./ralph.sh) &
done
wait</code></pre>
        </div>
        <p><strong>When to use:</strong> Independent tasks. No shared file access. Throughput is priority.</p>
        <p><strong>Constraints:</strong> Requires isolation (worktrees, containers, directories). May cause merge conflicts. Increases cost (multiple contexts).</p>
      </div>

      <div class="operator-card">
        <span class="operator-symbol">A { B }</span>
        <h4>Nested (A contains B)</h4>
        <p><strong>Pattern:</strong> B runs within A's context or scope.</p>
        <div class="code-block-wrapper">
          <button class="copy-btn" onclick="copyCode(this)">Copy</button>
          <pre><code># Example: Subagent within main agent
MainAgent {
  Subagent(expensive_task)
}

# Task tool spawn
Task(
  subagent_type="general-purpose",
  description="Handle Playwright verification",
  prompt="...",
  run_in_background=True
)</code></pre>
        </div>
        <p><strong>When to use:</strong> Isolate expensive operations. Specialize a subtask. Protect main context window.</p>
        <p><strong>Constraints:</strong> Subagent has fresh context. Results must be explicitly returned. No direct access to parent state.</p>
      </div>

      <div class="operator-card">
        <span class="operator-symbol">X ? A : B</span>
        <h4>Conditional (if X then A else B)</h4>
        <p><strong>Pattern:</strong> Choose path based on condition.</p>
        <div class="code-block-wrapper">
          <button class="copy-btn" onclick="copyCode(this)">Copy</button>
          <pre><code># Example: Model selection
is_complex_task ? use_opus : use_sonnet

# Completion check in Ralph
if grep -q "COMPLETE" output.txt; then
  break  # Exit loop
else
  continue  # Next iteration
fi</code></pre>
        </div>
        <p><strong>When to use:</strong> Different paths for different states. Error recovery. Optimization (cost, speed).</p>
      </div>

      <div class="operator-card">
        <span class="operator-symbol">while(!done) { A }</span>
        <h4>Iterative (Repeat A until condition)</h4>
        <p><strong>Pattern:</strong> Repeat until termination condition.</p>
        <div class="code-block-wrapper">
          <button class="copy-btn" onclick="copyCode(this)">Copy</button>
          <pre><code># Example: Ralph loop
while [ $ITERATION -le $MAX_ITERATIONS ]; do
  claude @prompt.md
  # Check completion
done</code></pre>
        </div>
        <p><strong>When to use:</strong> Unknown number of steps. Retry until success. Eventual consistency.</p>
        <div class="callout callout-warning">
          <div class="callout-title">Constraints (Critical)</div>
          <ul>
            <li>MUST have termination condition</li>
            <li>MUST have iteration limit (safety)</li>
            <li>MUST have external memory (avoid amnesia)</li>
          </ul>
        </div>
      </div>

      <div class="operator-card">
        <span class="operator-symbol">A -> spawn(B)</span>
        <h4>Delegation (A spawns B)</h4>
        <p><strong>Pattern:</strong> A creates B to handle subtask.</p>
        <div class="code-block-wrapper">
          <button class="copy-btn" onclick="copyCode(this)">Copy</button>
          <pre><code># Example: Orchestrator spawns worker
Orchestrator -> spawn(Worker(task))</code></pre>
        </div>
        <p><strong>When to use:</strong> Work needs isolated context. Parallel execution. Specialized skills.</p>
        <p><strong>Constraints:</strong> Parent can't see child's context. Child can't spawn (prevents infinite recursion). Results returned via Task output.</p>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Valid Compositions -->
    <section id="valid-compositions">
      <h2><span class="bionic">Val</span>id <span class="bionic">Com</span>positions</h2>

      <h3>High Synergy Combinations</h3>
      <table>
        <thead>
          <tr><th>Composition</th><th>Components</th><th>Synergy Reason</th></tr>
        </thead>
        <tbody>
          <tr><td><strong>Ralph + Playwright</strong></td><td>Loop + Browser Automation</td><td>Visual verification closes feedback loop</td></tr>
          <tr><td><strong>CC Mirror + Git Worktrees</strong></td><td>Task API + Isolation</td><td>Dependencies + conflict-free parallel</td></tr>
          <tr><td><strong>Gas Town + Beads</strong></td><td>Roles + Shared Context</td><td>Specialization + coordination</td></tr>
          <tr><td><strong>Ralph + Claude-Mem</strong></td><td>Fresh Context + Memory</td><td>Context reset + cross-session learning</td></tr>
          <tr><td><strong>Panopticon + Hooks</strong></td><td>Domain Isolation + Automation</td><td>Schedule + notification</td></tr>
        </tbody>
      </table>

      <h3>Component Compatibility Matrix</h3>
      <div class="compatibility-grid">                Loop  Tasks  Subagent  Worktree  Docker  Hooks  Memory
Loop             ok    ok      ok        ok        ok      ok     ok
Tasks            ok    ok      ok        --        --      ok     ok
Subagent         ok    ok      --        ok        ok      ok     ok
Worktree         ok    --      ok        ok        ok      ok     ok
Docker           ok    --      ok        ok        ok      ok     ok
Hooks            ok    ok      ok        ok        ok      ok     ok
Memory           ok    ok      ok        ok        ok      ok     ok

ok = Works well together
-- = Works with caveats</div>

      <h3>Composition Tiers</h3>

      <div class="tier-box tier-1">
        <span class="tier-label">Tier 1: Solo Developer (Quick Win)</span>
        <p><strong>Ralph = Loop + JSON + Git</strong></p>
        <ul>
          <li>Effort: 1 hour setup</li>
          <li>Cost: Single agent</li>
        </ul>
      </div>

      <div class="tier-box tier-2">
        <span class="tier-label">Tier 2: Power User (Medium Lift)</span>
        <p><strong>Ralph + Playwright = Loop + Browser + Subagents</strong></p>
        <p><strong>CC Mirror = Orchestrator + Workers + Tasks</strong></p>
        <ul>
          <li>Effort: Half-day setup</li>
          <li>Cost: Moderate (subagent overhead)</li>
        </ul>
      </div>

      <div class="tier-box tier-3">
        <span class="tier-label">Tier 3: Agent Factory (Deep Dive)</span>
        <p><strong>Gas Town = 7 Roles + Beads + tmux + Mail</strong></p>
        <p><strong>Parallel Ralph = Worktrees + Multiple Loops</strong></p>
        <ul>
          <li>Effort: Days of setup</li>
          <li>Cost: High (multiple accounts)</li>
        </ul>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Anti-patterns -->
    <section id="anti-patterns">
      <h2><span class="bionic">Inv</span>alid <span class="bionic">Com</span>positions (<span class="bionic">Ant</span>i-patterns)</h2>

      <div class="anti-pattern-box">
        <h4>Subagent Recursion</h4>
        <div class="code-block-wrapper">
          <button class="copy-btn" onclick="copyCode(this)">Copy</button>
          <pre><code>ANTI-PATTERN: Worker spawning workers

Worker {
  Subagent {
    Subagent {    # INFINITE RECURSION RISK
      ...
    }
  }
}</code></pre>
        </div>
        <p><strong>Why it breaks:</strong> Unbounded context growth. Each level spawns more. Eventually hits limits or costs explode.</p>
        <p><strong>Fix:</strong> Workers NEVER spawn. Only orchestrators spawn.</p>
      </div>

      <div class="anti-pattern-box">
        <h4>Context Pollution</h4>
        <div class="code-block-wrapper">
          <button class="copy-btn" onclick="copyCode(this)">Copy</button>
          <pre><code>ANTI-PATTERN: Multiple domains in single context

claude "
  Fix the auth bug AND
  Update the marketing copy AND
  Analyze financial data AND
  Generate workout plan
"</code></pre>
        </div>
        <p><strong>Why it breaks:</strong> Unrelated concerns bloat context. Model gets confused. Quality degrades.</p>
        <p><strong>Fix:</strong> Isolate domains (directories, sessions). One domain per context.</p>
      </div>

      <div class="anti-pattern-box">
        <h4>Parallel Without Isolation</h4>
        <div class="code-block-wrapper">
          <button class="copy-btn" onclick="copyCode(this)">Copy</button>
          <pre><code>ANTI-PATTERN: Multiple agents editing same files

Terminal 1: claude "Edit src/auth.ts"
Terminal 2: claude "Edit src/auth.ts"  # CONFLICT</code></pre>
        </div>
        <p><strong>Why it breaks:</strong> Race conditions. Overwrites. Broken state.</p>
        <p><strong>Fix:</strong> Use git worktrees. Or serialize access. Or file-level locking.</p>
      </div>

      <div class="anti-pattern-box">
        <h4>Loop Without External Memory</h4>
        <div class="code-block-wrapper">
          <button class="copy-btn" onclick="copyCode(this)">Copy</button>
          <pre><code>ANTI-PATTERN: Loop with no persistence

while true; do
  claude "Continue working"  # NO STATE BETWEEN ITERATIONS
done</code></pre>
        </div>
        <p><strong>Why it breaks:</strong> Each iteration starts from zero. No learning. No progress tracking. Repeats same mistakes.</p>
        <p><strong>Fix:</strong> Add prd.json, progress.txt, git commits. External memory compensates for context reset.</p>
      </div>

      <div class="anti-pattern-box">
        <h4>Loop Without Termination</h4>
        <div class="code-block-wrapper">
          <button class="copy-btn" onclick="copyCode(this)">Copy</button>
          <pre><code>ANTI-PATTERN: Unbounded loop

while true; do
  claude @prompt.md
done
# NO EXIT CONDITION</code></pre>
        </div>
        <p><strong>Why it breaks:</strong> Runs forever. Consumes unlimited tokens. No completion signal.</p>
        <p><strong>Fix:</strong> Add completion promise. Add max iterations. Add stuck detection.</p>
      </div>

      <div class="anti-pattern-box">
        <h4>Orchestrator With Tools</h4>
        <div class="code-block-wrapper">
          <button class="copy-btn" onclick="copyCode(this)">Copy</button>
          <pre><code>ANTI-PATTERN: Orchestrator doing implementation

Orchestrator {
  Write(file)     # WRONG - should delegate
  Edit(file)      # WRONG - should delegate
  spawn(Worker)
}</code></pre>
        </div>
        <p><strong>Why it breaks:</strong> Orchestrator context fills with tool output. Loses coordination capacity. Becomes unfocused.</p>
        <p><strong>Fix:</strong> Orchestrator ONLY uses TaskCreate, TaskUpdate, Task(). Workers do implementation.</p>
      </div>

      <div class="anti-pattern-box">
        <h4>Giant Task Sizing</h4>
        <div class="code-block-wrapper">
          <button class="copy-btn" onclick="copyCode(this)">Copy</button>
          <pre><code>ANTI-PATTERN: Tasks larger than context window

{
  "title": "Build the entire e-commerce platform",
  "passes": false
}</code></pre>
        </div>
        <p><strong>Why it breaks:</strong> Can't complete in one context window. Quality degrades as context fills. Gets stuck.</p>
        <p><strong>Fix:</strong> 2-3 sentence rule. If you can't describe it briefly, split it.</p>
      </div>
    </section>

    <div class="milestone">Milestone: Anti-Patterns Internalized</div>

    <hr class="section-divider">

    <!-- Examples -->
    <section id="examples">
      <h2><span class="bionic">Com</span>position <span class="bionic">Exa</span>mples</h2>

      <h3>Example 1: Overnight Feature Shipping</h3>
      <p><strong>Goal:</strong> Ship a feature while you sleep.</p>
      <div class="formula-code">Ralph + Playwright + Mobile Notifications

= while(!complete):
    FreshContext()
    + ReadState(prd.json, git)
    + Execute(next_task)
    + if(ui_task):
        Subagent(Playwright.verify())
      else:
        Bash(npm test)
    + Commit()
    + UpdateState()
  + Hook(AskUserQuestion) -> PushNotification(phone)</div>
      <p><strong>Result:</strong> Wake up to completed feature. Phone notification if human input needed.</p>

      <h3>Example 2: Parallel API Development</h3>
      <p><strong>Goal:</strong> Build multiple API endpoints simultaneously.</p>
      <div class="code-block-wrapper">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code>#!/bin/bash
ENDPOINTS="auth users products orders"

for ep in $ENDPOINTS; do
  git worktree add ../wt-$ep $ep-branch 2>/dev/null || true
  (cd ../wt-$ep && ./ralph.sh 15) &
done

wait
echo "All endpoints complete"

for ep in $ENDPOINTS; do
  git merge --no-edit $ep-branch
done</code></pre>
      </div>
      <p><strong>Result:</strong> 4x parallelization without merge conflicts.</p>

      <h3>Example 3: Life Automation System</h3>
      <p><strong>Goal:</strong> Personal operating system across life domains.</p>
      <div class="formula-code">Panopticon + Hooks + GUI Fallback

= for domain in [work, email, finance, health]:
    IsolatedDirectory(~/$domain)
    + Cron(nightly_data_pull)
    + while(always):
        claude($domain/brief.md)
        + if(needs_gui):
            InjectMouseKeyboard()
          else:
            API_call()
        + FileHandoff($domain/output.json -> ~/shared/)
    + Hook(completion) -> SMS(user)</div>
      <div class="code-block-wrapper">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code># Cron examples
# Pull finance data nightly
0 2 * * * cd ~/trades && claude "Generate morning brief from overnight data"

# Health sync after workout
0 18 * * * cd ~/health && claude "Analyze WHOOP data, update workout plan"</code></pre>
      </div>
      <p><strong>Result:</strong> Cross-domain awareness. Automated life admin. Morning briefs on phone.</p>
    </section>

    <hr class="section-divider">

    <!-- Decision Tree -->
    <section id="decision-tree">
      <h2><span class="bionic">Com</span>position <span class="bionic">Dec</span>ision <span class="bionic">Tre</span>e</h2>

      <div class="decision-tree">
        <pre>START: What are you building?
  |
  +-- Single feature, well-defined completion
  |    |
  |    +-- Use: RALPH LOOP
  |         Components: Loop + JSON + Git
  |         Effort: Quick Win
  |
  +-- Multiple features, need parallelization
  |    |
  |    +-- Same repo, no file conflicts?
  |    |    |
  |    |    +-- Use: PARALLEL RALPH
  |    |         Components: Worktrees + Multiple Loops
  |    |
  |    +-- Need task dependencies?
  |         |
  |         +-- Use: CC MIRROR
  |              Components: Orchestrator + Workers + Task API
  |
  +-- UI-heavy work
  |    |
  |    +-- Use: RALPH + PLAYWRIGHT
  |         Components: Loop + Browser Subagent
  |         Note: Subagent isolates high token cost
  |
  +-- Multi-domain life automation
  |    |
  |    +-- Use: PANOPTICON
  |         Components: Isolated Dirs + Cron + Handoffs
  |         Note: Domain isolation prevents context pollution
  |
  +-- Maximum throughput, cost no object
  |    |
  |    +-- Stage 7+ developer?
  |    |    |
  |    |    +-- Use: GAS TOWN
  |    |         Components: Factory + Roles + Beads + tmux
  |    |
  |    +-- Stage 5-6 developer?
  |         |
  |         +-- Use: CC MIRROR (80% of value, 10% of effort)
  |
  +-- Self-improving system
       |
       +-- Use: INFINITE ORCHESTRA
            Components: Docker + Profiles + Self-Improvement Loop
            Warning: Experimental</pre>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Quick Reference -->
    <div class="quick-ref">
      <h3 class="quick-ref-title">Quick Reference: Composition Formulas</h3>
      <table>
        <thead>
          <tr><th>Pattern</th><th>Formula</th></tr>
        </thead>
        <tbody>
          <tr><td><strong>Ralph</strong></td><td><code>while(!complete) { Fresh + State + Execute + Verify + Commit }</code></td></tr>
          <tr><td><strong>CC Mirror</strong></td><td><code>Orchestrator(TaskAPI) { spawn(Workers) }</code></td></tr>
          <tr><td><strong>Gas Town</strong></td><td><code>Factory { Mayor + Roles[] + Beads + Mail + Human }</code></td></tr>
          <tr><td><strong>Panopticon</strong></td><td><code>Domains[] { Cron + Claude + Handoffs }</code></td></tr>
          <tr><td><strong>Ralph+Play</strong></td><td><code>Ralph { Subagent(Playwright.verify()) }</code></td></tr>
          <tr><td><strong>Parallel Ralph</strong></td><td><code>Worktrees[] { Ralph(worktree) } + Merge</code></td></tr>
        </tbody>
      </table>
    </div>

    <!-- Related Pages -->
    <div class="related-pages">
      <h3>Continue Learning</h3>
      <ul>
        <li><a href="complexity-ladder.html">Complexity Ladder</a> - See which level each pattern belongs to</li>
        <li><a href="primitives.html">Primitives</a> - Deep dive on individual building blocks</li>
        <li><a href="domain-isolation.html">Domain Isolation</a> - Full Panopticon pattern documentation</li>
      </ul>
    </div>

    <!-- Footer Navigation -->
    <nav class="footer-nav">
      <a href="primitives.html">Previous: Primitives</a>
      <a href="domain-isolation.html">Next: Domain Isolation</a>
    </nav>
  </div>

  
  <script src="../../js/copy-code.js"></script>
</body>
</html>
