<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta data-pagefind-meta="chapter" content="Foundations">
  <meta data-pagefind-meta="section" content="Principles">
  <title>Core Principles - Claude Code Knowledge Base</title>
  <link rel="stylesheet" href="../../css/style.css">
  <link rel="stylesheet" href="../../css/search.css">
</head>
<body>
  <!-- Search Modal -->
  <div class="search-modal" id="searchModal" aria-hidden="true">
    <div class="search-overlay" onclick="closeSearch()"></div>
    <div class="search-content">
      <div class="search-header">
        <div class="search-input-wrapper">
          <span class="search-icon-input">&#128269;</span>
          <input type="text" id="searchInput" placeholder="Search documentation..." autocomplete="off" />
          <kbd class="search-kbd">ESC</kbd>
        </div>
      </div>
      <div class="search-filters">
        <button class="filter-btn active" data-filter="all">All</button>
        <button class="filter-btn" data-filter="ch1">Chapter 1</button>
        <button class="filter-btn" data-filter="ch2">Chapter 2</button>
        <button class="filter-btn" data-filter="ch3">Chapter 3</button>
        <button class="filter-btn" data-filter="ch4">Chapter 4</button>
        <button class="filter-btn" data-filter="ref">Reference</button>
      </div>
      <div class="search-results" id="searchResults">
        <div class="search-empty"><p>Start typing to search... (Press Cmd+K anytime)</p></div>
      </div>
      <div class="search-footer">
        <span>&#8593;&#8595; Navigate</span><span>&#8629; Select</span><span>ESC Close</span>
      </div>
    </div>
  </div>

  <div class="container">
    <!-- Search Trigger Button -->
    <button class="search-trigger" onclick="openSearch()" aria-label="Search" style="float: right; margin-bottom: 1rem;">
      <span class="search-icon">Cmd+K</span>
      <span class="search-text">Search</span>
    </button>

    <nav class="nav-breadcrumb">
      <a href="../../index.html">Home</a><span class="separator">/</span>
      <a href="../index.html">Foundations</a><span class="separator">/</span>
      <a href="index.html">Principles</a><span class="separator">/</span>
      <strong>Core Principles</strong>
    </nav>

    <div class="you-are-here">
      <h3>You Are Here</h3>
      <p><strong>Context:</strong> The <span class="bionic">fun</span>damental WHYs behind <span class="bionic">eve</span>ry <span class="bionic">pat</span>tern in Claude Code agent <span class="bionic">eng</span>ineering. These eight principles are the <span class="bionic">bed</span>rock from which all patterns <span class="bionic">der</span>ive.</p>
      <p><strong>Prerequisites:</strong> Basic familiarity with Claude Code. No prior patterns knowledge needed.</p>
      <p><strong>After this:</strong> <a href="anti-patterns.html">Anti-Patterns</a> to learn what NOT to do, or <a href="derivation-guide.html">Derivation Guide</a> to create your own patterns.</p>
    </div>

    <h1><span class="bionic">Co</span>re <span class="bionic">Prin</span>ciples of <span class="bionic">Ag</span>ent <span class="bionic">Eng</span>ineering</h1>

    <p class="lead">Understanding these principles enables you to <strong>create new patterns</strong>, <strong>adapt existing ones</strong>, and <strong>diagnose failures</strong>. Every major Claude Code pattern emerged from applying these principles to specific constraints.</p>

    <!-- Principle Hierarchy Diagram -->
    <div class="diagram-container">
      <h3><span class="bionic">Prin</span>ciple <span class="bionic">Hier</span>archy</h3>
      <div class="ascii-diagram">
<pre>
                    ┌─────────────────────────────────┐
                    │  PRINCIPLE 1: CONTEXT IS FINITE │
                    │  (The Primary Constraint)       │
                    └─────────────┬───────────────────┘
                                  │
              Everything flows from this limitation
                                  │
        ┌─────────────────────────┼─────────────────────────┐
        │                         │                         │
        ▼                         ▼                         ▼
┌───────────────────┐  ┌───────────────────┐  ┌───────────────────┐
│ PRINCIPLE 2:      │  │ PRINCIPLE 3:      │  │ PRINCIPLE 4:      │
│ External State    │  │ Fresh Context     │  │ Separation of     │
│ > Internal Memory │  │ > Extended        │  │ Concerns          │
│                   │  │   Sessions        │  │ (Orch/Worker)     │
└─────────┬─────────┘  └─────────┬─────────┘  └─────────┬─────────┘
          │                      │                      │
          └──────────────────────┼──────────────────────┘
                                 │
                    ┌────────────┴────────────┐
                    │                         │
                    ▼                         ▼
          ┌───────────────────┐    ┌───────────────────┐
          │ PRINCIPLE 5:      │    │ PRINCIPLE 6:      │
          │ Atomic, Verifiable│    │ Quality Gates     │
          │ Task Sizing       │    │ Before Commit     │
          └───────────────────┘    └───────────────────┘
</pre>
      </div>
    </div>

    <hr class="divider-context">

    <!-- Principle 1 -->
    <section id="principle-1">
      <h2><span class="bionic">Prin</span>ciple 1: <span class="bionic">Con</span>text Is The <span class="bionic">Pri</span>mary <span class="bionic">Const</span>raint</h2>

      <h3>The WHY</h3>
      <p><strong>LLMs degrade with filled context windows.</strong> This is not a minor inconvenience - it is the <span class="bionic">fun</span>damental constraint that shapes all agent engineering patterns.</p>

      <blockquote>
        "Context rot: LLMs get stupider with more tokens"
        <cite>-- @mattpocockuk</cite>
      </blockquote>

      <p>Claude's context window (~200K tokens nominal, ~100K effective for quality work) is a hard ceiling. As tokens accumulate:</p>

      <table class="data-table">
        <thead>
          <tr>
            <th>Context Level</th>
            <th>Quality Impact</th>
          </tr>
        </thead>
        <tbody>
          <tr><td>0-50%</td><td class="status-good">Full capability</td></tr>
          <tr><td>50-70%</td><td class="status-warning">Slight degradation possible</td></tr>
          <tr><td>70-85%</td><td class="status-warning">Noticeable quality loss</td></tr>
          <tr><td>85-95%</td><td class="status-error">Significant degradation, instructions forgotten</td></tr>
          <tr><td>95%+</td><td class="status-error">Failure mode - hallucinations, contradictions</td></tr>
        </tbody>
      </table>

      <h3>What Context Rot Looks Like</h3>
      <ol>
        <li><strong>Repetition</strong> - Claude starts repeating earlier statements</li>
        <li><strong>Amnesia</strong> - Forgets work done 10 minutes ago</li>
        <li><strong>Instruction Drift</strong> - CLAUDE.md directives ignored</li>
        <li><strong>Truncation</strong> - Code cut off mid-function</li>
        <li><strong>Hallucination</strong> - References files that don't exist</li>
        <li><strong>False Completion</strong> - Marks tasks done without verification</li>
      </ol>

      <h3>Derived Patterns</h3>
      <table class="data-table">
        <thead>
          <tr>
            <th>Pattern</th>
            <th>How It Addresses Context</th>
          </tr>
        </thead>
        <tbody>
          <tr><td>Ralph Loops (fresh context)</td><td>Kill and restart - zero accumulation</td></tr>
          <tr><td>File-based state</td><td>Externalize - don't store in context</td></tr>
          <tr><td>Git as memory</td><td>History lives outside context</td></tr>
          <tr><td>Subagent delegation</td><td>Expensive ops in isolated contexts</td></tr>
          <tr><td>.claudeignore</td><td>Prevent irrelevant files from loading</td></tr>
          <tr><td>CLAUDE.md brevity</td><td>Fixed context cost, minimize it</td></tr>
        </tbody>
      </table>

      <div class="callout-insight">
        <h4>The Core Insight</h4>
        <blockquote>
          "Memory is external. The agent is stateless."
          <cite>-- Ryan Carson</cite>
        </blockquote>
        <p>This isn't a bug. It's the architecture that enables reliability. Fighting it leads to failure; embracing it leads to robust systems.</p>
      </div>
    </section>

    <div class="checkpoint">
      <h4 class="checkpoint-header">Checkpoint: Principle 1</h4>
      <p>You should now understand:</p>
      <ul>
        <li>Context windows are a HARD constraint (~100K effective tokens)</li>
        <li>Quality degrades predictably as context fills</li>
        <li>Every pattern decision must consider context impact</li>
      </ul>
    </div>

    <hr class="divider-procedure">

    <!-- Principle 2 -->
    <section id="principle-2">
      <h2><span class="bionic">Prin</span>ciple 2: <span class="bionic">Ext</span>ernal <span class="bionic">Sta</span>te > <span class="bionic">Int</span>ernal <span class="bionic">Mem</span>ory</h2>

      <h3>The WHY</h3>
      <p><strong>Sessions end. Context clears. Memory evaporates.</strong> Any information stored only in the LLM's context will be lost when:</p>
      <ul>
        <li>The session ends normally</li>
        <li>Context window fills and forces reset</li>
        <li>An error crashes the session</li>
        <li>The user starts fresh</li>
      </ul>

      <p><strong>Therefore:</strong> All state that must persist beyond a single operation must be externalized to durable storage.</p>

      <div class="diagram-container">
        <h4>The Fundamental Architecture</h4>
        <div class="ascii-diagram">
<pre>
┌─────────────────────────────────────────────────────────┐
│                    THE AGENT                             │
│  ┌─────────────────────────────────────────────────────┐ │
│  │                CONTEXT WINDOW                        │ │
│  │                                                      │ │
│  │   [Ephemeral: dies when session ends]               │ │
│  │   - Current reasoning                               │ │
│  │   - Active task details                             │ │
│  │   - Recent tool outputs                             │ │
│  │                                                      │ │
│  └─────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
                           │
                    Read ↓ │ ↓ Write
                           │
┌─────────────────────────────────────────────────────────┐
│                 EXTERNAL STATE                           │
│  ┌───────────────┐  ┌───────────────┐  ┌─────────────┐  │
│  │   FILESYSTEM  │  │      GIT      │  │  DATABASE   │  │
│  │               │  │               │  │             │  │
│  │ progress.txt  │  │ Commits       │  │ claude-mem  │  │
│  │ prd.json      │  │ Branches      │  │ SQLite      │  │
│  │ CLAUDE.md     │  │ History       │  │ Checkpoints │  │
│  │ handoffs/     │  │ Diffs         │  │             │  │
│  │               │  │               │  │             │  │
│  └───────────────┘  └───────────────┘  └─────────────┘  │
│                                                          │
│  [Persistent: survives sessions, crashes, resets]        │
└─────────────────────────────────────────────────────────┘
</pre>
        </div>
      </div>

      <h3>The Three Core Files Pattern</h3>
      <table class="data-table">
        <thead>
          <tr>
            <th>File</th>
            <th>Purpose</th>
            <th>Format</th>
            <th>Rule</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>progress.txt</code></td>
            <td>Memory across iterations</td>
            <td>Markdown</td>
            <td class="status-warning">APPEND ONLY - never edit</td>
          </tr>
          <tr>
            <td><code>prd.json</code></td>
            <td>Task state tracking</td>
            <td>JSON</td>
            <td>Machine-readable, <code>passes: true/false</code></td>
          </tr>
          <tr>
            <td><code>CLAUDE.md</code></td>
            <td>Project context</td>
            <td>Markdown</td>
            <td>Under 500 tokens, essential info only</td>
          </tr>
        </tbody>
      </table>

      <div class="callout-warning">
        <h4>The Anti-Pattern</h4>
        <p><strong>Extended sessions</strong> that rely on in-context memory for continuity. The longer the session, the more accumulated context, the worse the performance.</p>
        <blockquote>
          "Each iteration spawns a NEW instance with NO memory of previous work. Continuity comes from: Git history, prd.json, progress.txt"
          <cite>-- Ryan Carson</cite>
        </blockquote>
      </div>
    </section>

    <hr class="divider-procedure">

    <!-- Principle 3 -->
    <section id="principle-3">
      <h2><span class="bionic">Prin</span>ciple 3: <span class="bionic">Fre</span>sh <span class="bionic">Con</span>text > <span class="bionic">Ext</span>ended <span class="bionic">Sess</span>ions</h2>

      <h3>The WHY</h3>
      <p><strong>Context accumulation is entropy.</strong> Every operation adds tokens. Every token added slightly degrades future operations. This compounds over time until quality collapse.</p>

      <p><strong>Fresh context is regeneration.</strong> A new instance starts at 0% context usage, at peak capability. No accumulated noise, no degraded performance, no risk of context rot.</p>

      <div class="diagram-container">
        <h4>The Fresh Context Pattern</h4>
        <div class="ascii-diagram">
<pre>
┌─────────────────────────────────────────────────────────┐
│  Iteration 1 (fresh Claude instance)                    │
│  → Read state from files (PRD, progress, git)           │
│  → Pick highest priority incomplete task                │
│  → Implement + verify                                   │
│  → Commit if passing                                    │
│  → Update external state                                │
│  → Exit                                                 │
└─────────────────────────────────────────────────────────┘
              ↓ (no memory carried forward)
┌─────────────────────────────────────────────────────────┐
│  Iteration 2 (fresh Claude instance)                    │
│  → Read state from files (now updated)                  │
│  → Repeat...                                            │
└─────────────────────────────────────────────────────────┘
</pre>
        </div>
      </div>

      <h3>Why Not Compaction?</h3>
      <ul>
        <li><strong>Compaction is lossy.</strong> When you compact, you summarize. When you summarize, you lose detail.</li>
        <li><strong>Fresh context is lossless.</strong> Files preserve full detail. Git preserves full history. Nothing is summarized away.</li>
      </ul>

      <h3>When Extended Sessions Are Acceptable</h3>
      <p>Only for:</p>
      <ul>
        <li>Single, small tasks (< 30 min)</li>
        <li>Exploratory work where loss is acceptable</li>
        <li>Debugging where context accumulation aids investigation</li>
      </ul>
      <p><strong>Even then,</strong> monitor context usage and reset before 70%.</p>
    </section>

    <div class="checkpoint">
      <h4 class="checkpoint-header">Checkpoint: Principles 2-3</h4>
      <p>You should now understand:</p>
      <ul>
        <li>The agent is STATELESS - memory lives in FILES</li>
        <li>progress.txt, prd.json, and CLAUDE.md are your three core state files</li>
        <li>Fresh context per iteration beats long sessions</li>
        <li>Compaction is lossy; files are not</li>
      </ul>
    </div>

    <hr class="divider-procedure">

    <!-- Principle 4 -->
    <section id="principle-4">
      <h2><span class="bionic">Prin</span>ciple 4: <span class="bionic">Sep</span>aration of <span class="bionic">Con</span>cerns (<span class="bionic">Orch</span>estrator/<span class="bionic">Work</span>er)</h2>

      <h3>The WHY</h3>
      <p><strong>Mixing coordination with execution causes two failures:</strong></p>
      <ol>
        <li><strong>Context pollution</strong> - The orchestrator fills its context with execution details it doesn't need</li>
        <li><strong>Role confusion</strong> - The agent oscillates between planning and doing, doing neither well</li>
      </ol>

      <blockquote class="callout-principle">
        "YOU DO NOT WRITE CODE. YOU DO NOT RUN COMMANDS. YOU DO NOT EXPLORE CODEBASES. You are the CONDUCTOR. Your agents play the instruments."
        <cite>-- @nummanali (CC Mirror)</cite>
      </blockquote>

      <div class="diagram-container">
        <h4>The Fundamental Separation</h4>
        <div class="two-column">
          <div class="column">
            <h5>ORCHESTRATOR</h5>
            <p><strong>DOES:</strong></p>
            <ul>
              <li>Decompose tasks</li>
              <li>Assign to workers</li>
              <li>Track dependencies</li>
              <li>Monitor progress</li>
              <li>Synthesize results</li>
            </ul>
            <p><strong>TOOLS:</strong> Task*, Read (1-2 files), AskUserQuestion</p>
          </div>
          <div class="column">
            <h5>WORKERS</h5>
            <p><strong>DOES:</strong></p>
            <ul>
              <li>Execute specific tasks</li>
              <li>Use tools directly</li>
              <li>Report results</li>
              <li>Follow instructions</li>
              <li>Complete and exit</li>
            </ul>
            <p><strong>TOOLS:</strong> Read, Write, Edit, Bash, Glob, Grep, WebFetch, LSP</p>
          </div>
        </div>
      </div>

      <h3>The Worker Preamble Pattern</h3>
      <p>Workers need explicit role definition to prevent role creep:</p>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
<pre>CONTEXT: You are a WORKER agent, not an orchestrator.

RULES:
- Complete ONLY the task described below
- Use tools directly (Read, Write, Edit, Bash, etc.)
- Do NOT spawn sub-agents
- Do NOT call TaskCreate or TaskUpdate
- Report your results with absolute file paths

TASK:
[Your specific task here]</pre>
      </div>

      <h3>Model Selection by Role</h3>
      <table class="data-table">
        <thead>
          <tr>
            <th>Role</th>
            <th>Recommended Model</th>
            <th>Rationale</th>
          </tr>
        </thead>
        <tbody>
          <tr><td>Orchestrator</td><td>Opus</td><td>Complex reasoning, coordination decisions</td></tr>
          <tr><td>Complex worker</td><td>Opus</td><td>Architecture, ambiguous tasks</td></tr>
          <tr><td>Standard worker</td><td>Sonnet</td><td>Implementation, testing, following patterns</td></tr>
          <tr><td>Simple worker</td><td>Haiku</td><td>File lookup, grep, simple transforms</td></tr>
        </tbody>
      </table>
    </section>

    <hr class="divider-procedure">

    <!-- Principle 5 -->
    <section id="principle-5">
      <h2><span class="bionic">Prin</span>ciple 5: <span class="bionic">Ato</span>mic, <span class="bionic">Ver</span>ifiable <span class="bionic">Ta</span>sk <span class="bionic">Siz</span>ing</h2>

      <h3>The WHY</h3>
      <p><strong>Large tasks fail for predictable reasons:</strong></p>
      <ol>
        <li><strong>Context overflow</strong> - Task requires more tokens than window allows</li>
        <li><strong>Scope creep</strong> - Undefined boundaries expand during execution</li>
        <li><strong>Verification impossible</strong> - Can't test something that isn't complete</li>
        <li><strong>Recovery lost</strong> - Partial failure means losing all progress</li>
      </ol>

      <blockquote>
        "Each story must be completable in ONE iteration (~one context window)"
        <cite>-- Ryan Carson</cite>
      </blockquote>

      <h3>The 2-3 Sentence Test</h3>
      <p><strong>If you can't describe the task in 2-3 sentences, it's too big.</strong></p>

      <div class="comparison-box">
        <div class="bad-example">
          <h5>Bad</h5>
          <p>"Implement the investor management system with types, filtering, and reporting."</p>
        </div>
        <div class="good-example">
          <h5>Good</h5>
          <p>"Add investorType column to users table with default value 'cold'. Create migration. Run npm typecheck."</p>
        </div>
      </div>

      <h3>Task Sizing Reference</h3>
      <table class="data-table">
        <thead>
          <tr>
            <th>Size</th>
            <th>Lines of Code</th>
            <th>Files</th>
            <th>Iterations</th>
            <th>Example</th>
          </tr>
        </thead>
        <tbody>
          <tr><td>XS</td><td>1-20</td><td>1</td><td>1</td><td>Add column, fix typo</td></tr>
          <tr><td>S</td><td>20-100</td><td>1-2</td><td>1</td><td>New component, endpoint</td></tr>
          <tr><td>M</td><td>100-300</td><td>2-5</td><td>1-2</td><td>Feature piece, integration</td></tr>
          <tr><td>L</td><td>300-1000</td><td>5-10</td><td>3-5</td><td>Small feature, refactor</td></tr>
          <tr class="status-error"><td>XL</td><td>1000+</td><td>10+</td><td>5+</td><td>MUST DECOMPOSE!</td></tr>
        </tbody>
      </table>
    </section>

    <hr class="divider-procedure">

    <!-- Principle 6 -->
    <section id="principle-6">
      <h2><span class="bionic">Prin</span>ciple 6: <span class="bionic">Qua</span>lity <span class="bionic">Gat</span>es <span class="bionic">Bef</span>ore <span class="bionic">Com</span>mit</h2>

      <h3>The WHY</h3>
      <p><strong>Broken code propagates.</strong> If iteration N commits broken code, iteration N+1 inherits a broken baseline. This compounds. Broken code creates debugging spirals that consume context and time.</p>

      <p><strong>Working code accumulates.</strong> If every commit passes tests, every future iteration starts from a working baseline. Progress is monotonic.</p>

      <div class="diagram-container">
        <h4>The Gate Pattern</h4>
        <div class="ascii-diagram">
<pre>
┌─────────────────────────────────────────────────────────┐
│                    QUALITY GATES                         │
├─────────────────────────────────────────────────────────┤
│                                                          │
│  BEFORE ANY COMMIT:                                     │
│                                                          │
│  1. Type checking     ──→ npm run typecheck              │
│  2. Unit tests        ──→ npm test                       │
│  3. Lint              ──→ npm run lint                   │
│  4. Integration tests ──→ npm run test:integration       │
│                                                          │
│  ALL PASS? ──→ Commit allowed                           │
│  ANY FAIL? ──→ Fix BEFORE commit, retry gates           │
│                                                          │
└─────────────────────────────────────────────────────────┘
</pre>
        </div>
      </div>

      <div class="callout-warning">
        <h4>The Anthropic Observation</h4>
        <blockquote>
          "Claude's tendency to mark features complete without proper testing... did much better at verifying end-to-end once explicitly prompted to use browser automation tools"
          <cite>-- Anthropic Best Practices</cite>
        </blockquote>
        <p><strong>The problem is real.</strong> Without explicit verification requirements, agents will declare completion prematurely.</p>
      </div>

      <h3>The CI Green Mandate</h3>
      <blockquote class="callout-principle">
        "Tests + types must pass every commit. No broken code inheritance."
        <cite>-- Ralph Pattern</cite>
      </blockquote>
      <p>This is non-negotiable. Breaking this rule causes debugging spirals, context waste, lost progress, and compound failures.</p>
    </section>

    <div class="checkpoint">
      <h4 class="checkpoint-header">Checkpoint: Principles 4-6</h4>
      <p>You should now understand:</p>
      <ul>
        <li>Orchestrators coordinate; workers execute - never mix roles</li>
        <li>Tasks must be atomic (2-3 sentences max) and completable in one context window</li>
        <li>Quality gates (tests, types) must pass BEFORE any commit</li>
        <li>Workers need explicit preambles to prevent role creep</li>
      </ul>
    </div>

    <hr class="divider-procedure">

    <!-- Principle 7 -->
    <section id="principle-7">
      <h2><span class="bionic">Prin</span>ciple 7: <span class="bionic">Iso</span>lation <span class="bionic">Pre</span>vents <span class="bionic">Cont</span>amination</h2>

      <h3>The WHY</h3>
      <p><strong>Shared state causes conflicts.</strong> When multiple agents operate on the same files: edits overwrite each other, merge conflicts arise, partial changes break builds.</p>

      <p><strong>Isolation enables parallelization.</strong> When each agent has its own space: no conflicts possible, parallel execution is safe, failures are contained.</p>

      <h3>Isolation Strategies</h3>
      <table class="data-table">
        <thead>
          <tr>
            <th>Strategy</th>
            <th>Mechanism</th>
            <th>Best For</th>
          </tr>
        </thead>
        <tbody>
          <tr><td>Directory isolation</td><td>Each agent owns a directory</td><td>Domain specialization</td></tr>
          <tr><td>Branch isolation</td><td>Each agent works on its own branch</td><td>Feature parallelism</td></tr>
          <tr><td>Worktree isolation</td><td>Git worktrees share repo, isolate checkouts</td><td>Heavy parallelism</td></tr>
          <tr><td>Container isolation</td><td>Docker containers with volume mounts</td><td>Production systems</td></tr>
          <tr><td>Process isolation</td><td>Separate Claude processes per directory</td><td>Simple parallelism</td></tr>
        </tbody>
      </table>
    </section>

    <hr class="divider-procedure">

    <!-- Principle 8 -->
    <section id="principle-8">
      <h2><span class="bionic">Prin</span>ciple 8: <span class="bionic">Exp</span>licit <span class="bionic">Comm</span>unication Over <span class="bionic">Imp</span>licit</h2>

      <h3>The WHY</h3>
      <p><strong>LLMs don't share memory.</strong> Unlike human teams who build shared context through conversation, each agent instance starts with zero knowledge of others.</p>

      <p><strong>Implicit coordination fails.</strong> Agents cannot sense what other agents are doing, know if a file is being edited elsewhere, or coordinate timing without signals.</p>

      <h3>Communication Mechanisms</h3>
      <table class="data-table">
        <thead>
          <tr>
            <th>Mechanism</th>
            <th>Use Case</th>
            <th>Example</th>
          </tr>
        </thead>
        <tbody>
          <tr><td>File-based handoffs</td><td>Agent-to-agent context transfer</td><td><code>handoff-agent1-to-agent2.json</code></td></tr>
          <tr><td>Git commits</td><td>Progress signaling</td><td>Commit message as communication</td></tr>
          <tr><td>Progress.txt</td><td>Learning propagation</td><td>Append-only log</td></tr>
          <tr><td>Task status files</td><td>Coordination state</td><td><code>prd.json</code> with passes/fails</td></tr>
        </tbody>
      </table>

      <h3>The Handoff Protocol</h3>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
<pre>// handoff-agent1-to-agent2.json
{
  "from": "agent1",
  "to": "agent2",
  "timestamp": "2026-01-09T10:30:00Z",
  "context": {
    "completed": ["API schema", "Database models"],
    "next_steps": ["Implement REST endpoints"],
    "blockers": [],
    "notes": "Using FastAPI, see docs in /api/README.md"
  }
}</pre>
      </div>

      <h3>The Promise Pattern</h3>
      <p>Explicit completion signals:</p>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
<pre>If all tasks complete, output: &lt;promise&gt;COMPLETE&lt;/promise&gt;</pre>
      </div>
      <p>The controlling loop greps for this signal. No ambiguity.</p>
    </section>

    <div class="checkpoint">
      <h4 class="checkpoint-header">Checkpoint: Principles 7-8</h4>
      <p>You should now understand:</p>
      <ul>
        <li>Parallel agents need isolation (branches, worktrees, containers)</li>
        <li>Communication must be explicit via files, not implicit</li>
        <li>Handoff JSON files enable agent-to-agent coordination</li>
        <li>Completion signals like <code>&lt;promise&gt;COMPLETE&lt;/promise&gt;</code> terminate loops</li>
      </ul>
    </div>

    <hr class="divider-context">

    <!-- Summary -->
    <section id="summary">
      <h2><span class="bionic">Sum</span>mary: The Eight <span class="bionic">Prin</span>ciples</h2>

      <ol class="principle-list">
        <li><strong>Context Is The Primary Constraint</strong> - All patterns optimize around finite context windows</li>
        <li><strong>External State > Internal Memory</strong> - Files persist, context evaporates</li>
        <li><strong>Fresh Context > Extended Sessions</strong> - New instances beat long conversations</li>
        <li><strong>Separation of Concerns</strong> - Orchestrators coordinate, workers execute</li>
        <li><strong>Atomic, Verifiable Tasks</strong> - Complete in one iteration, verify before commit</li>
        <li><strong>Quality Gates Before Commit</strong> - Tests must pass, no broken code inheritance</li>
        <li><strong>Isolation Prevents Contamination</strong> - Own your space, don't conflict</li>
        <li><strong>Explicit Communication</strong> - File-based handoffs, not implicit coordination</li>
      </ol>

      <div class="callout-principle">
        <h4>The Meta-Principle</h4>
        <p><strong>When in doubt:</strong> externalize, isolate, verify, and restart fresh.</p>
      </div>
    </section>

    <div class="milestone">
      Core Principles Complete! You now have the foundation for understanding all Claude Code patterns.
    </div>

    <!-- Quick Reference -->
    <section id="quick-reference">
      <h2><span class="bionic">Qui</span>ck <span class="bionic">Ref</span>erence: <span class="bionic">Whe</span>n Things <span class="bionic">Bre</span>ak</h2>

      <table class="data-table">
        <thead>
          <tr>
            <th>Symptom</th>
            <th>Likely Violated Principle</th>
            <th>Fix</th>
          </tr>
        </thead>
        <tbody>
          <tr><td>Agent forgets previous work</td><td>P2 (External state)</td><td>Externalize to files</td></tr>
          <tr><td>Quality degrades over time</td><td>P1/P3 (Context/Fresh)</td><td>Reset more frequently</td></tr>
          <tr><td>Workers spawn their own agents</td><td>P4 (Separation)</td><td>Explicit worker preamble</td></tr>
          <tr><td>Tasks never complete</td><td>P5 (Atomic sizing)</td><td>Smaller stories</td></tr>
          <tr><td>Broken code accumulates</td><td>P6 (Quality gates)</td><td>Enforce tests before commit</td></tr>
          <tr><td>Agents conflict on files</td><td>P7 (Isolation)</td><td>Worktrees or ownership</td></tr>
          <tr><td>Agents don't coordinate</td><td>P8 (Explicit comms)</td><td>File-based handoffs</td></tr>
        </tbody>
      </table>
    </section>

    <div class="footer-nav">
      <a href="index.html">← Principles Index</a>
      <a href="anti-patterns.html">Next: Anti-Patterns →</a>
    </div>
  </div>

  
  <script src="../../js/copy-code.js"></script>
  <script src="../../js/search.js"></script>
</body>
</html>
