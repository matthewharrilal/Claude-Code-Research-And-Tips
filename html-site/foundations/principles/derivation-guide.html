<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Deriving Patterns from First Principles - Claude Code Knowledge Base</title>
  <link rel="stylesheet" href="../../css/style.css">
</head>
<body>
  <div class="container">
    <nav class="nav-breadcrumb">
      <a href="../../index.html">Home</a><span>→</span>
      <a href="../index.html">Foundations</a><span>→</span>
      <a href="index.html">Principles</a><span>→</span>
      Derivation Guide
    </nav>

    <div class="you-are-here">
      <h3>You Are Here</h3>
      <p><strong>Context:</strong> The <span class="bionic">ult</span>imate goal: learn to <span class="bionic">inv</span>ent new patterns, not just copy existing ones. Every major Claude Code pattern emerged from applying core principles to specific constraints.</p>
      <p><strong>Prerequisites:</strong> <a href="core.html">Core Principles</a> (understand all 8 principles first)</p>
      <p><strong>After this:</strong> You're ready for the <a href="../../patterns/index.html">Patterns Library</a> to see derivation in action.</p>
    </div>

    <h1><span class="bionic">Der</span>iving <span class="bionic">Pat</span>terns from <span class="bionic">Fir</span>st <span class="bionic">Prin</span>ciples</h1>

    <p class="lead">Understanding the derivation process is <strong>more valuable than memorizing patterns</strong>. This guide teaches you to create patterns for novel constraints.</p>

    <div class="callout-insight">
      <h3>The Philosophy</h3>
      <p>Every major Claude Code pattern emerged from someone applying a few core principles to a specific constraint. Understanding this process is more valuable than memorizing patterns.</p>
    </div>

    <!-- Table of Contents -->
    <nav class="toc">
      <h3>Quick Navigation</h3>
      <ul>
        <li><a href="#core-principles">Core Principles Recap</a></li>
        <li><a href="#derivation-process">The Derivation Process</a></li>
        <li><a href="#primitives">The Primitives Catalog</a></li>
        <li><a href="#worked-examples">Worked Examples</a></li>
        <li><a href="#diy-derivation">DIY Pattern Derivation</a></li>
        <li><a href="#practice-problems">Practice Problems</a></li>
        <li><a href="#validation">Validation Checklist</a></li>
      </ul>
    </nav>

    <hr class="divider-context">

    <!-- Core Principles Recap -->
    <section id="core-principles">
      <h2><span class="bionic">Co</span>re <span class="bionic">Prin</span>ciples <span class="bionic">Rec</span>ap</h2>

      <p>Before deriving any pattern, internalize these foundational truths:</p>

      <table class="data-table principles-recap">
        <thead>
          <tr>
            <th>#</th>
            <th>Principle</th>
            <th>Implication</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>1</td>
            <td><strong>Context Is Primary Constraint</strong></td>
            <td>Any pattern that doesn't respect context limits will eventually fail</td>
          </tr>
          <tr>
            <td>2</td>
            <td><strong>External State > Internal Memory</strong></td>
            <td>Memory is files. Not conversation. Not summaries. Files.</td>
          </tr>
          <tr>
            <td>3</td>
            <td><strong>Verification Is Non-Negotiable</strong></td>
            <td>Any autonomous pattern must include verification steps, or errors compound</td>
          </tr>
          <tr>
            <td>4</td>
            <td><strong>Separation of Concerns</strong></td>
            <td>Orchestrators orchestrate. Workers execute. Never mix.</td>
          </tr>
          <tr>
            <td>5</td>
            <td><strong>Structured Data > Natural Language</strong></td>
            <td>JSON for machines, Markdown for humans</td>
          </tr>
          <tr>
            <td>6</td>
            <td><strong>Fresh Context > Extended Sessions</strong></td>
            <td>Prefer iteration loops over single long sessions</td>
          </tr>
          <tr>
            <td>7</td>
            <td><strong>Isolation Enables Parallelism</strong></td>
            <td>Design for isolation first, coordination second</td>
          </tr>
        </tbody>
      </table>
    </section>

    <hr class="divider-procedure">

    <!-- The Derivation Process -->
    <section id="derivation-process">
      <h2><span class="bionic">The</span> <span class="bionic">Der</span>ivation <span class="bionic">Pro</span>cess</h2>

      <p>Every pattern follows this derivation sequence:</p>

      <div class="diagram-container derivation-steps">
        <div class="ascii-diagram">
<pre>
┌─────────────────────────────────────────────────────────────────┐
│                    THE DERIVATION PROCESS                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                   │
│  Step 1: IDENTIFY THE CONSTRAINT                                 │
│          What limitation or requirement are you solving for?     │
│          • Context exhaustion?                                   │
│          • Need parallelism?                                     │
│          • Long-running work?                                    │
│          • Quality degradation?                                  │
│                                                                   │
│  Step 2: APPLY RELEVANT PRINCIPLES                               │
│          Which core principles address this constraint?          │
│          • External state for memory?                            │
│          • Fresh context for quality?                            │
│          • Separation for clarity?                               │
│          • Isolation for parallelism?                            │
│                                                                   │
│  Step 3: COMPOSE PRIMITIVES                                      │
│          What building blocks combine to implement?              │
│          • Loops, JSON state, file handoffs?                     │
│          • Task tool, model selection, preambles?                │
│          • Git worktrees, branches, hooks?                       │
│                                                                   │
│  Step 4: VALIDATE COMPOSITION                                    │
│          Does the pattern actually work?                         │
│          • Does it respect context limits?                       │
│          • Is state recoverable on failure?                      │
│          • Are there verification steps?                         │
│          • Can humans intervene when needed?                     │
│                                                                   │
└─────────────────────────────────────────────────────────────────┘
</pre>
        </div>
      </div>
    </section>

    <hr class="divider-procedure">

    <!-- The Primitives Catalog -->
    <section id="primitives">
      <h2><span class="bionic">The</span> <span class="bionic">Pri</span>mitives <span class="bionic">Cat</span>alog</h2>

      <p>These are the building blocks you compose into patterns:</p>

      <h3>Execution Primitives</h3>
      <table class="data-table">
        <thead>
          <tr>
            <th>Primitive</th>
            <th>What It Does</th>
            <th>When To Use</th>
          </tr>
        </thead>
        <tbody>
          <tr><td><code>claude "..."</code></td><td>Single Claude invocation</td><td>Atomic task execution</td></tr>
          <tr><td><code>for</code> loop</td><td>Repeated invocations</td><td>Sequential iteration</td></tr>
          <tr><td><code>&</code> (background)</td><td>Parallel execution</td><td>Independent tasks</td></tr>
          <tr><td><code>Task()</code> tool</td><td>Spawn subagent</td><td>Delegated work</td></tr>
          <tr><td>Git worktree</td><td>Isolated directory</td><td>Parallel branches</td></tr>
          <tr><td>Docker container</td><td>Isolated environment</td><td>Maximum isolation</td></tr>
        </tbody>
      </table>

      <h3>State Primitives</h3>
      <table class="data-table">
        <thead>
          <tr>
            <th>Primitive</th>
            <th>What It Does</th>
            <th>When To Use</th>
          </tr>
        </thead>
        <tbody>
          <tr><td><code>progress.txt</code></td><td>Append-only log</td><td>Cross-iteration memory</td></tr>
          <tr><td><code>prd.json</code></td><td>Task state tracking</td><td>Pass/fail status</td></tr>
          <tr><td><code>CLAUDE.md</code></td><td>Project context</td><td>Onboarding/constraints</td></tr>
          <tr><td>Git commit</td><td>Checkpoint</td><td>State preservation</td></tr>
          <tr><td>Handoff JSON</td><td>Agent communication</td><td>Multi-agent coordination</td></tr>
          <tr><td><code>status.json</code></td><td>Current state</td><td>Live monitoring</td></tr>
        </tbody>
      </table>

      <h3>Control Primitives</h3>
      <table class="data-table">
        <thead>
          <tr>
            <th>Primitive</th>
            <th>What It Does</th>
            <th>When To Use</th>
          </tr>
        </thead>
        <tbody>
          <tr><td>Completion signal</td><td><code>&lt;promise&gt;COMPLETE&lt;/promise&gt;</code></td><td>Loop termination</td></tr>
          <tr><td>Hooks</td><td>Lifecycle automation</td><td>Notifications, formatting</td></tr>
          <tr><td>Quality gates</td><td>Tests/types before commit</td><td>Verification enforcement</td></tr>
          <tr><td>Timeout</td><td>Max iterations</td><td>Safety limits</td></tr>
          <tr><td>Worker preamble</td><td>Role enforcement</td><td>Orchestrator/worker separation</td></tr>
        </tbody>
      </table>

      <h3>Communication Primitives</h3>
      <table class="data-table">
        <thead>
          <tr>
            <th>Primitive</th>
            <th>What It Does</th>
            <th>When To Use</th>
          </tr>
        </thead>
        <tbody>
          <tr><td>File handoff</td><td>JSON between agents</td><td>Async coordination</td></tr>
          <tr><td>Shared volume</td><td>Docker communication</td><td>Container patterns</td></tr>
          <tr><td>Git branch</td><td>Merge-based sync</td><td>Feature isolation</td></tr>
          <tr><td>TaskList/TaskGet</td><td>Native task API</td><td>CC Mirror orchestration</td></tr>
        </tbody>
      </table>
    </section>

    <div class="checkpoint">
      <h4 class="checkpoint-header">Checkpoint: Primitives</h4>
      <p>You should now understand:</p>
      <ul>
        <li><strong>Execution:</strong> How to invoke Claude (single, loop, parallel, subagent)</li>
        <li><strong>State:</strong> Where to store information (progress.txt, prd.json, git)</li>
        <li><strong>Control:</strong> How to manage flow (signals, gates, timeouts)</li>
        <li><strong>Communication:</strong> How agents talk (files, volumes, branches)</li>
      </ul>
    </div>

    <hr class="divider-procedure">

    <!-- Worked Examples -->
    <section id="worked-examples">
      <h2><span class="bionic">Wor</span>ked <span class="bionic">Exa</span>mples</h2>

      <!-- Example 1: Ralph Wiggum -->
      <div class="worked-example">
        <h3>Example 1: Deriving Ralph Wiggum from Principles</h3>

        <h4>Step 1: Identify the Constraint</h4>
        <blockquote>"I need autonomous execution without quality degradation over time"</blockquote>
        <p>The constraint is: <strong>long-running autonomous work that doesn't get stupider.</strong></p>

        <h4>Step 2: Apply Relevant Principles</h4>
        <ul>
          <li><strong>Context Is Primary Constraint</strong> - Quality degrades with context usage</li>
          <li><strong>Fresh Context > Extended Sessions</strong> - New instances don't accumulate context pollution</li>
          <li><strong>External State > Internal Memory</strong> - State must persist outside conversation</li>
          <li><strong>Verification Is Non-Negotiable</strong> - Each iteration must verify its work</li>
        </ul>

        <h4>Step 3: Compose Primitives</h4>
        <table class="data-table">
          <thead>
            <tr>
              <th>Principle</th>
              <th>Primitive Implementation</th>
            </tr>
          </thead>
          <tbody>
            <tr><td>Fresh context</td><td>Bash loop spawning new Claude instances</td></tr>
            <tr><td>External memory</td><td><code>progress.txt</code> (append-only), <code>prd.json</code> (task state)</td></tr>
            <tr><td>Verification</td><td>Tests + types must pass before marking complete</td></tr>
            <tr><td>Termination</td><td><code>&lt;promise&gt;COMPLETE&lt;/promise&gt;</code> signal for loop exit</td></tr>
          </tbody>
        </table>

        <h4>Step 4: Validate Composition</h4>
        <div class="code-block">
          <button class="copy-btn" onclick="copyCode(this)">Copy</button>
<pre># The resulting pattern
for (( i=1; i<=$MAX_ITERATIONS; i++ )); do
  claude "Review prd.json. Pick ONE task with passes: false.
          Implement it. Run tests.
          If passing, mark passes: true, commit.
          Append learnings to progress.txt.
          If ALL complete, output: &lt;promise&gt;COMPLETE&lt;/promise&gt;"

  if grep -q "&lt;promise&gt;COMPLETE&lt;/promise&gt;" output.txt; then
    break
  fi
done</pre>
        </div>

        <h4>Validation Questions</h4>
        <ul class="checklist validation">
          <li class="passed">Context limits respected? Yes - fresh instance each iteration</li>
          <li class="passed">State recoverable? Yes - git commits + files persist</li>
          <li class="passed">Verification steps? Yes - tests must pass before commit</li>
          <li class="passed">Human intervention? Yes - can CTRL+C, edit files, restart</li>
        </ul>

        <div class="result-badge">Result: Ralph Wiggum pattern</div>
      </div>

      <!-- Example 2: CC Mirror -->
      <div class="worked-example">
        <h3>Example 2: Deriving CC Mirror from Principles</h3>

        <h4>Step 1: Identify the Constraint</h4>
        <blockquote>"I need multiple agents working in parallel without chaos"</blockquote>
        <p>The constraint is: <strong>parallelism without coordination failures.</strong></p>

        <h4>Step 2: Apply Relevant Principles</h4>
        <ul>
          <li><strong>Separation of Concerns</strong> - Planning and execution must be separate roles</li>
          <li><strong>Isolation Enables Parallelism</strong> - Workers need isolated contexts</li>
          <li><strong>External State > Internal Memory</strong> - Coordination via files/APIs, not conversation</li>
          <li><strong>Verification Is Non-Negotiable</strong> - Each worker's output must be checked</li>
        </ul>

        <h4>Step 3: Compose Primitives</h4>
        <table class="data-table">
          <thead>
            <tr>
              <th>Principle</th>
              <th>Primitive Implementation</th>
            </tr>
          </thead>
          <tbody>
            <tr><td>Separation</td><td>Orchestrator (Opus) + Workers (Sonnet/Haiku)</td></tr>
            <tr><td>Isolation</td><td>Task tool spawns isolated subagents</td></tr>
            <tr><td>External state</td><td>TaskCreate/TaskUpdate API for coordination</td></tr>
            <tr><td>Verification</td><td>Acceptance criteria in task definitions</td></tr>
          </tbody>
        </table>

        <h4>Step 4: Validate Composition</h4>
        <div class="code-block">
          <button class="copy-btn" onclick="copyCode(this)">Copy</button>
<pre>Orchestrator:
  - Tools: Task*, AskUserQuestion, Read (minimal)
  - NEVER: Write, Edit, Bash

Worker Preamble:
  CONTEXT: You are a WORKER agent, not an orchestrator.
  RULES:
  - Complete ONLY the task described below
  - Do NOT spawn sub-agents
  - Do NOT call TaskCreate or TaskUpdate
  TASK: [specific work]</pre>
        </div>

        <div class="result-badge">Result: CC Mirror (Hub-and-Spoke Orchestration) pattern</div>
      </div>

      <!-- Example 3: Git Worktree Parallelism -->
      <div class="worked-example">
        <h3>Example 3: Deriving Git Worktree Parallelism from Principles</h3>

        <h4>Step 1: Identify the Constraint</h4>
        <blockquote>"I need multiple features developed simultaneously without file conflicts"</blockquote>
        <p>The constraint is: <strong>parallel work on shared codebase without conflicts.</strong></p>

        <h4>Step 2: Apply Relevant Principles</h4>
        <ul>
          <li><strong>Isolation Enables Parallelism</strong> - Each agent needs its own working directory</li>
          <li><strong>External State > Internal Memory</strong> - Git history is shared, files are isolated</li>
          <li><strong>Fresh Context > Extended</strong> - Each worktree gets fresh agent instances</li>
        </ul>

        <h4>Step 3: Compose Primitives</h4>
        <table class="data-table">
          <thead>
            <tr>
              <th>Principle</th>
              <th>Primitive Implementation</th>
            </tr>
          </thead>
          <tbody>
            <tr><td>Isolation</td><td>Git worktrees create separate directories</td></tr>
            <tr><td>Shared history</td><td>Same .git database across worktrees</td></tr>
            <tr><td>Independent execution</td><td>Separate Claude instance per worktree</td></tr>
            <tr><td>Merge coordination</td><td>Human reviews and merges PRs</td></tr>
          </tbody>
        </table>

        <h4>Step 4: Validate Composition</h4>
        <div class="code-block">
          <button class="copy-btn" onclick="copyCode(this)">Copy</button>
<pre># Create isolated worktrees
git worktree add ../wt-feature-auth feature-auth
git worktree add ../wt-feature-payments feature-payments

# Run parallel agents
(cd ../wt-feature-auth && claude "Implement auth") &
(cd ../wt-feature-payments && claude "Implement payments") &
wait

# Human merges
git checkout main
git merge feature-auth
git merge feature-payments</pre>
        </div>

        <div class="result-badge">Result: Git Worktree Parallelism pattern</div>
      </div>

      <!-- Example 4: File-Based Handoffs -->
      <div class="worked-example">
        <h3>Example 4: Deriving File-Based Handoffs from Principles</h3>

        <h4>Step 1: Identify the Constraint</h4>
        <blockquote>"Agents need to pass context to each other without conversation"</blockquote>
        <p>The constraint is: <strong>inter-agent communication without shared memory.</strong></p>

        <h4>Step 2: Apply Relevant Principles</h4>
        <ul>
          <li><strong>External State > Internal Memory</strong> - Communication via filesystem</li>
          <li><strong>Structured Data > Natural Language</strong> - JSON for machine parsing</li>
          <li><strong>Context Is Primary</strong> - Handoffs should be compact, not full dumps</li>
        </ul>

        <h4>Step 3: Compose Primitives</h4>
        <table class="data-table">
          <thead>
            <tr>
              <th>Principle</th>
              <th>Primitive Implementation</th>
            </tr>
          </thead>
          <tbody>
            <tr><td>External state</td><td>JSON files in shared directory</td></tr>
            <tr><td>Structured data</td><td>Schema: from, to, context, completed, next_steps</td></tr>
            <tr><td>Compact context</td><td>Summary of relevant work, not full history</td></tr>
          </tbody>
        </table>

        <h4>Step 4: Validate Composition</h4>
        <div class="code-block">
          <button class="copy-btn" onclick="copyCode(this)">Copy</button>
<pre>// handoff-agent1-to-agent2.json
{
  "from": "agent1",
  "to": "agent2",
  "timestamp": "2026-01-09T10:30:00Z",
  "context": {
    "completed": ["API schema", "Database models"],
    "next_steps": ["Implement REST endpoints"],
    "blockers": [],
    "notes": "Using FastAPI, see docs in /api/README.md"
  }
}</pre>
        </div>

        <div class="result-badge">Result: File-Based Handoff pattern</div>
      </div>
    </section>

    <hr class="divider-procedure">

    <!-- DIY Pattern Derivation -->
    <section id="diy-derivation">
      <h2><span class="bionic">DI</span>Y <span class="bionic">Pat</span>tern <span class="bionic">Der</span>ivation</h2>

      <p>Use this worksheet when facing a new problem:</p>

      <div class="worksheet">
        <h3>Step 1: State Your Constraint</h3>
        <div class="worksheet-field">
          <label>I need to:</label>
          <input type="text" placeholder="[describe what you're trying to accomplish]" />
        </div>
        <div class="worksheet-field">
          <label>The core challenge is:</label>
          <input type="text" placeholder="[the main obstacle]" />
        </div>
        <div class="worksheet-field">
          <label>This is hard because:</label>
          <input type="text" placeholder="[why simple approaches fail]" />
        </div>

        <h3>Step 2: Identify Applicable Principles</h3>
        <table class="data-table worksheet-table">
          <thead>
            <tr>
              <th>Principle</th>
              <th>Applies?</th>
              <th>How?</th>
            </tr>
          </thead>
          <tbody>
            <tr><td>Context is primary constraint</td><td><input type="checkbox" /></td><td><input type="text" /></td></tr>
            <tr><td>External state > internal memory</td><td><input type="checkbox" /></td><td><input type="text" /></td></tr>
            <tr><td>Verification is non-negotiable</td><td><input type="checkbox" /></td><td><input type="text" /></td></tr>
            <tr><td>Separation of concerns</td><td><input type="checkbox" /></td><td><input type="text" /></td></tr>
            <tr><td>Structured data > natural language</td><td><input type="checkbox" /></td><td><input type="text" /></td></tr>
            <tr><td>Fresh context > extended sessions</td><td><input type="checkbox" /></td><td><input type="text" /></td></tr>
            <tr><td>Isolation enables parallelism</td><td><input type="checkbox" /></td><td><input type="text" /></td></tr>
          </tbody>
        </table>

        <h3>Step 3: Select Primitives</h3>
        <div class="primitive-selection">
          <h4>Execution</h4>
          <label><input type="checkbox" /> Single invocation</label>
          <label><input type="checkbox" /> Loop</label>
          <label><input type="checkbox" /> Parallel</label>
          <label><input type="checkbox" /> Subagent</label>
          <label><input type="checkbox" /> Worktree</label>
          <label><input type="checkbox" /> Container</label>
        </div>
        <div class="primitive-selection">
          <h4>State</h4>
          <label><input type="checkbox" /> progress.txt</label>
          <label><input type="checkbox" /> prd.json</label>
          <label><input type="checkbox" /> CLAUDE.md</label>
          <label><input type="checkbox" /> Git commits</label>
          <label><input type="checkbox" /> Handoff JSON</label>
          <label><input type="checkbox" /> status.json</label>
        </div>
        <div class="primitive-selection">
          <h4>Control</h4>
          <label><input type="checkbox" /> Completion signal</label>
          <label><input type="checkbox" /> Hooks</label>
          <label><input type="checkbox" /> Quality gates</label>
          <label><input type="checkbox" /> Timeout</label>
          <label><input type="checkbox" /> Worker preamble</label>
        </div>
        <div class="primitive-selection">
          <h4>Communication</h4>
          <label><input type="checkbox" /> File handoff</label>
          <label><input type="checkbox" /> Shared volume</label>
          <label><input type="checkbox" /> Git branch</label>
          <label><input type="checkbox" /> Task API</label>
        </div>
      </div>
    </section>

    <hr class="divider-procedure">

    <!-- Practice Problems -->
    <section id="practice-problems">
      <h2><span class="bionic">Pra</span>ctice <span class="bionic">Prob</span>lems</h2>

      <!-- Problem 1 -->
      <div class="practice-problem">
        <h3>Problem 1: The Documentation Gap</h3>
        <p><strong>Constraint:</strong> You need to generate comprehensive documentation for a large codebase, but reading the entire codebase would exhaust context.</p>

        <div class="hints">
          <h4>Hints</h4>
          <ul>
            <li>What principle addresses context exhaustion?</li>
            <li>How can you process the codebase in chunks?</li>
            <li>How should documentation state accumulate?</li>
          </ul>
        </div>

        <details class="solution">
          <summary>One Possible Solution</summary>
          <div class="solution-content">
            <h4>Principles Applied</h4>
            <ul>
              <li>Context is primary - Process in chunks</li>
              <li>External state - Accumulate docs in files</li>
              <li>Fresh context - New instance per module</li>
            </ul>

            <h4>Primitives</h4>
            <ul>
              <li>Loop over modules</li>
              <li>Per-module doc file</li>
              <li>Aggregation step at end</li>
            </ul>

            <h4>Pattern</h4>
            <div class="code-block">
              <button class="copy-btn" onclick="copyCode(this)">Copy</button>
<pre>for module in $(find src -type d -maxdepth 1); do
  claude "Document $module only. Write to docs/${module}.md"
done
claude "Synthesize docs/*.md into docs/README.md"</pre>
            </div>
          </div>
        </details>
      </div>

      <!-- Problem 2 -->
      <div class="practice-problem">
        <h3>Problem 2: The Security Audit</h3>
        <p><strong>Constraint:</strong> You need multiple security perspectives reviewing code (OWASP, crypto, injection, etc.) but a single agent can't hold all expertise.</p>

        <div class="hints">
          <h4>Hints</h4>
          <ul>
            <li>What principle addresses multiple perspectives?</li>
            <li>How do specialists work without conflicting?</li>
            <li>How are findings aggregated?</li>
          </ul>
        </div>

        <details class="solution">
          <summary>One Possible Solution</summary>
          <div class="solution-content">
            <h4>Principles Applied</h4>
            <ul>
              <li>Separation of concerns - Specialized reviewers</li>
              <li>Isolation - Each reviewer has own context</li>
              <li>External state - Findings in shared files</li>
            </ul>

            <h4>Pattern</h4>
            <div class="code-block">
              <button class="copy-btn" onclick="copyCode(this)">Copy</button>
<pre>Spawn in parallel:
- OWASP reviewer → findings/owasp.md
- Crypto reviewer → findings/crypto.md
- Injection reviewer → findings/injection.md

Then: Aggregator synthesizes findings/security-report.md</pre>
            </div>
          </div>
        </details>
      </div>

      <!-- Problem 3 -->
      <div class="practice-problem">
        <h3>Problem 3: The Living Specification</h3>
        <p><strong>Constraint:</strong> Requirements change during development. How do you prevent the PRD from becoming stale?</p>

        <div class="hints">
          <h4>Hints</h4>
          <ul>
            <li>What principle addresses state management?</li>
            <li>When should the spec update?</li>
            <li>How do you prevent drift between spec and code?</li>
          </ul>
        </div>

        <details class="solution">
          <summary>One Possible Solution</summary>
          <div class="solution-content">
            <h4>Pattern</h4>
            <div class="code-block">
              <button class="copy-btn" onclick="copyCode(this)">Copy</button>
<pre>PostToolUse hook on Edit:
  If modifying behavior → Prompt: "Does this change require PRD update?"

Before each Ralph iteration:
  Validate: Current code matches PRD assertions

Explicit PRD update mode:
  "Update PRD for new requirement: [X]"
  Regenerate affected user stories</pre>
            </div>
          </div>
        </details>
      </div>

      <!-- Problem 4 -->
      <div class="practice-problem">
        <h3>Problem 4: The Cost Optimizer</h3>
        <p><strong>Constraint:</strong> You're running expensive Opus calls but many tasks don't need that capability. How do you minimize cost while maintaining quality?</p>

        <div class="hints">
          <h4>Hints</h4>
          <ul>
            <li>What principle addresses separation?</li>
            <li>How do you classify task complexity?</li>
            <li>What triggers model escalation?</li>
          </ul>
        </div>

        <details class="solution">
          <summary>One Possible Solution</summary>
          <div class="solution-content">
            <h4>Pattern</h4>
            <div class="code-block">
              <button class="copy-btn" onclick="copyCode(this)">Copy</button>
<pre>{
  "task": "Implement login",
  "complexity": "simple",  // simple → Haiku, medium → Sonnet, complex → Opus
  "escalated": false
}

If simple task fails twice:
  Set escalated: true
  Retry with Sonnet

If Sonnet fails:
  Escalate to Opus

Complexity heuristics:
- File lookup: simple
- Pattern implementation: medium
- Architecture decision: complex</pre>
            </div>
          </div>
        </details>
      </div>

      <!-- Problem 5 -->
      <div class="practice-problem">
        <h3>Problem 5: The Overnight Orchestrator</h3>
        <p><strong>Constraint:</strong> You want to run CC Mirror-style multi-agent work overnight, but need to handle failures gracefully and notify you of critical issues.</p>

        <div class="hints">
          <h4>Hints</h4>
          <ul>
            <li>Combine which existing patterns?</li>
            <li>What triggers human notification?</li>
            <li>How does work resume after failure?</li>
          </ul>
        </div>

        <details class="solution">
          <summary>One Possible Solution</summary>
          <div class="solution-content">
            <h4>Pattern</h4>
            <div class="code-block">
              <button class="copy-btn" onclick="copyCode(this)">Copy</button>
<pre>Outer Ralph loop:
  Inner CC Mirror orchestration:
    Workers with:
      - Max retry = 3
      - Checkpoint after each task
      - Notification hook on repeated failure

  If orchestrator exits cleanly:
    Check all tasks complete → exit loop
    Else → continue next iteration

  If orchestrator fails:
    Notification hook → Poke/Pushover
    Wait for human input or timeout
    Resume from checkpoint</pre>
            </div>
          </div>
        </details>
      </div>
    </section>

    <div class="checkpoint">
      <h4 class="checkpoint-header">Checkpoint: Derivation Skills</h4>
      <p>You should now be able to:</p>
      <ul>
        <li>Identify the core constraint in any problem</li>
        <li>Map constraints to relevant principles</li>
        <li>Select appropriate primitives</li>
        <li>Compose primitives into a working pattern</li>
        <li>Validate the pattern against key criteria</li>
      </ul>
    </div>

    <hr class="divider-checkpoint">

    <!-- Validation Checklist -->
    <section id="validation">
      <h2><span class="bionic">Val</span>idation <span class="bionic">Check</span>list</h2>

      <p>Before deploying any derived pattern, verify:</p>

      <h3>Context Management</h3>
      <ul class="checklist">
        <li>Maximum context usage estimated and acceptable</li>
        <li>Fresh context strategy if long-running</li>
        <li>No unbounded state accumulation</li>
      </ul>

      <h3>State Durability</h3>
      <ul class="checklist">
        <li>All state persisted to filesystem or git</li>
        <li>Can resume from any checkpoint</li>
        <li>State format is parseable (JSON/YAML/structured MD)</li>
      </ul>

      <h3>Error Handling</h3>
      <ul class="checklist">
        <li>Failures detected and logged</li>
        <li>Retry strategy defined</li>
        <li>Escalation path for repeated failures</li>
        <li>Human notification for critical issues</li>
      </ul>

      <h3>Verification</h3>
      <ul class="checklist">
        <li>Quality gates (tests/types) in workflow</li>
        <li>No marking complete without verification</li>
        <li>Cross-checking for multi-agent outputs</li>
      </ul>

      <h3>Human Oversight</h3>
      <ul class="checklist">
        <li>Can pause at any point</li>
        <li>State is inspectable</li>
        <li>Overrides are possible</li>
        <li>Audit trail exists</li>
      </ul>

      <h3>Termination</h3>
      <ul class="checklist">
        <li>Clear completion criteria</li>
        <li>Maximum iterations/timeout defined</li>
        <li>Graceful shutdown preserves state</li>
      </ul>
    </section>

    <hr class="divider-context">

    <!-- The Meta-Principle -->
    <section id="meta-principle">
      <h2><span class="bionic">The</span> <span class="bionic">Me</span>ta-<span class="bionic">Prin</span>ciple</h2>

      <div class="callout-principle">
        <blockquote>
          Patterns are not gospel. They are crystalized solutions to specific constraints.
        </blockquote>
      </div>

      <p>When your constraint changes, derive a new pattern. When principles evolve, revisit existing patterns. <strong>The derivation skill matters more than pattern memorization.</strong></p>

      <h3>The Progression</h3>
      <ol class="progression-list">
        <li><strong>Learn existing patterns</strong> - Immediate productivity</li>
        <li><strong>Understand the principles</strong> - Know when patterns apply</li>
        <li><strong>Master derivation</strong> - Create patterns for novel constraints</li>
      </ol>

      <p class="lead">You are now at step 3.</p>
    </section>

    <div class="milestone">
      Derivation Guide Complete! You now have the ultimate skill: creating new patterns from first principles.
    </div>

    <!-- Quick Reference -->
    <section id="quick-reference">
      <h2><span class="bionic">Qui</span>ck <span class="bionic">Ref</span>erence: Principle -> Pattern Mapping</h2>

      <table class="data-table">
        <thead>
          <tr>
            <th>When You Need</th>
            <th>Apply Principle</th>
            <th>Consider Pattern</th>
          </tr>
        </thead>
        <tbody>
          <tr><td>Long-running autonomy</td><td>Fresh context + External state</td><td>Ralph Loop</td></tr>
          <tr><td>Parallel work</td><td>Isolation + Separation</td><td>CC Mirror, Worktrees</td></tr>
          <tr><td>Quality consistency</td><td>Verification</td><td>CI Green Enforcement</td></tr>
          <tr><td>Multi-perspective</td><td>Separation + Isolation</td><td>Adversarial Speccing</td></tr>
          <tr><td>Persistent memory</td><td>External state</td><td>progress.txt, Claude-Mem</td></tr>
          <tr><td>Human oversight</td><td>External state + Hooks</td><td>Notification patterns</td></tr>
          <tr><td>Cost optimization</td><td>Separation</td><td>Model selection matrix</td></tr>
          <tr><td>Recovery</td><td>External state + Verification</td><td>Checkpointing</td></tr>
        </tbody>
      </table>
    </section>

    <div class="footer-nav">
      <a href="learning-loops.html">← Learning Loops</a>
      <a href="index.html">Principles Index →</a>
    </div>
  </div>

  
  <script src="../../js/copy-code.js"></script>
</body>
</html>
