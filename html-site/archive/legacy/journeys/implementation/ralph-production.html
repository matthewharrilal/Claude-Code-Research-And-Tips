<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ralph Production Loop - Claude Code Knowledge Base</title>
  <link rel="stylesheet" href="../../css/style.css">
  <link rel="stylesheet" href="../../css/sidebar.css">
</head>
<body>
  <div class="page-with-sidebar">
    <!-- Sidebar navigation -->
    <nav class="sidebar">
      <button class="sidebar-close" aria-label="Close sidebar">&times;</button>
      <div class="sidebar-header">
        <h2 class="sidebar-title"><a href="../../index.html">Claude Code KB</a></h2>
      </div>
      <ul class="sidebar-nav">
        <li class="nav-section">
          <div class="nav-section-title">Start Here</div>
          <ul class="nav-subsections">
            <li class="nav-page"><a href="../../start-here/index.html">Overview</a></li>
            <li class="nav-page"><a href="../../start-here/master-playbook.html">Master Playbook</a></li>
            <li class="nav-page"><a href="../../start-here/judgment-guide.html">Judgment Guide</a></li>
          </ul>
        </li>
        <li class="nav-section">
          <div class="nav-section-title">Foundations</div>
          <ul class="nav-subsections">
            <li class="nav-page"><a href="../../foundations/index.html">Overview</a></li>
            <li class="nav-page"><a href="../../foundations/principles/core.html">Core Principles</a></li>
            <li class="nav-page"><a href="../../foundations/architecture/complexity-ladder.html">Complexity Ladder</a></li>
          </ul>
        </li>
        <li class="nav-section">
          <div class="nav-section-title">Mental Models Journey</div>
          <ul class="nav-subsections">
            <li class="nav-page"><a href="../mental-models/index.html">Overview</a></li>
            <li class="nav-page"><a href="../mental-models/core-models.html">Core Models (1-10)</a></li>
            <li class="nav-page"><a href="../mental-models/advanced-models.html">Advanced Models (11-16)</a></li>
            <li class="nav-page"><a href="../mental-models/practice-heuristics.html">Practice &amp; Heuristics</a></li>
          </ul>
        </li>
        <li class="nav-section">
          <div class="nav-section-title">Architecture Journey</div>
          <ul class="nav-subsections">
            <li class="nav-page"><a href="../architecture/index.html">Overview</a></li>
            <li class="nav-page"><a href="../architecture/decision-framework.html">Decision Framework</a></li>
            <li class="nav-page"><a href="../architecture/core-patterns.html">Core Patterns</a></li>
            <li class="nav-page"><a href="../architecture/enterprise-swarm.html">Enterprise &amp; Swarm</a></li>
            <li class="nav-page"><a href="../architecture/context-composition.html">Context &amp; Composition</a></li>
          </ul>
        </li>
        <li class="nav-section open">
          <div class="nav-section-title">Implementation Journey</div>
          <ul class="nav-subsections">
            <li class="nav-page"><a href="../implementation/index.html">Overview</a></li>
            <li class="nav-page"><a href="../implementation/context-state.html">Context &amp; State</a></li>
            <li class="nav-page current"><a href="../implementation/ralph-production.html">Ralph Production</a></li>
            <li class="nav-page"><a href="../implementation/hooks-enterprise.html">Hooks &amp; Enterprise</a></li>
          </ul>
        </li>
        <li class="nav-section">
          <div class="nav-section-title">Operations Journey</div>
          <ul class="nav-subsections">
            <li class="nav-page"><a href="../operations/index.html">Overview</a></li>
            <li class="nav-page"><a href="../operations/monitoring-cost.html">Monitoring &amp; Cost</a></li>
            <li class="nav-page"><a href="../operations/security-checklists.html">Security &amp; Checklists</a></li>
            <li class="nav-page"><a href="../operations/incident-response.html">Incident Response</a></li>
          </ul>
        </li>
        <li class="nav-section">
          <div class="nav-section-title">Reference</div>
          <ul class="nav-subsections">
            <li class="nav-page"><a href="../foundations/invariants-reference.html">Invariants Reference</a></li>
            <li class="nav-page"><a href="../../reference/index.html">Full Reference</a></li>
            <li class="nav-page"><a href="../../reference/cost-analysis.html">Cost Analysis</a></li>
          </ul>
        </li>
      </ul>
    </nav>

    <!-- Sidebar overlay for mobile -->
    <div class="sidebar-overlay"></div>

    <!-- Main content -->
    <main class="main-content">
      <!-- Breadcrumb -->
      <nav class="breadcrumb">
        <a href="../../index.html">Home</a>
        <span class="breadcrumb-separator">/</span>
        <a href="../index.html">Journeys</a>
        <span class="breadcrumb-separator">/</span>
        <a href="index.html">Implementation</a>
        <span class="breadcrumb-separator">/</span>
        <span class="breadcrumb-current">Ralph Production</span>
      </nav>

      <!-- Page meta -->
      <div class="page-meta">
        <span class="page-meta-item">~33 min read</span>
      </div>

      <h1>Production Ralph Loop Implementation</h1>

      <div class="context-box you-are-here">
        <h3>You Are Here</h3>
        <p><strong>What this covers:</strong> Complete production Ralph loop implementation - from simple variants to enterprise-grade loops with multi-layer exit detection, cost controls, and Queen/Worker orchestration.</p>
        <p><strong>Time estimate:</strong> ~33 minutes for full read</p>
        <p><strong>Where this fits:</strong></p>
        <div class="ascii-diagram">Foundations (Principles/Architecture)
           |
    =====================================
    |  Building Production Systems      |
    =====================================
           |
    +-- Context & State (previous)
    +-- >>> RALPH PRODUCTION <<< (here)
    +-- Hooks & Enterprise (next)
           |
    Operations (Monitoring/Recovery)</div>
        <p><strong>Key sources:</strong></p>
        <ul>
          <li><a href="https://github.com/snarktank/ralph">snarktank/ralph</a> (4.7k stars) - Original pattern</li>
          <li><a href="https://github.com/frankbria/ralph-claude-code">frankbria/ralph-claude-code</a> - Dual-condition exit</li>
          <li><a href="https://github.com/ruvnet/claude-flow">ruvnet/claude-flow</a> (11.3k stars) - Queen/Worker swarm</li>
          <li><a href="https://github.com/0xSero/orchestra">0xSero/orchestra</a> - Self-improvement pattern</li>
        </ul>
      </div>

      <p>The Ralph Wiggum Loop is the core pattern for autonomous Claude Code work. This guide covers the full production implementation, from simple variants to enterprise-grade loops with multi-layer exit detection and cost controls.</p>

      <!-- Woven Summary 1: Ralph Variant Comparison -->
      <div class="context-box" style="background: linear-gradient(135deg, #f0ebe3 0%, #fefcf3 100%); border-left: 4px solid #2a7d7d; border-radius: 8px; padding: 1.5rem; margin: 2rem 0;">
        <h3>Deep Dive: Choosing the Right Ralph Variant</h3>
        <p><strong>Source:</strong> <a href="../../synthesis/ralph-ecosystem-complete.html">Ralph Ecosystem Complete</a></p>
        <p>The Ralph ecosystem has evolved from a simple bash loop into a family of specialized variants. Understanding when to use each is critical for production success.</p>

        <p><strong>The Four Pillars (All Variants Share):</strong></p>
        <ol>
          <li><strong>Fresh Context Per Iteration</strong> - Each loop spawns a NEW instance with NO memory</li>
          <li><strong>External Memory Architecture</strong> - Git, prd.json, progress.txt persist state</li>
          <li><strong>Small, Verifiable Tasks</strong> - Complete in one context window</li>
          <li><strong>Failure as Data</strong> - Each failure informs the next attempt</li>
        </ol>

        <table>
          <thead>
            <tr><th>Scenario</th><th>Recommended Variant</th><th>Why</th></tr>
          </thead>
          <tbody>
            <tr><td>Standard feature development</td><td><strong>Basic Ralph</strong></td><td>Simple, proven, low overhead</td></tr>
            <tr><td>Uncertain requirements</td><td><strong>Dr. Ralph</strong></td><td>Confidence thresholds pause for human input</td></tr>
            <tr><td>Overnight autonomous run</td><td><strong>Rate-Limited Ralph</strong></td><td>Cost controls + rate limiting</td></tr>
            <tr><td>Long-term project</td><td><strong>Compounding Ralph</strong></td><td>Archives learnings across runs</td></tr>
            <tr><td>Full application build</td><td><strong>Marathon Ralph</strong></td><td>SDLC phases: plan, code, test, docs</td></tr>
            <tr><td>Unclear specifications</td><td><strong>Lisa + Ralph</strong></td><td>Lisa interviews, Ralph implements</td></tr>
            <tr><td>High-stakes code</td><td><strong>Zeroshot</strong></td><td>Multi-agent validation prevents errors</td></tr>
          </tbody>
        </table>

        <p><strong>Cost comparison (per 10 iterations):</strong></p>
        <ul>
          <li><strong>Basic Ralph:</strong> $0.50-2.00</li>
          <li><strong>Rate-Limited:</strong> Same cost, controlled spend rate</li>
          <li><strong>Compounding:</strong> $0.70-2.50 (learns, so fewer iterations over time)</li>
          <li><strong>Zeroshot Standard (4 agents):</strong> $2-6</li>
          <li><strong>Zeroshot Critical (7 agents):</strong> $3.50-10</li>
        </ul>
        <p><em>For complete runnable implementations of all variants, see <a href="../../synthesis/ralph-ecosystem-complete.html">Ralph Ecosystem Complete</a>.</em></p>
      </div>

      <h2 id="variant-matrix">The Ralph Variant Matrix</h2>

      <p>After analyzing 10+ Ralph implementations, here are the key variants:</p>

      <table>
        <thead>
          <tr>
            <th>Variant</th>
            <th>Best For</th>
            <th>Exit Strategy</th>
            <th>Stars</th>
          </tr>
        </thead>
        <tbody>
          <tr><td><strong>snarktank/ralph</strong></td><td>Learning, simple features</td><td>Simple grep</td><td>4.7k</td></tr>
          <tr><td><strong>frankbria/ralph-claude-code</strong></td><td>Production, long sessions</td><td>Dual-condition</td><td>~2k</td></tr>
          <tr><td><strong>mikeyobrien/ralph-orchestrator</strong></td><td>Enterprise, mixed tools</td><td>Configurable</td><td>788</td></tr>
          <tr><td><strong>covibes/zeroshot</strong></td><td>Security-critical</td><td>Validator consensus</td><td>867</td></tr>
          <tr><td><strong>claude-flow</strong></td><td>Enterprise swarms</td><td>Queen coordination</td><td>11.3k</td></tr>
          <tr><td><strong>orchestra (OpenCode)</strong></td><td>Self-improving</td><td>Idle-state trigger</td><td>244</td></tr>
        </tbody>
      </table>

      <hr class="section-divider">

      <h2 id="queen-worker">Claude-Flow's Queen/Worker Pattern</h2>

      <p>Source: <a href="https://github.com/ruvnet/claude-flow">ruvnet/claude-flow</a> by Reuven Cohen</p>

      <p>Claude-Flow implements a fundamentally different architecture than basic Ralph: a Queen/Worker swarm model:</p>

      <div class="ascii-diagram">Claude-Flow Architecture
========================

            +-----------------------------+
            |      QUEEN AGENT            |
            |   (Central Coordinator)      |
            |                             |
            |  - Task distribution        |
            |  - Resource allocation      |
            |  - Swarm health monitoring  |
            +-------------+---------------+
                          |
        +-----------------+------------------+
        |                 |                  |
        v                 v                  v
+---------------+ +---------------+ +---------------+
|  WORKER AGENT | |  WORKER AGENT | |  WORKER AGENT |
|   (Planner)   | |   (Coder)     | |   (Critic)    |
+-------+-------+ +-------+-------+ +-------+-------+
        |                 |                  |
        v                 v                  v
+-----------------------------------------------+
|              SHARED MEMORY LAYER              |
|          (AgentDB + ReasoningBank)            |
+-----------------------------------------------+</div>

      <h3>Implementing Queen/Worker in Ralph</h3>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code>#!/bin/bash
# claude-flow-style-ralph.sh - Queen/Worker pattern for Ralph loops

# Queen: Coordinates workers and manages task distribution
run_queen() {
    local prd_file="$1"

    cat > /tmp/queen-prompt.md << EOF
# Queen Agent Instructions

You are the QUEEN coordinator. Your role:
1. Read $prd_file and identify the next story to work on
2. Analyze the story requirements
3. Decide which worker type should handle it:
   - Planner: For architecture/design stories
   - Coder: For implementation stories
   - Critic: For review/testing stories
4. Emit a task assignment for the worker

## Output Format
\`\`\`json
{
  "worker_type": "coder|planner|critic",
  "task": "specific task for worker",
  "story_id": "US-XXX",
  "files_to_modify": ["list", "of", "files"]
}
\`\`\`

## Critical Rules
- Do NOT implement anything yourself
- Only coordinate and assign work
- Monitor for stuck workers (same task 3+ iterations)
EOF

    claude-code --print < /tmp/queen-prompt.md
}

# Worker: Executes task assigned by Queen
run_worker() {
    local worker_type="$1"
    local task="$2"
    local story_id="$3"

    cat > /tmp/worker-prompt.md << EOF
# Worker Agent: $worker_type

You are a $worker_type worker. Execute this specific task:

## Task
$task

## Story
$story_id

## Rules
- Complete ONLY this task
- Do NOT expand scope
- Do NOT spawn subagents
- Commit when done
- Report completion status
EOF

    claude-code --print < /tmp/worker-prompt.md
}

# Main loop: Queen coordinates, Workers execute
main() {
    local prd_file="${1:-plans/prd.json}"

    while true; do
        # Queen assigns task
        local assignment=$(run_queen "$prd_file")

        # Parse assignment
        local worker_type=$(echo "$assignment" | jq -r '.worker_type')
        local task=$(echo "$assignment" | jq -r '.task')
        local story_id=$(echo "$assignment" | jq -r '.story_id')

        if [ "$worker_type" = "null" ]; then
            echo "All tasks complete"
            break
        fi

        # Worker executes
        run_worker "$worker_type" "$task" "$story_id"

        sleep 2
    done
}

main "$@"</code></pre>
      </div>

      <h2 id="self-improvement">Orchestra Self-Improvement Pattern</h2>

      <p>Source: <a href="https://github.com/0xSero/orchestra">0xSero/orchestra</a></p>

      <p>Orchestra introduces a novel pattern: self-improving orchestrators that run 24/7. When idle, the system improves itself:</p>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code>#!/bin/bash
# orchestra-style-self-improve.sh - Self-improving agent pattern

ORCHESTRATOR_CONFIG="orchestrator.json"

# Define worker profiles
init_profiles() {
    cat > "$ORCHESTRATOR_CONFIG" << 'EOF'
{
  "profiles": [
    { "id": "vision", "purpose": "Visual analysis", "model": "claude-3-opus" },
    { "id": "docs", "purpose": "Documentation research", "model": "claude-3-sonnet" },
    { "id": "research", "purpose": "Deep investigation", "model": "claude-3-opus" },
    { "id": "coder", "purpose": "Implementation", "model": "claude-3-sonnet" },
    { "id": "memory", "purpose": "Context persistence", "model": "claude-3-haiku" },
    { "id": "architect", "purpose": "System design", "model": "claude-3-opus" }
  ],
  "self_improvement": {
    "enabled": true,
    "idle_threshold_seconds": 300,
    "triggers": ["idle", "error_rate_high", "manual"]
  }
}
EOF
}

# Check if system is idle (Orchestra trigger)
check_idle_state() {
    local threshold="${1:-300}"  # 5 minutes default

    # Get last activity timestamp
    local last_activity=$(stat -c %Y plans/progress.txt 2>/dev/null || echo 0)
    local now=$(date +%s)
    local idle_time=$((now - last_activity))

    if [ $idle_time -ge $threshold ]; then
        echo "idle"
        return 0
    else
        echo "active"
        return 1
    fi
}

# Self-improvement routine (core Orchestra innovation)
run_self_improvement() {
    cat > /tmp/self-improve-prompt.md << 'EOF'
# Self-Improvement Mode (Orchestra Pattern)

You are in self-improvement mode. The system has been idle.

## Your Task
Analyze the current orchestrator setup and identify improvements:

1. Review recent task history for patterns
2. Identify bottlenecks or failures
3. Suggest and implement improvements

## Example Improvements
- Added Docker containerization for isolation
- Improved error handling in stuck detection
- Optimized worker profile allocation

## Rules
- Make small, testable changes
- Document changes in progress.txt
- Do NOT break existing functionality
- If unsure, propose instead of implementing
EOF

    claude-code --print < /tmp/self-improve-prompt.md
}

# Main orchestrator loop with self-improvement
main() {
    init_profiles

    while true; do
        # Check for pending work
        local pending=$(jq '[.userStories[] | select(.passes == false)] | length' plans/prd.json)

        if [ "$pending" -gt 0 ]; then
            # Normal Ralph iteration
            cat plans/prompt.md | claude-code
        else
            # Check if idle long enough for self-improvement
            local state=$(check_idle_state 300)
            if [ "$state" = "idle" ]; then
                echo "System idle - running self-improvement..."
                run_self_improvement
            fi
        fi

        sleep 60  # Check every minute
    done
}

main "$@"</code></pre>
      </div>

      <p>Key Orchestra innovations:</p>
      <ul>
        <li><strong>Idle-state triggers</strong> - When no work, improve the system</li>
        <li><strong>Docker containerization</strong> - Added by the agent itself for safety</li>
        <li><strong>Worker profiles</strong> - Specialized agents loaded on demand</li>
        <li><strong>24/7 operation</strong> - Designed for continuous running</li>
      </ul>

      <!-- Woven Summary 2: Exit Detection Deep Dive -->
      <div class="context-box" style="background: linear-gradient(135deg, #f0ebe3 0%, #fefcf3 100%); border-left: 4px solid #6b9b7a; border-radius: 8px; padding: 1.5rem; margin: 2rem 0;">
        <h3>Deep Dive: Dual-Condition Exit Detection</h3>
        <p><strong>Source:</strong> <a href="../../synthesis/compare-ralph-variants-complete.html">Ralph Variants Comparison</a></p>
        <p>The most common Ralph failure mode is incorrect loop termination - either too early (work incomplete) or too late (wasted tokens). Frank Bria's dual-condition gate solves this with a two-factor approach:</p>

        <p><strong>The Dual-Condition Gate:</strong></p>
        <div class="code-block">
          <button class="copy-btn">Copy</button>
          <pre><code># BOTH conditions must be true to exit:
# 1. Explicit EXIT_SIGNAL = true (agent says "done")
# 2. completion_indicators >= 2 (objective evidence of completion)

if [ "$exit_signal" = "true" ] && [ "$completion_indicators" -ge 2 ]; then
    echo "EXIT: Both conditions met"
    exit 0
fi</code></pre>
        </div>

        <p><strong>Why single signals fail:</strong></p>
        <table>
          <thead><tr><th>Signal Type</th><th>False Positive Rate</th><th>Failure Mode</th></tr></thead>
          <tbody>
            <tr><td>Simple grep ("COMPLETE")</td><td>~15-20%</td><td>Agent says "complete" when describing what WILL happen</td></tr>
            <tr><td>PRD check only</td><td>~10%</td><td>Agent marks passes:true before verification</td></tr>
            <tr><td>Test-only check</td><td>~5%</td><td>Tests pass but acceptance criteria unmet</td></tr>
            <tr><td>Dual-condition gate</td><td>~2%</td><td>Rare - requires both signal AND evidence</td></tr>
          </tbody>
        </table>

        <p><strong>Completion indicators (count toward the "2" threshold):</strong></p>
        <ul>
          <li>All acceptance criteria met (verified)</li>
          <li>Tests passing (npm test exit 0)</li>
          <li>Code committed (git commit successful)</li>
          <li>No TODOs remaining in modified files</li>
          <li>Documentation updated (if applicable)</li>
        </ul>
        <p><em>For complete exit detection implementation with test-loop saturation and circuit breakers, see the Production Loop below.</em></p>
      </div>

      <hr class="section-divider">

      <h2 id="production-loop">Production Ralph Loop (Full Featured)</h2>

      <p>This is the complete production implementation with dual-condition exit gate, circuit breaker, cost tracking, and rate limit handling.</p>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code>#!/bin/bash
#===============================================================================
# ralph-production.sh - Complete Production Ralph Implementation
#
# FEATURES:
#   - Dual-condition exit gate (frankbria pattern)
#   - Circuit breaker for stuck detection
#   - Cost tracking and limits
#   - Multi-layer graceful exit
#   - RALPH_STATUS parsing
#   - Rate limit handling
#
# USAGE: ./ralph-production.sh [max_iterations] [cost_limit]
#
# EXIT CODES:
#   0 - Success (all stories complete)
#   1 - Max iterations reached
#   2 - Stuck detection triggered
#   3 - Cost limit exceeded
#   4 - Manual intervention required
#===============================================================================

set -euo pipefail

#-------------------------------------------------------------------------------
# Configuration
#-------------------------------------------------------------------------------
MAX_ITERATIONS=${1:-50}
COST_LIMIT_USD=${2:-25.00}
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# File locations
PRD_FILE="$SCRIPT_DIR/prd.json"
PROGRESS_FILE="$SCRIPT_DIR/progress.txt"
PROMPT_FILE="$SCRIPT_DIR/prompt.md"
METRICS_FILE="$SCRIPT_DIR/.metrics.json"

# Safety parameters
STUCK_THRESHOLD=3
SLEEP_BETWEEN_ITERATIONS=2
RATE_LIMIT_WAIT=60
MAX_CONSECUTIVE_TEST_LOOPS=5
MAX_CONSECUTIVE_DONE_SIGNALS=3

# Tracking state
LAST_COMMIT=""
STUCK_COUNT=0
TOTAL_ITERATIONS=0
ESTIMATED_COST=0
CONSECUTIVE_TEST_LOOPS=0
CONSECUTIVE_DONE_SIGNALS=0

#-------------------------------------------------------------------------------
# Utility Functions
#-------------------------------------------------------------------------------

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*"
}

log_error() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] ERROR: $*" >&2
}

initialize_metrics() {
    if [ ! -f "$METRICS_FILE" ]; then
        cat > "$METRICS_FILE" << EOF
{
    "started_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
    "total_iterations": 0,
    "estimated_cost_usd": 0,
    "stories_completed": 0,
    "exit_reason": null
}
EOF
    fi
}

update_metrics() {
    local field="$1"
    local value="$2"

    local temp=$(mktemp)
    jq ".$field = $value" "$METRICS_FILE" > "$temp"
    mv "$temp" "$METRICS_FILE"
}

estimate_iteration_cost() {
    # Opus pricing estimate: ~$0.45-0.75 per typical iteration
    # Conservative estimate: $0.60
    echo "0.60"
}

#-------------------------------------------------------------------------------
# Validation
#-------------------------------------------------------------------------------

validate_environment() {
    log "=== Validating Environment ==="

    local errors=0

    for file in "$PRD_FILE" "$PROMPT_FILE"; do
        if [ ! -f "$file" ]; then
            log_error "Required file not found: $file"
            errors=$((errors + 1))
        fi
    done

    if [ -f "$PRD_FILE" ]; then
        if ! jq empty "$PRD_FILE" 2>/dev/null; then
            log_error "Invalid JSON in $PRD_FILE"
            errors=$((errors + 1))
        fi
    fi

    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        log_error "Not in a git repository"
        errors=$((errors + 1))
    fi

    if ! command -v jq &> /dev/null; then
        log_error "jq is required but not installed"
        errors=$((errors + 1))
    fi

    if [ $errors -gt 0 ]; then
        log_error "Validation failed with $errors errors"
        exit 1
    fi

    log "Environment validated successfully"
}

#-------------------------------------------------------------------------------
# PRD Operations
#-------------------------------------------------------------------------------

count_pending_stories() {
    jq '[.userStories[] | select(.passes == false)] | length' "$PRD_FILE"
}

count_complete_stories() {
    jq '[.userStories[] | select(.passes == true)] | length' "$PRD_FILE"
}

get_current_story() {
    jq -r '.userStories[] | select(.passes == false) | .id' "$PRD_FILE" | head -1
}

get_story_title() {
    local story_id="$1"
    jq -r ".userStories[] | select(.id == \"$story_id\") | .title" "$PRD_FILE"
}

#-------------------------------------------------------------------------------
# Exit Detection (Multi-Layer)
#-------------------------------------------------------------------------------

parse_ralph_status() {
    local output="$1"

    local status=$(echo "$output" | grep -oP '{"RALPH_STATUS":\s*{[^}]+}}' | head -1 || echo "")

    if [ -n "$status" ]; then
        echo "$status" | jq -r '.RALPH_STATUS'
    else
        echo '{"EXIT_SIGNAL": false, "completion_indicators": 0}'
    fi
}

detect_test_loop_saturation() {
    local output="$1"

    local test_commands=$(echo "$output" | grep -c "npm run test\|npm test\|jest\|vitest" || echo "0")
    local file_edits=$(echo "$output" | grep -c "Write tool\|Edit tool\|wrote to" || echo "0")

    if [ "$test_commands" -gt 3 ] && [ "$file_edits" -eq 0 ]; then
        CONSECUTIVE_TEST_LOOPS=$((CONSECUTIVE_TEST_LOOPS + 1))
        return 0
    else
        CONSECUTIVE_TEST_LOOPS=0
        return 1
    fi
}

detect_completion_signals() {
    local output="$1"

    local done_signals=$(echo "$output" | grep -ciE "complete|finished|done|all tests pass" || echo "0")

    if [ "$done_signals" -gt 2 ]; then
        CONSECUTIVE_DONE_SIGNALS=$((CONSECUTIVE_DONE_SIGNALS + 1))
        return 0
    else
        CONSECUTIVE_DONE_SIGNALS=0
        return 1
    fi
}

should_exit_gracefully() {
    local output="$1"

    # Stage 1: Test-only loop saturation
    if [ $CONSECUTIVE_TEST_LOOPS -ge $MAX_CONSECUTIVE_TEST_LOOPS ]; then
        log "Exit trigger: Test loop saturation (Stage 1)"
        echo "test_saturation"
        return 0
    fi

    # Stage 2: Completion signals without proper exit
    if [ $CONSECUTIVE_DONE_SIGNALS -ge $MAX_CONSECUTIVE_DONE_SIGNALS ]; then
        log "Exit trigger: Completion signals (Stage 2)"
        echo "completion_signals"
        return 0
    fi

    # Stage 3: Dual-condition gate (explicit + heuristic)
    local status=$(parse_ralph_status "$output")
    local exit_signal=$(echo "$status" | jq -r '.EXIT_SIGNAL // false')
    local completion_indicators=$(echo "$status" | jq -r '.completion_indicators // 0')

    if [ "$exit_signal" = "true" ] && [ "$completion_indicators" -ge 2 ]; then
        log "Exit trigger: Dual-gate satisfied (Stage 3)"
        echo "project_complete"
        return 0
    fi

    # Stage 4: Simple promise (backwards compatibility)
    if echo "$output" | grep -q "<promise>COMPLETE</promise>"; then
        log "Exit trigger: Promise marker (Stage 4)"
        echo "promise_complete"
        return 0
    fi

    # Stage 5: All PRD stories complete
    local pending=$(count_pending_stories)
    if [ "$pending" -eq 0 ]; then
        log "Exit trigger: All stories complete (Stage 5)"
        echo "prd_complete"
        return 0
    fi

    return 1
}

#-------------------------------------------------------------------------------
# Stuck Detection and Circuit Breaker
#-------------------------------------------------------------------------------

check_stuck() {
    local current_commit=$(git rev-parse HEAD 2>/dev/null || echo "none")

    if [ "$current_commit" = "$LAST_COMMIT" ] && [ -n "$LAST_COMMIT" ]; then
        STUCK_COUNT=$((STUCK_COUNT + 1))
        log "WARNING: No commit in iteration (stuck count: $STUCK_COUNT/$STUCK_THRESHOLD)"

        if [ $STUCK_COUNT -ge $STUCK_THRESHOLD ]; then
            return 1  # Circuit breaker triggered
        fi
    else
        STUCK_COUNT=0
        LAST_COMMIT="$current_commit"
    fi

    return 0
}

check_cost_limit() {
    local iteration_cost=$(estimate_iteration_cost)
    ESTIMATED_COST=$(echo "$ESTIMATED_COST + $iteration_cost" | bc)

    if (( $(echo "$ESTIMATED_COST > $COST_LIMIT_USD" | bc -l) )); then
        log_error "Cost limit exceeded: \$$ESTIMATED_COST > \$$COST_LIMIT_USD"
        return 1
    fi

    return 0
}

#-------------------------------------------------------------------------------
# Main Loop
#-------------------------------------------------------------------------------

run_ralph_loop() {
    log "=== Ralph Production Loop Starting ==="
    log "Max iterations: $MAX_ITERATIONS"
    log "Cost limit: \$$COST_LIMIT_USD"
    log "Stories pending: $(count_pending_stories)"
    log "Starting story: $(get_current_story)"

    for i in $(seq 1 $MAX_ITERATIONS); do
        TOTAL_ITERATIONS=$i
        update_metrics "total_iterations" "$i"

        log "========================================"
        log "=== Iteration $i of $MAX_ITERATIONS ==="
        log "========================================"
        log "Pending: $(count_pending_stories) | Complete: $(count_complete_stories)"
        log "Current: $(get_current_story) - $(get_story_title "$(get_current_story)")"
        log "Estimated cost: \$$ESTIMATED_COST"

        if ! check_cost_limit; then
            update_metrics "exit_reason" '"cost_limit_exceeded"'
            exit 3
        fi

        # Run Claude with fresh context (NEVER use --continue)
        local output=""
        output=$(cat "$PROMPT_FILE" | \
            claude-code --dangerously-skip-permissions 2>&1 | \
            tee /dev/stderr) || true

        # Multi-layer exit detection
        local exit_reason=""
        if exit_reason=$(should_exit_gracefully "$output"); then
            log "========================================"
            log "=== SUCCESS: $exit_reason ==="
            log "========================================"
            log "Total iterations: $TOTAL_ITERATIONS"
            log "Final cost estimate: \$$ESTIMATED_COST"

            git add -A
            if ! git diff --cached --quiet; then
                git commit -m "feat: ralph complete - $exit_reason"
            fi

            update_metrics "exit_reason" "\"$exit_reason\""
            update_metrics "stories_completed" "$(count_complete_stories)"
            update_metrics "estimated_cost_usd" "$ESTIMATED_COST"

            exit 0
        fi

        if echo "$output" | grep -qi "rate.limit"; then
            log "Rate limited, waiting ${RATE_LIMIT_WAIT}s..."
            sleep $RATE_LIMIT_WAIT
        fi

        detect_test_loop_saturation "$output"
        detect_completion_signals "$output"

        if ! check_stuck; then
            log "========================================"
            log "=== STUCK: Circuit breaker triggered ==="
            log "========================================"
            log "No progress for $STUCK_THRESHOLD consecutive iterations"
            log "Current story: $(get_current_story)"

            update_metrics "exit_reason" '"stuck_circuit_breaker"'
            exit 2
        fi

        # Checkpoint every 5 iterations
        if [ $((i % 5)) -eq 0 ]; then
            git add -A
            if ! git diff --cached --quiet; then
                git commit -m "checkpoint: iteration $i - $(get_current_story)" || true
            fi
        fi

        sleep $SLEEP_BETWEEN_ITERATIONS
    done

    log "========================================"
    log "=== Max iterations reached ($MAX_ITERATIONS) ==="
    log "========================================"
    log "Pending stories: $(count_pending_stories)"
    log "Estimated cost: \$$ESTIMATED_COST"

    update_metrics "exit_reason" '"max_iterations"'
    exit 1
}

#-------------------------------------------------------------------------------
# Entry Point
#-------------------------------------------------------------------------------

main() {
    cd "$PROJECT_ROOT"

    validate_environment
    initialize_metrics

    if [ ! -f "$PROGRESS_FILE" ]; then
        cat > "$PROGRESS_FILE" << 'EOF'
# Progress Log - APPEND ONLY
# Started: $(date -u +%Y-%m-%dT%H:%M:%SZ)

## Codebase Patterns
<!-- Patterns discovered during work -->

---
EOF
    fi

    run_ralph_loop
}

main "$@"</code></pre>
      </div>

      <div class="checkpoint">
        <div class="checkpoint-header">Checkpoint: Ralph Script Setup</div>
        <div class="checkpoint-content">
          <p>Verify your Ralph script is ready:</p>
          <div class="code-block">
            <button class="copy-btn">Copy</button>
            <pre><code>chmod +x plans/ralph.sh

# Test preflight (should pass)
./plans/ralph.sh 1 2>&1 | head -20
# Should show "Validating Environment" and "Environment validated"</code></pre>
          </div>
        </div>
      </div>

      <details class="troubleshoot">
        <summary>Ralph loop issues</summary>
        <div class="troubleshoot-content">
          <table>
            <tr><th>Symptom</th><th>Cause</th><th>Recovery</th></tr>
            <tr><td>Exit code 1</td><td>Max iterations reached</td><td>Increase MAX_ITERATIONS or reduce scope</td></tr>
            <tr><td>Exit code 2</td><td>Stuck circuit breaker</td><td>Check current story - may be blocked</td></tr>
            <tr><td>Exit code 3</td><td>Cost limit exceeded</td><td>Increase COST_LIMIT_USD or reduce scope</td></tr>
            <tr><td>Agent runs tests repeatedly</td><td>Test loop saturation</td><td>Story may be complete - check manually</td></tr>
            <tr><td>"rate.limit" in output</td><td>Hit API rate limits</td><td>Increase SLEEP_BETWEEN_ITERATIONS</td></tr>
          </table>
        </div>
      </details>

      <hr class="section-divider">

      <h2 id="prompt-template">Ralph Prompt Template (Production)</h2>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code># Ralph Agent Instructions (Production)

## Identity
You are an autonomous implementation agent in a production Ralph Wiggum Loop. Each iteration gives you FRESH CONTEXT. Your memory persists ONLY through external files.

## This Iteration Protocol

### Step 1: Read State
1. Read `plans/prd.json` for task list
2. Read `plans/progress.txt` for learnings from previous iterations
3. Read `CLAUDE.md` if you need project patterns

### Step 2: Select Work
1. Find highest priority story where `passes: false`
2. If all stories pass, emit completion signal and stop
3. Check if selected story is blocked by any dependencies

### Step 3: Implement
1. Implement ONLY the selected story
2. Follow existing code patterns (check CLAUDE.md)
3. Write tests if project has tests
4. Keep changes minimal and focused
5. Do NOT refactor unrelated code
6. Do NOT expand scope beyond acceptance criteria

### Step 4: Verify
Run ALL verification commands:
```bash
npm run typecheck  # Must pass
npm run test       # Must pass
npm run lint       # Should pass (warn if not)
```

If ANY verification fails:
- DO NOT mark story as complete
- Fix the issue if possible
- Document the failure in progress.txt
- Continue to next iteration

### Step 5: Update State

#### On Success (all verifications pass):
1. Update prd.json: Set `passes: true` for this story
2. Add tracking: `completed_at`, `commit_sha`, `iteration_count`
3. Commit with message: `feat: [STORY-ID] - [title]`
4. APPEND to progress.txt (NEVER overwrite)

#### On Failure (verification fails):
1. Keep `passes: false`
2. Add notes to story explaining blocker
3. APPEND failure details to progress.txt
4. Do NOT commit broken code

### Step 6: Emit Status

At the END of EVERY iteration, emit this block:

```json
{
  "RALPH_STATUS": {
    "EXIT_SIGNAL": false,
    "completion_indicators": 0,
    "progress_summary": "What was accomplished this iteration",
    "blockers": [],
    "next_action": "What should happen next"
  }
}
```

#### EXIT_SIGNAL Rules:
- Set `true` ONLY when ALL of these are true:
  - Every story in prd.json has `passes: true`
  - Final verification (typecheck, tests) passed
  - Code is committed
  - No pending work remains

- Set `false` if ANY of these are true:
  - Any story has `passes: false`
  - Tests are failing
  - Work is in progress
  - You completed a phase but more work remains

**CRITICAL: When in doubt, set EXIT_SIGNAL: false**
Premature exit is worse than extra iterations.

#### completion_indicators (count 0-5):
+1 for each: acceptance criteria met, tests passing, code committed, no TODOs, docs updated

### Step 7: End Iteration

If ALL stories complete:
```
<promise>COMPLETE</promise>
```

Otherwise: End normally. Loop will restart with fresh context.

## Critical Rules

1. **ONE story per iteration** - Never work on multiple
2. **Verify before marking complete** - Tests must actually pass
3. **APPEND to progress.txt** - Never overwrite history
4. **Commit AFTER verification** - Not before
5. **Stay focused** - No refactoring beyond story scope
6. **EXIT_SIGNAL accuracy** - False negatives are safer than false positives
7. **Fresh context assumption** - Never reference "earlier in conversation"</code></pre>
      </div>

      <h3>Aider-Style Commit Patterns</h3>

      <p>Source: <a href="https://github.com/paul-gauthier/aider">paul-gauthier/aider</a></p>

      <p>Aider's auto-commit pattern is one of its most valuable features. Add this to your Ralph prompt:</p>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code>## Git Integration (Aider Pattern)

### Commit After Each Logical Change
After completing any discrete unit of work, commit immediately:

```bash
# Aider commit format: type(scope): description
git add -A
git commit -m "feat(auth): implement JWT token generation"
```

### Commit Types
- `feat` - New feature
- `fix` - Bug fix
- `refactor` - Code restructuring
- `test` - Adding tests
- `docs` - Documentation

### Use Git as Memory
Before starting work, check recent history:
```bash
git log --oneline -10
```

This shows what was done in previous iterations without needing progress.txt.</code></pre>
      </div>

      <hr class="section-divider">

      <h2 id="worker-preamble">Worker Preamble Template (Subagent Isolation)</h2>

      <p>Use this preamble when spawning worker subagents to prevent recursive spawning and context pollution:</p>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code># Worker Agent Preamble

## Your Identity
You are a WORKER agent. You execute a specific task and return results.

## Critical Constraints

1. **SCOPE:** Work ONLY on the task assigned below. Do not expand scope.

2. **NO SPAWNING:** You may NOT use Task, TaskCreate, or spawn subagents.
   Attempting to spawn will waste tokens and fail.

3. **TOOLS ALLOWED:**
   - Read - Read files
   - Write - Write files
   - Edit - Edit files
   - Bash - Run commands
   - Glob - Find files
   - Grep - Search content

4. **TOOLS FORBIDDEN:**
   - Task/TaskCreate (spawning)
   - AskUserQuestion (blocking)
   - Any MCP tools unless explicitly listed

5. **OUTPUT FORMAT:** Return a concise summary under 500 tokens.

6. **CONTEXT LIMIT:** If you reach 60% context, STOP and summarize progress.

## Your Task

[TASK DESCRIPTION INSERTED HERE]

## Expected Output Format

```json
{
  "status": "complete|partial|blocked",
  "summary": "Brief description of what was done",
  "files_modified": ["list", "of", "files"],
  "tests_status": "passed|failed|skipped",
  "blockers": ["if any"],
  "tokens_used_estimate": 5000
}
```

## Begin Work Now

Read the necessary files and complete the task. Do not ask for clarification - make reasonable assumptions and document them.</code></pre>
      </div>

      <!-- Woven Summary 3: Failure Recovery -->
      <div class="context-box" style="background: linear-gradient(135deg, #f0ebe3 0%, #fefcf3 100%); border-left: 4px solid #c97065; border-radius: 8px; padding: 1.5rem; margin: 2rem 0;">
        <h3>Deep Dive: Failure Recovery Patterns</h3>
        <p><strong>Source:</strong> <a href="../../synthesis/debugging-agent-failures.html">Debugging Agent Failures</a></p>
        <p>The OHIV Framework for systematic diagnosis: <strong>O</strong>bserve, <strong>H</strong>ypothesize, <strong>I</strong>solate, <strong>V</strong>erify. Most Ralph failures fall into predictable patterns with known recoveries.</p>

        <p><strong>Quick Diagnosis Table:</strong></p>
        <table>
          <thead><tr><th>Symptom</th><th>Most Likely Cause</th><th>Quick Fix</th></tr></thead>
          <tbody>
            <tr><td>Loop runs forever</td><td>No completion criteria</td><td>Add explicit <code>&lt;promise&gt;COMPLETE&lt;/promise&gt;</code> check</td></tr>
            <tr><td>Commits fail every iteration</td><td>Pre-commit hooks rejecting</td><td>Check hook output; may need to bypass temporarily</td></tr>
            <tr><td>Same error 3+ times</td><td>Task too complex</td><td>Split into smaller stories</td></tr>
            <tr><td>Cost exploding</td><td>Runaway loop</td><td><code>pkill -f claude</code>, add MAX_ITERATIONS</td></tr>
            <tr><td>Workers spawning workers</td><td>Missing preamble</td><td>Add worker isolation template</td></tr>
          </tbody>
        </table>

        <p><strong>Emergency Recovery Commands:</strong></p>
        <div class="code-block">
          <button class="copy-btn">Copy</button>
          <pre><code># Stop runaway loop immediately
pkill -f "ralph.sh"
pkill -f "claude"

# Check what state we're in
cat prd.json | jq '.userStories[] | {id, passes}'
git log --oneline -10

# If commits are bad, revert to last good
git log --oneline -20  # Find last good commit
git reset --hard abc123  # Reset to it

# Resume from checkpoint
./plans/ralph.sh 5  # Continue with 5 more iterations</code></pre>
        </div>
        <p><em>For complete debugging workflows including multi-agent coordination failures, see <a href="../../synthesis/debugging-agent-failures.html">Debugging Agent Failures</a>.</em></p>
      </div>

      <hr class="section-divider">

      <h2 id="exit-stages">The 5 Exit Stages</h2>

      <p>The production Ralph loop uses multi-layer exit detection to prevent both premature termination and infinite loops:</p>

      <table>
        <thead>
          <tr>
            <th>Stage</th>
            <th>Trigger</th>
            <th>Reason</th>
          </tr>
        </thead>
        <tbody>
          <tr><td>1</td><td>Test loop saturation</td><td>Running tests repeatedly with no file edits</td></tr>
          <tr><td>2</td><td>Completion signals</td><td>Multiple "done/complete" messages without exit</td></tr>
          <tr><td>3</td><td>Dual-gate satisfied</td><td>EXIT_SIGNAL=true AND completion_indicators>=2</td></tr>
          <tr><td>4</td><td>Promise marker</td><td><code>&lt;promise&gt;COMPLETE&lt;/promise&gt;</code> found</td></tr>
          <tr><td>5</td><td>PRD complete</td><td>All stories have passes=true</td></tr>
        </tbody>
      </table>

      <h2 id="summary">Summary: Running Your Ralph Loop</h2>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code># Start Ralph with defaults (50 iterations, $25 limit)
./plans/ralph.sh

# Or specify limits
./plans/ralph.sh 25 15.00  # 25 iterations, $15 limit

# Check status during run
jq '.userStories[] | {id, passes, title}' plans/prd.json

# View progress
tail -50 plans/progress.txt

# Check metrics after completion
cat plans/.metrics.json | jq .</code></pre>
      </div>

      <!-- Footer navigation -->
      <div class="footer-nav">
        <a href="context-state.html" class="nav-prev">
          <span class="nav-direction">Previous</span>
          <span class="nav-title">Context & State</span>
        </a>
        <a href="hooks-enterprise.html" class="nav-next">
          <span class="nav-direction">Next</span>
          <span class="nav-title">Hooks & Enterprise</span>
        </a>
      </div>

    </main>
  </div>

  <!-- Mobile toggle button -->
  <button class="sidebar-toggle" aria-label="Open navigation">&#9776;</button>

  <script src="../../js/sidebar.js"></script>
</body>
</html>
