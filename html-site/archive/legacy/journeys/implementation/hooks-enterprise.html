<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hooks & Enterprise Patterns - Claude Code Knowledge Base</title>
  <link rel="stylesheet" href="../../css/style.css">
  <link rel="stylesheet" href="../../css/sidebar.css">
</head>
<body>
  <div class="page-with-sidebar">
    <!-- Sidebar navigation -->
    <nav class="sidebar">
      <button class="sidebar-close" aria-label="Close sidebar">&times;</button>
      <div class="sidebar-header">
        <h2 class="sidebar-title"><a href="../../index.html">Claude Code KB</a></h2>
      </div>
      <ul class="sidebar-nav">
        <li class="nav-section">
          <div class="nav-section-title">Start Here</div>
          <ul class="nav-subsections">
            <li class="nav-page"><a href="../../start-here/index.html">Overview</a></li>
            <li class="nav-page"><a href="../../start-here/master-playbook.html">Master Playbook</a></li>
            <li class="nav-page"><a href="../../start-here/judgment-guide.html">Judgment Guide</a></li>
          </ul>
        </li>
        <li class="nav-section">
          <div class="nav-section-title">Foundations</div>
          <ul class="nav-subsections">
            <li class="nav-page"><a href="../../foundations/index.html">Overview</a></li>
            <li class="nav-page"><a href="../../foundations/principles/core.html">Core Principles</a></li>
            <li class="nav-page"><a href="../../foundations/architecture/complexity-ladder.html">Complexity Ladder</a></li>
          </ul>
        </li>
        <li class="nav-section">
          <div class="nav-section-title">Mental Models Journey</div>
          <ul class="nav-subsections">
            <li class="nav-page"><a href="../mental-models/index.html">Overview</a></li>
            <li class="nav-page"><a href="../mental-models/core-models.html">Core Models (1-10)</a></li>
            <li class="nav-page"><a href="../mental-models/advanced-models.html">Advanced Models (11-16)</a></li>
            <li class="nav-page"><a href="../mental-models/practice-heuristics.html">Practice &amp; Heuristics</a></li>
          </ul>
        </li>
        <li class="nav-section">
          <div class="nav-section-title">Architecture Journey</div>
          <ul class="nav-subsections">
            <li class="nav-page"><a href="../architecture/index.html">Overview</a></li>
            <li class="nav-page"><a href="../architecture/decision-framework.html">Decision Framework</a></li>
            <li class="nav-page"><a href="../architecture/core-patterns.html">Core Patterns</a></li>
            <li class="nav-page"><a href="../architecture/enterprise-swarm.html">Enterprise &amp; Swarm</a></li>
            <li class="nav-page"><a href="../architecture/context-composition.html">Context &amp; Composition</a></li>
          </ul>
        </li>
        <li class="nav-section open">
          <div class="nav-section-title">Implementation Journey</div>
          <ul class="nav-subsections">
            <li class="nav-page"><a href="../implementation/index.html">Overview</a></li>
            <li class="nav-page"><a href="../implementation/context-state.html">Context &amp; State</a></li>
            <li class="nav-page"><a href="../implementation/ralph-production.html">Ralph Production</a></li>
            <li class="nav-page current"><a href="../implementation/hooks-enterprise.html">Hooks &amp; Enterprise</a></li>
          </ul>
        </li>
        <li class="nav-section">
          <div class="nav-section-title">Operations Journey</div>
          <ul class="nav-subsections">
            <li class="nav-page"><a href="../operations/index.html">Overview</a></li>
            <li class="nav-page"><a href="../operations/monitoring-cost.html">Monitoring &amp; Cost</a></li>
            <li class="nav-page"><a href="../operations/security-checklists.html">Security &amp; Checklists</a></li>
            <li class="nav-page"><a href="../operations/incident-response.html">Incident Response</a></li>
          </ul>
        </li>
        <li class="nav-section">
          <div class="nav-section-title">Reference</div>
          <ul class="nav-subsections">
            <li class="nav-page"><a href="../foundations/invariants-reference.html">Invariants Reference</a></li>
            <li class="nav-page"><a href="../../reference/index.html">Full Reference</a></li>
            <li class="nav-page"><a href="../../reference/cost-analysis.html">Cost Analysis</a></li>
          </ul>
        </li>
      </ul>
    </nav>

    <!-- Sidebar overlay for mobile -->
    <div class="sidebar-overlay"></div>

    <!-- Main content -->
    <main class="main-content">
      <!-- Breadcrumb -->
      <nav class="breadcrumb">
        <a href="../../index.html">Home</a>
        <span class="breadcrumb-separator">/</span>
        <a href="../index.html">Journeys</a>
        <span class="breadcrumb-separator">/</span>
        <a href="index.html">Implementation</a>
        <span class="breadcrumb-separator">/</span>
        <span class="breadcrumb-current">Hooks &amp; Enterprise</span>
      </nav>

      <!-- Page meta -->
      <div class="page-meta">
        <span class="page-meta-item">~70 min read</span>
      </div>

      <h1>Hooks & Enterprise Patterns</h1>

      <div class="context-box you-are-here">
        <h3>You Are Here</h3>
        <p><strong>What this covers:</strong> Pre/post tool hooks for safety, formatting, and notifications, plus enterprise patterns for cost management (LiteLLM), concurrent execution (Swarms), and QA integration (BMAD-METHOD).</p>
        <p><strong>Time estimate:</strong> ~70 minutes for full read</p>
        <p><strong>Where this fits:</strong></p>
        <div class="ascii-diagram">Foundations (Principles/Architecture)
           |
    =====================================
    |  Building Production Systems      |
    =====================================
           |
    +-- Context & State
    +-- Ralph Production
    +-- >>> HOOKS & ENTERPRISE <<< (here)
           |
    Operations (Monitoring/Recovery)</div>
        <p><strong>Key sources:</strong></p>
        <ul>
          <li><a href="https://github.com/0xSero/orchestra">0xSero/orchestra</a> - Docker isolation, profiles</li>
          <li><a href="https://github.com/ruvnet/claude-flow">ruvnet/claude-flow</a> - 100+ MCP tools</li>
          <li><a href="https://github.com/BerriAI/litellm">BerriAI/litellm</a> - Budget-aware model routing</li>
          <li><a href="https://github.com/kyegomez/swarms">kyegomez/swarms</a> - Concurrent agent execution</li>
          <li><a href="https://github.com/bmad-code-org/BMAD-METHOD">bmad-code-org/BMAD-METHOD</a> - QA agent integration</li>
        </ul>
      </div>

      <p>This guide covers pre/post tool hooks for safety, formatting, and notifications, plus enterprise patterns for cost management, concurrent execution, and QA integration. These patterns enable production-grade Claude Code deployments.</p>

      <!-- Woven Summary 1: Hook Types Overview -->
      <div class="context-box" style="background: linear-gradient(135deg, #f0ebe3 0%, #fefcf3 100%); border-left: 4px solid #2a7d7d; border-radius: 8px; padding: 1.5rem; margin: 2rem 0;">
        <h3>Deep Dive: Hook Types and Lifecycle</h3>
        <p><strong>Source:</strong> <a href="../../synthesis/mcp-ecosystem-complete.html">MCP Ecosystem Complete</a></p>
        <p>Claude Code hooks provide three interception points for customizing agent behavior. Understanding when each fires is critical for building reliable safety and formatting pipelines.</p>

        <table>
          <thead><tr><th>Hook Type</th><th>When It Fires</th><th>Common Uses</th><th>Can Block?</th></tr></thead>
          <tbody>
            <tr><td><strong>PreToolUse</strong></td><td>Before any tool executes</td><td>Security gates, command filtering, secret scanning</td><td>Yes - exit 1 blocks</td></tr>
            <tr><td><strong>PostToolUse</strong></td><td>After tool completes</td><td>Auto-formatting, notifications, metrics</td><td>No - informational only</td></tr>
            <tr><td><strong>SessionStart</strong></td><td>When session begins</td><td>Context injection, profile loading, state restore</td><td>No - setup only</td></tr>
          </tbody>
        </table>

        <p><strong>Configuration example (.claude/hooks.json):</strong></p>
        <div class="code-block">
          <button class="copy-btn">Copy</button>
          <pre><code>{
  "hooks": {
    "PreToolUse": [
      {
        "matcher": "Bash",
        "hooks": [{ "type": "command", "command": "~/.claude/hooks/security-gate.sh" }]
      }
    ],
    "PostToolUse": [
      {
        "matcher": "Edit",
        "hooks": [{ "type": "command", "command": "prettier --write $FILE" }]
      }
    ]
  }
}</code></pre>
        </div>

        <p><strong>Key insight:</strong> PreToolUse hooks can <em>block</em> dangerous operations, but PostToolUse hooks can only <em>observe</em>. Use PreToolUse for security gates, PostToolUse for formatting and notifications.</p>
        <p><em>For complete MCP tool ecosystem including 100+ community tools, see <a href="../../synthesis/mcp-ecosystem-complete.html">MCP Ecosystem Complete</a>.</em></p>
      </div>

      <hr class="section-divider">

      <h2 id="hook-templates">Part 1: Hook Templates</h2>

      <p>Reference implementations from:</p>
      <ul>
        <li><a href="https://github.com/0xSero/orchestra">0xSero/orchestra</a> - Docker isolation hooks</li>
        <li><a href="https://github.com/ruvnet/claude-flow">ruvnet/claude-flow</a> - MCP tool integration (100+ tools)</li>
        <li><a href="https://github.com/paul-gauthier/aider">paul-gauthier/aider</a> - Auto-commit hooks</li>
      </ul>

      <h3 id="profile-hooks">Worker Profile Hooks (Orchestra Pattern)</h3>

      <p>Source: <a href="https://github.com/0xSero/orchestra">0xSero/orchestra</a></p>

      <p>Orchestra uses profile-based hooks to load different tool configurations for different worker types:</p>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code>#!/bin/bash
# opencode-profile-hooks.sh - Load worker-specific tool configurations

PROFILE_DIR="${HOME}/.claude/profiles"
mkdir -p "$PROFILE_DIR"

# Create profile configurations (Orchestra pattern)
init_profiles() {
    # Coder profile - full file access
    cat > "$PROFILE_DIR/coder.json" << 'EOF'
{
  "profile": "coder",
  "tools_enabled": ["Read", "Write", "Edit", "Bash", "Glob", "Grep"],
  "tools_disabled": ["WebFetch"],
  "context_budget": 60,
  "auto_commit": true,
  "commit_format": "feat(${component}): ${action}"
}
EOF

    # Architect profile - read-only + planning
    cat > "$PROFILE_DIR/architect.json" << 'EOF'
{
  "profile": "architect",
  "tools_enabled": ["Read", "Glob", "Grep", "WebFetch"],
  "tools_disabled": ["Write", "Edit", "Bash"],
  "context_budget": 50,
  "auto_commit": false,
  "output_format": "markdown"
}
EOF

    # Critic profile - read + limited bash for tests
    cat > "$PROFILE_DIR/critic.json" << 'EOF'
{
  "profile": "critic",
  "tools_enabled": ["Read", "Glob", "Grep", "Bash"],
  "tools_disabled": ["Write", "Edit"],
  "bash_allowlist": ["npm test", "npm run lint", "npm run typecheck", "git log", "git diff"],
  "context_budget": 40,
  "auto_commit": false
}
EOF
}

# Load profile at session start
load_profile() {
    local profile="${1:-coder}"
    local profile_file="$PROFILE_DIR/${profile}.json"

    if [ ! -f "$profile_file" ]; then
        echo "Profile not found: $profile" >&2
        return 1
    fi

    # Export profile settings for hooks to use
    export CLAUDE_PROFILE="$profile"
    export CLAUDE_CONTEXT_BUDGET=$(jq -r '.context_budget' "$profile_file")
    export CLAUDE_AUTO_COMMIT=$(jq -r '.auto_commit' "$profile_file")

    echo "Loaded profile: $profile (budget: ${CLAUDE_CONTEXT_BUDGET}%)"
}

# Hook: Enforce profile tool restrictions
enforce_profile_tools() {
    local tool_name="$1"
    local profile_file="$PROFILE_DIR/${CLAUDE_PROFILE:-coder}.json"

    if [ ! -f "$profile_file" ]; then
        return 0  # Allow if no profile
    fi

    # Check if tool is disabled
    if jq -e ".tools_disabled | index(\"$tool_name\")" "$profile_file" > /dev/null 2>&1; then
        echo "BLOCKED: Tool '$tool_name' disabled for profile '$CLAUDE_PROFILE'" >&2
        return 1
    fi

    return 0
}</code></pre>
      </div>

      <h3 id="block-destructive">PreToolUse - Block Destructive Commands</h3>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code>#!/bin/bash
# block-destructive.sh - PreToolUse hook to prevent dangerous commands
# Location: ~/.claude/hooks/block-destructive.sh

TOOL_NAME="${TOOL_NAME:-}"
if [ "$TOOL_NAME" != "Bash" ]; then
    exit 0
fi

COMMAND=$(echo "$EVENT_DATA" | jq -r '.tool_input.command // empty')

if [ -z "$COMMAND" ]; then
    exit 0
fi

DANGEROUS_PATTERNS=(
    "rm -rf /"
    "rm -rf ~"
    "rm -rf \$HOME"
    "rm -rf /*"
    "> /dev/sda"
    "mkfs"
    "dd if=/dev"
    ":(){:|:&};:"
    "chmod -R 777 /"
    "git push.*--force.*main"
    "git push.*--force.*master"
    "git reset --hard.*origin"
    "DROP TABLE"
    "DROP DATABASE"
    "TRUNCATE TABLE"
    "curl.*| bash"
    "curl.*| sh"
    "wget.*| bash"
    "wget.*| sh"
    "sudo rm"
    "sudo dd"
)

for pattern in "${DANGEROUS_PATTERNS[@]}"; do
    if echo "$COMMAND" | grep -qiE "$pattern"; then
        echo "BLOCKED: Dangerous command pattern detected: $pattern" >&2
        echo "Command was: $COMMAND" >&2
        exit 1
    fi
done

exit 0</code></pre>
      </div>

      <h3 id="scan-secrets">PreToolUse - Secret Scanning</h3>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code>#!/bin/bash
# scan-secrets.sh - Block writes containing secrets
# Location: ~/.claude/hooks/scan-secrets.sh

TOOL_NAME="${TOOL_NAME:-}"

if [ "$TOOL_NAME" != "Write" ]; then
    exit 0
fi

CONTENT=$(echo "$EVENT_DATA" | jq -r '.tool_input.content // empty')
FILE_PATH=$(echo "$EVENT_DATA" | jq -r '.tool_input.file_path // empty')

if [ -z "$CONTENT" ]; then
    exit 0
fi

SECRET_PATTERNS=(
    "sk-ant-[a-zA-Z0-9]+"                    # Anthropic API keys
    "sk-[a-zA-Z0-9]{48}"                     # OpenAI API keys
    "AKIA[0-9A-Z]{16}"                       # AWS Access Key
    "ghp_[a-zA-Z0-9]{36}"                    # GitHub Personal Token
    "gho_[a-zA-Z0-9]{36}"                    # GitHub OAuth Token
    "xox[baprs]-[0-9a-zA-Z-]+"               # Slack tokens
    "-----BEGIN RSA PRIVATE KEY-----"        # RSA private key
    "-----BEGIN OPENSSH PRIVATE KEY-----"    # SSH private key
    "AIza[0-9A-Za-z_-]{35}"                  # Google API key
)

for pattern in "${SECRET_PATTERNS[@]}"; do
    if echo "$CONTENT" | grep -qE "$pattern"; then
        echo "BLOCKED: Potential secret detected in write to: $FILE_PATH" >&2
        echo "Pattern matched: $pattern" >&2
        exit 1
    fi
done

exit 0</code></pre>
      </div>

      <h3 id="auto-format">PostToolUse - Auto-Format on Write</h3>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code>#!/bin/bash
# auto-format.sh - Format files after writes
# Location: ~/.claude/hooks/auto-format.sh

TOOL_NAME="${TOOL_NAME:-}"

if [ "$TOOL_NAME" != "Write" ] && [ "$TOOL_NAME" != "Edit" ]; then
    exit 0
fi

FILE_PATH=$(echo "$EVENT_DATA" | jq -r '.tool_input.file_path // empty')

if [ -z "$FILE_PATH" ] || [ ! -f "$FILE_PATH" ]; then
    exit 0
fi

EXT="${FILE_PATH##*.}"

case "$EXT" in
    js|jsx|ts|tsx|json|md|html|css)
        if command -v prettier &> /dev/null; then
            prettier --write "$FILE_PATH" 2>/dev/null &
        fi
        ;;
    py)
        if command -v black &> /dev/null; then
            black "$FILE_PATH" 2>/dev/null &
        fi
        ;;
    go)
        if command -v gofmt &> /dev/null; then
            gofmt -w "$FILE_PATH" 2>/dev/null &
        fi
        ;;
    rs)
        if command -v rustfmt &> /dev/null; then
            rustfmt "$FILE_PATH" 2>/dev/null &
        fi
        ;;
esac

exit 0</code></pre>
      </div>

      <h3 id="notify-mobile">PreToolUse - Mobile Push Notifications</h3>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code>#!/bin/bash
# notify-mobile.sh - Send push notification when Claude asks questions
# Location: ~/.claude/hooks/notify-mobile.sh

TOOL_NAME="${TOOL_NAME:-}"

if [ "$TOOL_NAME" != "AskUserQuestion" ]; then
    exit 0
fi

QUESTION=$(echo "$EVENT_DATA" | jq -r '.tool_input.questions[0].question // "Claude needs input"')

# Option 1: Poke (iOS)
POKE_WEBHOOK="${POKE_WEBHOOK:-}"
if [ -n "$POKE_WEBHOOK" ]; then
    curl -s -X POST "$POKE_WEBHOOK" \
        -H "Content-Type: application/json" \
        -d "{\"title\": \"Claude Code\", \"body\": \"$QUESTION\"}" &
fi

# Option 2: ntfy (open source)
NTFY_TOPIC="${NTFY_TOPIC:-}"
if [ -n "$NTFY_TOPIC" ]; then
    curl -s -X POST "https://ntfy.sh/$NTFY_TOPIC" \
        -H "Title: Claude Code" \
        -d "$QUESTION" &
fi

# Option 3: macOS native (local only)
if [ "$(uname)" = "Darwin" ]; then
    osascript -e "display notification \"$QUESTION\" with title \"Claude Code\"" 2>/dev/null &
fi

exit 0</code></pre>
      </div>

      <h3 id="audit-log">SessionStart - Audit Logging</h3>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code>#!/bin/bash
# audit-log.sh - Log all Claude sessions for compliance
# Location: ~/.claude/hooks/audit-log.sh

AUDIT_DIR="${HOME}/.claude/audit"
mkdir -p "$AUDIT_DIR"

LOG_FILE="$AUDIT_DIR/$(date +%Y-%m-%d).jsonl"

jq -nc \
    --arg ts "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
    --arg event "session_start" \
    --arg pwd "$(pwd)" \
    --arg user "$(whoami)" \
    --arg branch "$(git branch --show-current 2>/dev/null || echo 'none')" \
    '{
        timestamp: $ts,
        event: $event,
        working_directory: $pwd,
        user: $user,
        git_branch: $branch
    }' >> "$LOG_FILE"

exit 0</code></pre>
      </div>

      <h3 id="aider-auto-commit">Aider-Style Auto-Commit Hook</h3>

      <p>Source: <a href="https://github.com/paul-gauthier/aider">paul-gauthier/aider</a></p>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code>#!/bin/bash
# aider-auto-commit.sh - Auto-commit after file writes (Aider pattern)
# Location: ~/.claude/hooks/aider-auto-commit.sh

TOOL_NAME="${TOOL_NAME:-}"

# Only trigger on Write or Edit
if [ "$TOOL_NAME" != "Write" ] && [ "$TOOL_NAME" != "Edit" ]; then
    exit 0
fi

# Check if auto-commit is enabled for this profile
if [ "${CLAUDE_AUTO_COMMIT:-false}" != "true" ]; then
    exit 0
fi

FILE_PATH=$(echo "$EVENT_DATA" | jq -r '.tool_input.file_path // empty')

if [ -z "$FILE_PATH" ]; then
    exit 0
fi

# Extract component from file path (Aider convention)
COMPONENT=$(dirname "$FILE_PATH" | sed 's|.*/||')
if [ -z "$COMPONENT" ] || [ "$COMPONENT" = "." ]; then
    COMPONENT="root"
fi

# Generate commit message
FILENAME=$(basename "$FILE_PATH")
ACTION="update $FILENAME"

# Aider-style commit
cd "$(dirname "$FILE_PATH")" 2>/dev/null || exit 0
git add "$FILE_PATH" 2>/dev/null || exit 0

if ! git diff --cached --quiet 2>/dev/null; then
    git commit -m "feat($COMPONENT): $ACTION" 2>/dev/null &
fi

exit 0</code></pre>
      </div>

      <h3 id="docker-isolation">Docker Isolation Hook (Orchestra Pattern)</h3>

      <p>Source: <a href="https://github.com/0xSero/orchestra">0xSero/orchestra</a></p>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code>#!/bin/bash
# docker-isolation.sh - Run dangerous commands in Docker (Orchestra pattern)
# Location: ~/.claude/hooks/docker-isolation.sh

TOOL_NAME="${TOOL_NAME:-}"

if [ "$TOOL_NAME" != "Bash" ]; then
    exit 0
fi

COMMAND=$(echo "$EVENT_DATA" | jq -r '.tool_input.command // empty')

if [ -z "$COMMAND" ]; then
    exit 0
fi

# Patterns that should run in Docker isolation
ISOLATE_PATTERNS=(
    "npm install"
    "pip install"
    "cargo build"
    "make"
    "cmake"
    "python.*setup.py"
)

for pattern in "${ISOLATE_PATTERNS[@]}"; do
    if echo "$COMMAND" | grep -qE "$pattern"; then
        echo "ISOLATE: Command matches isolation pattern: $pattern" >&2

        # Run in Docker container instead
        docker run --rm \
            -v "$(pwd):/workspace" \
            -w /workspace \
            --network none \
            node:18 \
            bash -c "$COMMAND" &

        # Tell Claude to wait for Docker output
        echo "Command running in Docker isolation..."
        exit 0
    fi
done

exit 0</code></pre>
      </div>

      <h3 id="claude-flow-mcp">Claude-Flow MCP Integration Hook</h3>

      <p>Source: <a href="https://github.com/ruvnet/claude-flow">ruvnet/claude-flow</a> (100+ MCP tools)</p>

      <p>Claude-Flow's 100+ MCP tool library can be loaded selectively via hooks:</p>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code>#!/bin/bash
#===============================================================================
# claude-flow-mcp.sh - Load Claude-Flow MCP tools based on task
# Location: ~/.claude/hooks/claude-flow-mcp.sh
#===============================================================================

# MCP tool categories from Claude-Flow
declare -A MCP_CATEGORIES=(
    ["file"]="read write edit glob grep"
    ["git"]="git-status git-log git-diff git-commit"
    ["api"]="http-get http-post api-call"
    ["db"]="sqlite-query postgres-query"
    ["browser"]="browser-open browser-screenshot"
)

# Load MCP tools based on current task
load_mcp_for_task() {
    local task_type="$1"

    case "$task_type" in
        "implementation")
            echo "file git"
            ;;
        "testing")
            echo "file git bash"
            ;;
        "research")
            echo "file api browser"
            ;;
        "database")
            echo "file db git"
            ;;
        *)
            echo "file"
            ;;
    esac
}

# Get current task type from PRD
get_task_type() {
    local prd_file="${1:-plans/prd.json}"

    if [ -f "$prd_file" ]; then
        # Extract story type from title keywords
        local title=$(jq -r '.userStories[] | select(.passes == false) | .title' "$prd_file" | head -1)

        if echo "$title" | grep -qiE "test|spec|validate"; then
            echo "testing"
        elif echo "$title" | grep -qiE "database|schema|migration"; then
            echo "database"
        elif echo "$title" | grep -qiE "research|analyze|investigate"; then
            echo "research"
        else
            echo "implementation"
        fi
    else
        echo "implementation"
    fi
}

# Main: Load appropriate MCP tools
TASK_TYPE=$(get_task_type)
MCP_TOOLS=$(load_mcp_for_task "$TASK_TYPE")

echo "Task type: $TASK_TYPE"
echo "MCP tools loaded: $MCP_TOOLS"

export CLAUDE_MCP_TOOLS="$MCP_TOOLS"
exit 0</code></pre>
      </div>

      <h3 id="hooks-json">Complete hooks.json Configuration</h3>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code>{
  "hooks": {
    "PreToolUse": [
      {
        "matcher": "Bash",
        "hooks": [
          {
            "type": "command",
            "command": "~/.claude/hooks/block-destructive.sh"
          }
        ]
      },
      {
        "matcher": "Write",
        "hooks": [
          {
            "type": "command",
            "command": "~/.claude/hooks/scan-secrets.sh"
          }
        ]
      },
      {
        "matcher": "AskUserQuestion",
        "hooks": [
          {
            "type": "command",
            "command": "~/.claude/hooks/notify-mobile.sh"
          }
        ]
      }
    ],
    "PostToolUse": [
      {
        "matcher": "Write",
        "hooks": [
          {
            "type": "command",
            "command": "~/.claude/hooks/auto-format.sh"
          }
        ]
      },
      {
        "matcher": "Edit",
        "hooks": [
          {
            "type": "command",
            "command": "~/.claude/hooks/auto-format.sh"
          }
        ]
      }
    ],
    "SessionStart": [
      {
        "type": "command",
        "command": "~/.claude/hooks/generate-context.sh"
      },
      {
        "type": "command",
        "command": "~/.claude/hooks/audit-log.sh"
      }
    ]
  }
}</code></pre>
      </div>

      <div class="checkpoint">
        <div class="checkpoint-header">Checkpoint: Hook Setup</div>
        <div class="checkpoint-content">
          <p>Verify your hooks are configured:</p>
          <div class="code-block">
            <button class="copy-btn">Copy</button>
            <pre><code># Make hooks executable
chmod +x ~/.claude/hooks/*.sh

# Verify hooks.json is valid
jq empty ~/.claude/hooks.json && echo "Valid JSON"

# Test a hook manually
TOOL_NAME=Bash EVENT_DATA='{"tool_input":{"command":"echo hello"}}' \
  ~/.claude/hooks/block-destructive.sh && echo "Hook passed"</code></pre>
          </div>
        </div>
      </div>

      <details class="troubleshoot">
        <summary>Hook configuration issues</summary>
        <div class="troubleshoot-content">
          <table>
            <tr><th>Symptom</th><th>Cause</th><th>Recovery</th></tr>
            <tr><td>Hooks not running</td><td>hooks.json not found</td><td>Check path: <code>~/.claude/hooks.json</code> or <code>.claude/hooks.json</code></td></tr>
            <tr><td>"Permission denied"</td><td>Script not executable</td><td>Run <code>chmod +x ~/.claude/hooks/*.sh</code></td></tr>
            <tr><td>Hook blocks everything</td><td>Pattern too broad</td><td>Narrow the regex pattern</td></tr>
            <tr><td>jq errors</td><td>EVENT_DATA not available</td><td>Check Claude Code version supports hooks</td></tr>
          </table>
        </div>
      </details>

      <!-- Woven Summary 2: MCP Integration -->
      <div class="context-box" style="background: linear-gradient(135deg, #f0ebe3 0%, #fefcf3 100%); border-left: 4px solid #6b9b7a; border-radius: 8px; padding: 1.5rem; margin: 2rem 0;">
        <h3>Deep Dive: MCP Tool Ecosystem</h3>
        <p><strong>Source:</strong> <a href="../../synthesis/mcp-ecosystem-complete.html">MCP Ecosystem Complete</a></p>
        <p>The Model Context Protocol (MCP) extends Claude Code with external tools. The ecosystem now includes 100+ community tools covering databases, APIs, browsers, and more.</p>

        <p><strong>Popular MCP categories:</strong></p>
        <table>
          <thead><tr><th>Category</th><th>Notable Tools</th><th>Use Case</th></tr></thead>
          <tbody>
            <tr><td><strong>Databases</strong></td><td>PostgreSQL, SQLite, MongoDB</td><td>Direct DB queries without shell</td></tr>
            <tr><td><strong>APIs</strong></td><td>GitHub, Slack, Linear, Notion</td><td>Ticketing, notifications, docs</td></tr>
            <tr><td><strong>Browsers</strong></td><td>Playwright, Puppeteer</td><td>Web scraping, E2E testing</td></tr>
            <tr><td><strong>Search</strong></td><td>Brave, Perplexity</td><td>Research, documentation lookup</td></tr>
            <tr><td><strong>Memory</strong></td><td>Claude-Mem, Chroma</td><td>Cross-session persistence</td></tr>
          </tbody>
        </table>

        <p><strong>MCP tool loading pattern:</strong></p>
        <div class="code-block">
          <button class="copy-btn">Copy</button>
          <pre><code># Task-specific MCP loading (reduces context overhead)
load_mcp_for_task() {
    local task_type="$1"
    case "$task_type" in
        "api")        echo "github,linear,slack" ;;
        "database")   echo "postgres,sqlite" ;;
        "frontend")   echo "playwright,browser" ;;
        "research")   echo "brave,perplexity,websearch" ;;
        *)            echo "" ;;  # No extra MCP tools
    esac
}</code></pre>
        </div>
        <p><strong>Key insight:</strong> Load MCP tools only when needed. Each loaded tool consumes context window space even when not used. Task-based loading (shown above) is more efficient than loading everything.</p>
      </div>

      <hr class="section-divider">

      <h2 id="enterprise-patterns">Part 2: Enterprise Implementation Patterns</h2>

      <h3 id="litellm">LiteLLM Enterprise Cost Management</h3>

      <p>Source: <a href="https://github.com/BerriAI/litellm">BerriAI/litellm</a> - Production-grade model routing with budget controls</p>

      <p>LiteLLM provides the infrastructure layer for enterprise Claude Code deployments:</p>
      <ul>
        <li>Routes requests to cheaper models when approaching budget limits</li>
        <li>Provides team-level spending visibility and allocation</li>
        <li>Essential for Bedrock/Vertex deployments</li>
        <li>Enables fallback chains when rate-limited</li>
      </ul>

      <h4>Budget-Aware Router Configuration</h4>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code># litellm_config.yaml - Enterprise budget management
# Location: /etc/litellm/config.yaml or ~/.litellm/config.yaml

model_list:
  - model_name: claude-opus
    litellm_params:
      model: claude-3-opus-20240229
      api_key: ${ANTHROPIC_API_KEY}
    model_info:
      max_tokens: 200000
      input_cost_per_token: 0.000015
      output_cost_per_token: 0.000075

  - model_name: claude-sonnet
    litellm_params:
      model: claude-3-5-sonnet-20241022
      api_key: ${ANTHROPIC_API_KEY}
    model_info:
      max_tokens: 200000
      input_cost_per_token: 0.000003
      output_cost_per_token: 0.000015

  - model_name: claude-haiku
    litellm_params:
      model: claude-3-5-haiku-20241022
      api_key: ${ANTHROPIC_API_KEY}
    model_info:
      max_tokens: 200000
      input_cost_per_token: 0.00000025
      output_cost_per_token: 0.00000125

litellm_settings:
  # Budget enforcement
  budget_manager:
    max_budget: 100.00          # Daily limit in USD
    budget_duration: daily
    soft_budget: 80.00          # Alert threshold

  # Cost-optimized routing
  router_settings:
    routing_strategy: cost-optimized
    fallbacks:
      - claude-opus: [claude-sonnet, claude-haiku]
      - claude-sonnet: [claude-haiku]

    # Route to cheaper model when approaching budget
    budget_routing:
      budget_threshold_percent: 80
      downgrade_to: claude-sonnet
      emergency_threshold_percent: 95
      emergency_model: claude-haiku

  # Rate limit handling
  rate_limit_policy:
    retry_on_rate_limit: true
    max_retries: 3
    retry_delay: 10</code></pre>
      </div>

      <h4>LiteLLM Python Integration</h4>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code>#!/usr/bin/env python3
"""litellm_claude_wrapper.py - Budget-aware Claude Code integration"""

import litellm
from litellm import completion, BudgetManager

budget_manager = BudgetManager(
    project_name="claude-code-production",
    max_budget=100.0,
    time_period="daily"
)

def get_claude_response(prompt: str, task_complexity: str = "medium") -> dict:
    """Get response with automatic model selection based on budget."""
    model_map = {
        "simple": "claude-haiku",
        "medium": "claude-sonnet",
        "complex": "claude-opus"
    }
    selected_model = model_map.get(task_complexity, "claude-sonnet")

    # LiteLLM budget-aware downgrade
    remaining = budget_manager.get_remaining_budget()
    if remaining < 5.0:
        selected_model = "claude-haiku"
    elif remaining < 20.0 and selected_model == "claude-opus":
        selected_model = "claude-sonnet"

    response = completion(
        model=selected_model,
        messages=[{"role": "user", "content": prompt}],
        max_tokens=4096
    )
    cost = litellm.completion_cost(response)
    budget_manager.update_cost(cost)

    return {
        "content": response.choices[0].message.content,
        "model_used": selected_model,
        "cost_usd": cost,
        "remaining_budget": budget_manager.get_remaining_budget()
    }</code></pre>
      </div>

      <h4>Ralph Integration with LiteLLM</h4>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code>#!/bin/bash
# ralph-litellm.sh - Ralph loop with LiteLLM budget controls

check_litellm_budget() {
    python3 -c "
from litellm import BudgetManager
bm = BudgetManager('claude-code-production')
print(bm.get_remaining_budget())
"
}

select_model_by_budget() {
    local remaining=$(check_litellm_budget)
    if (( $(echo "$remaining < 5" | bc -l) )); then
        echo "claude-haiku"
    elif (( $(echo "$remaining < 20" | bc -l) )); then
        echo "claude-sonnet"
    else
        echo "claude-opus"
    fi
}

run_iteration() {
    local model=$(select_model_by_budget)
    echo "Using model: $model (budget: \$$(check_litellm_budget) remaining)"
    ANTHROPIC_MODEL="$model" cat "$PROMPT_FILE" | claude-code
}</code></pre>
      </div>

      <h4>LiteLLM Cost Impact</h4>

      <table>
        <thead>
          <tr>
            <th>Scenario</th>
            <th>Without LiteLLM</th>
            <th>With LiteLLM</th>
            <th>Savings</th>
          </tr>
        </thead>
        <tbody>
          <tr><td>50-iteration Ralph</td><td>$50-$75 (all Opus)</td><td>$15-$25 (mixed)</td><td>60-70%</td></tr>
          <tr><td>Budget exceeded</td><td>Session crashed</td><td>Graceful fallback</td><td>100% uptime</td></tr>
          <tr><td>Rate limited</td><td>Manual retry</td><td>Auto-fallback</td><td>Zero downtime</td></tr>
        </tbody>
      </table>

      <hr class="section-divider">

      <h3 id="swarms">Swarms Concurrent Agent Framework</h3>

      <p>Source: <a href="https://github.com/kyegomez/swarms">kyegomez/swarms</a> - Enterprise multi-agent framework (45M+ agents spawned)</p>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code>#!/usr/bin/env python3
"""swarms_claude_integration.py - Concurrent Claude Code agent execution"""

from dataclasses import dataclass
from typing import List
from concurrent.futures import ThreadPoolExecutor, as_completed
import subprocess


@dataclass
class SwarmTask:
    """Task definition for concurrent execution."""
    task_id: str
    prompt_file: str
    dependencies: List[str] = None
    timeout_seconds: int = 300
    model: str = "claude-sonnet"


class ClaudeSwarm:
    """
    Concurrent Claude Code execution using Swarms patterns.
    - Parallel independent task execution
    - Dependency-aware scheduling (DAG pattern)
    """

    def __init__(self, max_workers: int = 4):
        self.executor = ThreadPoolExecutor(max_workers=max_workers)

    def execute_task(self, task: SwarmTask) -> dict:
        """Execute single Claude Code task."""
        try:
            result = subprocess.run(
                ["claude-code", "--print"],
                stdin=open(task.prompt_file),
                capture_output=True, text=True,
                timeout=task.timeout_seconds,
                env={**dict(__import__('os').environ),
                     'ANTHROPIC_MODEL': task.model}
            )
            return {
                "task_id": task.task_id,
                "status": "complete" if result.returncode == 0 else "failed",
                "output": result.stdout
            }
        except subprocess.TimeoutExpired:
            return {"task_id": task.task_id, "status": "timeout"}

    def run_parallel(self, tasks: List[SwarmTask]) -> List[dict]:
        """Execute independent tasks in parallel (Swarms fan-out)."""
        futures = {self.executor.submit(self.execute_task, task): task
                   for task in tasks}
        return [future.result() for future in as_completed(futures)]

    def run_with_dependencies(self, tasks: List[SwarmTask]) -> List[dict]:
        """Execute with dependency ordering (Swarms DAG pattern)."""
        completed, results, pending = set(), [], list(tasks)
        while pending:
            ready = [t for t in pending
                     if not t.dependencies or
                     all(d in completed for d in t.dependencies)]
            batch_results = self.run_parallel(ready)
            results.extend(batch_results)
            for r in batch_results:
                if r["status"] == "complete":
                    completed.add(r["task_id"])
            pending = [t for t in pending if t.task_id not in completed]
        return results


# Example: Parallel feature build
def parallel_feature_build():
    """Swarms-style concurrent feature implementation."""
    swarm = ClaudeSwarm(max_workers=3)
    tasks = [
        # Phase 1: Independent (parallel)
        SwarmTask("db-schema", "prompts/auth-schema.md"),
        SwarmTask("api-types", "prompts/auth-types.md"),
        SwarmTask("test-fixtures", "prompts/auth-fixtures.md"),
        # Phase 2: Depends on Phase 1
        SwarmTask("api-routes", "prompts/auth-routes.md",
                  dependencies=["db-schema", "api-types"]),
        # Phase 3: Integration
        SwarmTask("integration", "prompts/auth-integration.md",
                  dependencies=["api-routes", "test-fixtures"])
    ]
    return swarm.run_with_dependencies(tasks)</code></pre>
      </div>

      <h4>Swarms Configuration</h4>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code># swarms_config.yaml - Concurrent agent scaling
swarm_settings:
  concurrency:
    max_parallel_tasks: 4
    task_timeout_seconds: 300
    retry_attempts: 3

  # Model assignment by task type
  model_routing:
    orchestration: claude-opus     # Complex reasoning
    implementation: claude-sonnet  # Code generation
    testing: claude-sonnet         # Test writing
    documentation: claude-haiku    # Simple text</code></pre>
      </div>

      <h4>Swarms Performance Impact</h4>

      <table>
        <thead>
          <tr>
            <th>Approach</th>
            <th>6-Task Feature</th>
            <th>Time</th>
            <th>Cost</th>
          </tr>
        </thead>
        <tbody>
          <tr><td>Sequential</td><td>6 tasks @ 30min</td><td>3 hours</td><td>$18</td></tr>
          <tr><td>Swarms parallel (3 agents)</td><td>3 phases</td><td>1.2 hours</td><td>$15</td></tr>
          <tr><td>Swarms with model routing</td><td>Optimized</td><td>1 hour</td><td>$10</td></tr>
        </tbody>
      </table>

      <hr class="section-divider">

      <h3 id="bmad">BMAD-METHOD QA Agent Integration</h3>

      <p>Source: <a href="https://github.com/bmad-code-org/BMAD-METHOD">bmad-code-org/BMAD-METHOD</a> - 19 specialized agents with "document sharding"</p>

      <h4>BMAD QA Agent Setup</h4>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code># bmad_qa_agent.yaml - Quality assurance agent configuration

qa_agent:
  role: quality_assurance
  description: "Validates implementation against acceptance criteria"

  # Document sharding - key BMAD insight
  context_loading:
    strategy: progressive
    max_context_percent: 40
    shard_by:
      - acceptance_criteria
      - test_specifications
      - code_under_review

  verification_steps:
    - name: schema_validation
      command: "npm run typecheck"
      required: true
      failure_action: block_merge

    - name: test_execution
      command: "npm run test"
      required: true
      failure_action: block_merge

    - name: lint_check
      command: "npm run lint"
      required: false
      failure_action: warn</code></pre>
      </div>

      <h4>BMAD Checklist Script</h4>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code>#!/bin/bash
# bmad-qa-check.sh - BMAD-METHOD QA checklist execution

PRD_FILE="${1:-plans/prd.json}"
STORY_ID="${2:-}"

# BMAD Pattern: Load only relevant acceptance criteria (document sharding)
load_acceptance_criteria() {
    jq -r ".userStories[] | select(.id == \"$1\") | .acceptanceCriteria[]" "$PRD_FILE"
}

run_bmad_verification() {
    local story_id="$1"
    mkdir -p .bmad

    echo "=== BMAD QA Verification: $story_id ==="

    # Technical verification
    local typecheck_pass=false
    local test_pass=false

    npm run typecheck 2>&1 && typecheck_pass=true
    npm run test 2>&1 && test_pass=true

    # Generate BMAD-style report
    cat > ".bmad/qa-results-$story_id.json" << EOF
{
    "story_id": "$story_id",
    "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
    "technical_verification": {
        "typecheck": $typecheck_pass,
        "tests": $test_pass
    },
    "overall_status": "$([ "$typecheck_pass" = true ] && [ "$test_pass" = true ] && echo "PASS" || echo "FAIL")"
}
EOF

    cat ".bmad/qa-results-$story_id.json" | jq .
}

run_bmad_verification "$STORY_ID"</code></pre>
      </div>

      <h4>BMAD Story File Template</h4>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code># Story: {STORY_ID} - {STORY_TITLE}

## BMAD Document Shard
&lt;!-- BMAD pattern: Each agent loads ONLY what it needs for this story --&gt;
&lt;!-- Context budget target: 40% max --&gt;

### Overview
Brief description of what this story accomplishes.

### Acceptance Criteria
&lt;!-- Specific, verifiable criteria - each must be testable --&gt;
- [ ] Criterion 1: {specific requirement}
- [ ] Criterion 2: {specific requirement}
- [ ] Criterion 3: {specific requirement}
- [ ] npm run typecheck passes with zero errors
- [ ] npm run test passes with all tests green

### Files Under Review
&lt;!-- List ONLY files relevant to this story --&gt;
- src/path/to/file1.ts
- src/path/to/file2.ts
- tests/path/to/test.ts

### BMAD Agent Assignment
- **Primary:** Developer Agent (implementation)
- **Secondary:** QA Agent (verification)
- **Model:** claude-sonnet (implementation tier)

### Dependencies
&lt;!-- Stories that must complete before this one --&gt;
- {STORY_ID}: {dependency description}

### Verification Commands
```bash
npm run typecheck
npm run test -- --grep "{story-related}"
./scripts/bmad-qa-check.sh plans/prd.json {STORY_ID}
```

### Context Loading Strategy
1. Load acceptance criteria ONLY (not full PRD)
2. Load affected files ONLY (not entire codebase)
3. Load relevant test fixtures
4. Stay under 40% context budget</code></pre>
      </div>

      <h4>BMAD Agent Role Selection</h4>

      <table>
        <thead>
          <tr>
            <th>Task Type</th>
            <th>BMAD Agent Role</th>
            <th>Context Budget</th>
          </tr>
        </thead>
        <tbody>
          <tr><td>Requirements</td><td>Analyst Agent</td><td>30%</td></tr>
          <tr><td>Architecture</td><td>Architect Agent</td><td>40%</td></tr>
          <tr><td>Implementation</td><td>Developer Agent</td><td>60%</td></tr>
          <tr><td>Testing</td><td>Test Agent</td><td>40%</td></tr>
          <tr><td>Code Review</td><td>Review Agent</td><td>35%</td></tr>
          <tr><td>Documentation</td><td>Doc Agent</td><td>25%</td></tr>
          <tr><td>QA Validation</td><td>QA Agent</td><td>40%</td></tr>
        </tbody>
      </table>

      <hr class="section-divider">

      <h3 id="agentdb">AgentDB Setup (Vector Memory)</h3>

      <p>Source: <a href="https://github.com/ruvnet/agentic-flow">ruvnet/agentic-flow</a> (66 SONA agents)</p>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code>#!/usr/bin/env python3
"""agent_db.py - Vector database setup for enterprise agent systems"""

import os
import json
import sqlite3
from datetime import datetime, timedelta
from typing import Optional, List, Dict, Any
import numpy as np
from pathlib import Path


class AgentDB:
    """
    Vector database for agent memory and pattern storage.

    Features:
    - SQLite + HNSW-style similarity search
    - Pattern storage with reward signals
    - Cross-agent knowledge sharing
    """

    def __init__(
        self,
        db_path: str = ".agent-state/agent_db.sqlite",
        embedding_dim: int = 1536
    ):
        self.db_path = Path(db_path)
        self.db_path.parent.mkdir(parents=True, exist_ok=True)
        self.embedding_dim = embedding_dim
        self._init_db()

    def _init_db(self):
        """Initialize database schema."""
        with sqlite3.connect(self.db_path) as conn:
            # Patterns table (ReasoningBank)
            conn.execute("""
                CREATE TABLE IF NOT EXISTS patterns (
                    id INTEGER PRIMARY KEY,
                    pattern_id TEXT UNIQUE NOT NULL,
                    problem_signature TEXT NOT NULL,
                    solution_steps TEXT NOT NULL,
                    embedding BLOB,
                    reward_score REAL DEFAULT 0,
                    applications INTEGER DEFAULT 0,
                    created_at TEXT NOT NULL,
                    updated_at TEXT NOT NULL
                )
            """)

            # Agent memory table
            conn.execute("""
                CREATE TABLE IF NOT EXISTS agent_memory (
                    id INTEGER PRIMARY KEY,
                    agent_id TEXT NOT NULL,
                    memory_type TEXT NOT NULL,
                    key TEXT NOT NULL,
                    value TEXT NOT NULL,
                    embedding BLOB,
                    created_at TEXT NOT NULL,
                    expires_at TEXT
                )
            """)

            conn.execute("""
                CREATE INDEX IF NOT EXISTS idx_patterns_id ON patterns(pattern_id)
            """)
            conn.execute("""
                CREATE INDEX IF NOT EXISTS idx_memory_agent ON agent_memory(agent_id)
            """)

    def store_pattern(
        self,
        pattern_id: str,
        problem_signature: str,
        solution_steps: List[str],
        reward_score: float = 0.0
    ) -> dict:
        """Store a learned pattern in the ReasoningBank."""
        now = datetime.utcnow().isoformat()

        with sqlite3.connect(self.db_path) as conn:
            conn.execute("""
                INSERT OR REPLACE INTO patterns
                (pattern_id, problem_signature, solution_steps,
                 reward_score, applications, created_at, updated_at)
                VALUES (?, ?, ?, ?,
                        COALESCE((SELECT applications FROM patterns WHERE pattern_id = ?), 0) + 1,
                        COALESCE((SELECT created_at FROM patterns WHERE pattern_id = ?), ?),
                        ?)
            """, (
                pattern_id, problem_signature, json.dumps(solution_steps),
                reward_score, pattern_id, pattern_id, now, now
            ))

        return {"pattern_id": pattern_id, "status": "stored"}

    def search_patterns(
        self,
        query: str,
        limit: int = 5,
        min_reward: float = 0.5
    ) -> List[dict]:
        """Search for relevant patterns using keyword matching."""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute("""
                SELECT pattern_id, problem_signature, solution_steps,
                       reward_score, applications
                FROM patterns
                WHERE reward_score >= ?
                AND problem_signature LIKE ?
                ORDER BY applications DESC
                LIMIT ?
            """, (min_reward, f'%{query}%', limit))

            return [
                {
                    "pattern_id": row[0],
                    "problem_signature": row[1],
                    "solution_steps": json.loads(row[2]),
                    "reward_score": row[3],
                    "applications": row[4]
                }
                for row in cursor
            ]

    def store_agent_memory(
        self,
        agent_id: str,
        key: str,
        value: Any,
        memory_type: str = "general",
        ttl_seconds: Optional[int] = None
    ):
        """Store agent-specific memory."""
        now = datetime.utcnow()
        expires = None
        if ttl_seconds:
            expires = (now + timedelta(seconds=ttl_seconds)).isoformat()

        with sqlite3.connect(self.db_path) as conn:
            conn.execute("""
                INSERT INTO agent_memory
                (agent_id, memory_type, key, value, created_at, expires_at)
                VALUES (?, ?, ?, ?, ?, ?)
            """, (
                agent_id, memory_type, key,
                json.dumps(value) if not isinstance(value, str) else value,
                now.isoformat(), expires
            ))

    def get_agent_memory(
        self,
        agent_id: str,
        key: Optional[str] = None,
        memory_type: Optional[str] = None
    ) -> List[dict]:
        """Retrieve agent memory."""
        now = datetime.utcnow().isoformat()

        query = """
            SELECT key, value, memory_type, created_at
            FROM agent_memory
            WHERE agent_id = ?
            AND (expires_at IS NULL OR expires_at > ?)
        """
        params = [agent_id, now]

        if key:
            query += " AND key = ?"
            params.append(key)
        if memory_type:
            query += " AND memory_type = ?"
            params.append(memory_type)

        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute(query, params)
            return [
                {"key": row[0], "value": row[1], "type": row[2], "created_at": row[3]}
                for row in cursor
            ]</code></pre>
      </div>

      <hr class="section-divider">

      <h3 id="cost-controls">Cost Controls Implementation</h3>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code>#!/bin/bash
# cost-controller.sh - Enterprise cost management for agent systems

COST_DB=".agent-state/cost_tracking.json"
ALERT_WEBHOOK="${COST_ALERT_WEBHOOK:-}"

init_cost_tracking() {
    if [ ! -f "$COST_DB" ]; then
        mkdir -p "$(dirname "$COST_DB")"
        cat > "$COST_DB" << EOF
{
    "budget": {
        "daily_limit_usd": 100.00,
        "session_limit_usd": 25.00,
        "alert_threshold_percent": 80
    },
    "spending": {
        "today": 0.00,
        "this_session": 0.00,
        "this_month": 0.00
    },
    "last_updated": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
    "agents": {}
}
EOF
    fi
}

record_spending() {
    local agent_id="$1"
    local amount="$2"

    local temp=$(mktemp)
    jq --arg agent "$agent_id" \
       --argjson amount "$amount" \
       --arg now "$(date -u +%Y-%m-%dT%H:%M:%SZ)" '
        .spending.today += $amount |
        .spending.this_session += $amount |
        .spending.this_month += $amount |
        .agents[$agent] = (.agents[$agent] // 0) + $amount |
        .last_updated = $now
    ' "$COST_DB" > "$temp"
    mv "$temp" "$COST_DB"

    check_limits
}

check_limits() {
    local daily_limit=$(jq -r '.budget.daily_limit_usd' "$COST_DB")
    local session_limit=$(jq -r '.budget.session_limit_usd' "$COST_DB")
    local alert_threshold=$(jq -r '.budget.alert_threshold_percent' "$COST_DB")

    local daily_spend=$(jq -r '.spending.today' "$COST_DB")
    local session_spend=$(jq -r '.spending.this_session' "$COST_DB")

    if (( $(echo "$daily_spend >= $daily_limit" | bc -l) )); then
        echo "CRITICAL: Daily limit exceeded (\$$daily_spend >= \$$daily_limit)"
        send_alert "CRITICAL: Daily cost limit exceeded"
        return 1
    fi

    if (( $(echo "$session_spend >= $session_limit" | bc -l) )); then
        echo "CRITICAL: Session limit exceeded (\$$session_spend >= \$$session_limit)"
        send_alert "CRITICAL: Session cost limit exceeded"
        return 1
    fi

    local daily_percent=$(echo "scale=0; $daily_spend * 100 / $daily_limit" | bc)
    if [ "$daily_percent" -ge "$alert_threshold" ]; then
        echo "WARNING: ${daily_percent}% of daily budget used"
        send_alert "WARNING: ${daily_percent}% of daily budget used"
    fi

    return 0
}

send_alert() {
    local message="$1"

    if [ -n "$ALERT_WEBHOOK" ]; then
        curl -s -X POST "$ALERT_WEBHOOK" \
            -H "Content-Type: application/json" \
            -d "{\"text\": \"$message\"}" &
    fi

    echo "[COST ALERT] $message" >&2
}

spending_report() {
    echo "=== Cost Report ==="
    echo ""
    echo "Budget Limits:"
    jq -r '"  Daily: $\(.budget.daily_limit_usd)\n  Session: $\(.budget.session_limit_usd)"' "$COST_DB"
    echo ""
    echo "Current Spending:"
    jq -r '"  Today: $\(.spending.today)\n  This Session: $\(.spending.this_session)\n  This Month: $\(.spending.this_month)"' "$COST_DB"
    echo ""
    echo "Per-Agent Spending:"
    jq -r '.agents | to_entries | .[] | "  \(.key): $\(.value)"' "$COST_DB"
}

case "${1:-}" in
    init) init_cost_tracking ;;
    record) record_spending "${2:-unknown}" "${3:-0.50}" ;;
    check) check_limits ;;
    report) spending_report ;;
    *) echo "Usage: $0 {init|record|check|report}" ;;
esac</code></pre>
      </div>

      <!-- Woven Summary 3: Enterprise Observability -->
      <div class="context-box" style="background: linear-gradient(135deg, #f0ebe3 0%, #fefcf3 100%); border-left: 4px solid #c49052; border-radius: 8px; padding: 1.5rem; margin: 2rem 0;">
        <h3>Deep Dive: Enterprise Observability Stack</h3>
        <p><strong>Source:</strong> <a href="../../synthesis/tooling-observability-guide.html">Tooling Observability Guide</a></p>
        <p>Enterprise agent deployments require comprehensive observability. The three pillars of agent observability are metrics (what's happening), logs (why it happened), and traces (how it flowed through agents).</p>

        <p><strong>Essential metrics for production agent systems:</strong></p>
        <table>
          <thead><tr><th>Metric</th><th>Type</th><th>Alert Threshold</th></tr></thead>
          <tbody>
            <tr><td>ralph_stories_complete</td><td>Gauge</td><td>0 increase over 3 iterations</td></tr>
            <tr><td>ralph_iterations_total</td><td>Counter</td><td>Exceeds MAX_ITERATIONS</td></tr>
            <tr><td>ralph_estimated_cost_usd</td><td>Gauge</td><td>Exceeds budget limit</td></tr>
            <tr><td>agent_context_utilization_percent</td><td>Gauge</td><td>Above 70%</td></tr>
            <tr><td>agent_error_rate</td><td>Counter</td><td>Above 5% of iterations</td></tr>
          </tbody>
        </table>

        <p><strong>Integration with standard observability tools:</strong></p>
        <ul>
          <li><strong>Prometheus:</strong> Scrape metrics endpoint on port 9100</li>
          <li><strong>Grafana:</strong> Dashboard templates for Ralph loops available</li>
          <li><strong>Datadog/NewRelic:</strong> Use custom metrics API for cost tracking</li>
          <li><strong>Slack/PagerDuty:</strong> Webhook alerts for stuck detection, cost overruns</li>
        </ul>

        <p><strong>Cost tracking integration pattern:</strong></p>
        <div class="code-block">
          <button class="copy-btn">Copy</button>
          <pre><code># Record cost per iteration in Ralph loop
./scripts/cost-tracking.sh record "ralph-main" "0.55"

# Check if approaching limits (integrates with LiteLLM)
./scripts/cost-tracking.sh check && echo "Within budget" || exit 3

# Generate cost report for team
./scripts/cost-tracking.sh report</code></pre>
        </div>
        <p><em>For complete observability setup including Grafana dashboards and alert configurations, see <a href="../../synthesis/tooling-observability-guide.html">Tooling Observability Guide</a>.</em></p>
      </div>

      <hr class="section-divider">

      <h3 id="monitoring">Monitoring Integration</h3>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code>#!/bin/bash
# agent-metrics.sh - Prometheus-style metrics for agent monitoring

METRICS_PORT=${METRICS_PORT:-9100}
METRICS_DIR=".agent-state/metrics"
mkdir -p "$METRICS_DIR"

write_metric() {
    local name="$1"
    local value="$2"
    local labels="${3:-}"
    local timestamp=$(date +%s%3N)

    if [ -n "$labels" ]; then
        echo "${name}{${labels}} ${value} ${timestamp}" >> "$METRICS_DIR/current.prom"
    else
        echo "${name} ${value} ${timestamp}" >> "$METRICS_DIR/current.prom"
    fi
}

collect_ralph_metrics() {
    local prd_file="${1:-plans/prd.json}"
    local metrics_file="${2:-plans/.metrics.json}"

    if [ -f "$prd_file" ]; then
        local total=$(jq '.userStories | length' "$prd_file")
        local complete=$(jq '[.userStories[] | select(.passes == true)] | length' "$prd_file")
        local pending=$(jq '[.userStories[] | select(.passes == false)] | length' "$prd_file")

        write_metric "ralph_stories_total" "$total"
        write_metric "ralph_stories_complete" "$complete"
        write_metric "ralph_stories_pending" "$pending"
    fi

    if [ -f "$metrics_file" ]; then
        local iterations=$(jq -r '.total_iterations // 0' "$metrics_file")
        local cost=$(jq -r '.estimated_cost_usd // 0' "$metrics_file")

        write_metric "ralph_iterations_total" "$iterations"
        write_metric "ralph_estimated_cost_usd" "$cost"
    fi
}

generate_metrics() {
    > "$METRICS_DIR/current.prom"
    echo "# HELP ralph_stories_total Total number of user stories" >> "$METRICS_DIR/current.prom"
    echo "# TYPE ralph_stories_total gauge" >> "$METRICS_DIR/current.prom"

    collect_ralph_metrics
    write_metric "agent_metrics_last_update" "$(date +%s)"
}

case "${1:-}" in
    serve)
        echo "Starting metrics server on port $METRICS_PORT"
        while true; do
            generate_metrics
            local response="HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\n\r\n$(cat "$METRICS_DIR/current.prom")"
            echo -e "$response" | nc -l -p $METRICS_PORT -q 1
        done
        ;;
    collect)
        generate_metrics
        cat "$METRICS_DIR/current.prom"
        ;;
    *)
        echo "Usage: $0 {serve|collect}"
        ;;
esac</code></pre>
      </div>

      <hr class="section-divider">

      <h2 id="checklists">Part 3: Implementation Checklists</h2>

      <h3 id="preflight">Pre-Flight Checklist</h3>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code>#!/bin/bash
# preflight-check.sh - Validate environment before autonomous work

echo "=== Claude Code Pre-Flight Checklist ==="
echo ""

ERRORS=0

echo "[ ] Git Repository"
if git rev-parse --git-dir > /dev/null 2>&1; then
    echo "    [x] In git repository"

    if git diff --quiet HEAD 2>/dev/null; then
        echo "    [x] Working directory clean"
    else
        echo "    [ ] WARNING: Uncommitted changes"
    fi

    BRANCH=$(git branch --show-current)
    if [ "$BRANCH" = "main" ] || [ "$BRANCH" = "master" ]; then
        echo "    [ ] WARNING: On main/master branch"
        ERRORS=$((ERRORS + 1))
    else
        echo "    [x] On feature branch: $BRANCH"
    fi
else
    echo "    [x] ERROR: Not in git repository"
    ERRORS=$((ERRORS + 1))
fi
echo ""

echo "[ ] Required Files"
for file in "CLAUDE.md" "plans/prd.json" "plans/prompt.md"; do
    if [ -f "$file" ]; then
        echo "    [x] $file exists"
    else
        echo "    [ ] MISSING: $file"
        ERRORS=$((ERRORS + 1))
    fi
done
echo ""

echo "[ ] PRD Validation"
if [ -f "plans/prd.json" ]; then
    if jq empty plans/prd.json 2>/dev/null; then
        echo "    [x] Valid JSON"
        PENDING=$(jq '[.userStories[] | select(.passes == false)] | length' plans/prd.json)
        TOTAL=$(jq '.userStories | length' plans/prd.json)
        echo "    [x] Stories: $PENDING pending of $TOTAL total"
    else
        echo "    [ ] ERROR: Invalid JSON in prd.json"
        ERRORS=$((ERRORS + 1))
    fi
fi
echo ""

echo "==================================="
if [ $ERRORS -eq 0 ]; then
    echo "PRE-FLIGHT: PASSED"
    exit 0
else
    echo "PRE-FLIGHT: FAILED ($ERRORS errors)"
    exit 1
fi</code></pre>
      </div>

      <h3 id="verification-checklist">Per-Iteration Verification Checklist</h3>

      <p>Include these checks in your prompt.md:</p>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code>## Verification Checklist (Every Iteration)

Before marking any story complete, verify ALL of the following:

### Code Quality
- [ ] `npm run typecheck` passes (zero errors)
- [ ] `npm run lint` passes (zero errors)
- [ ] No console.log statements left in production code
- [ ] No TODO comments without issue references

### Tests
- [ ] `npm run test` passes (all tests green)
- [ ] New code has test coverage if project has tests
- [ ] No skipped tests (`.skip()` or `xit()`)

### Git
- [ ] Changes are committed with descriptive message
- [ ] Commit message follows convention: `feat: [ID] - description`
- [ ] No untracked files that should be committed

### Acceptance Criteria
- [ ] ALL acceptance criteria from prd.json are met
- [ ] Behavior verified (not just assumed)

### If ANY check fails:
1. Do NOT mark story as `passes: true`
2. Document the failure in progress.txt
3. Either fix the issue or add notes explaining the blocker</code></pre>
      </div>

      <h3 id="cleanup">End-of-Run Cleanup Checklist</h3>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code>#!/bin/bash
# cleanup-check.sh - Post-run validation

echo "=== Post-Run Cleanup Checklist ==="
echo ""

echo "[ ] Git State"
git status --short
UNCOMMITTED=$(git status --porcelain | wc -l | tr -d ' ')
if [ "$UNCOMMITTED" -gt 0 ]; then
    echo "    WARNING: $UNCOMMITTED uncommitted changes"
fi
echo ""

echo "[ ] PRD Final State"
if [ -f "plans/prd.json" ]; then
    TOTAL=$(jq '.userStories | length' plans/prd.json)
    COMPLETE=$(jq '[.userStories[] | select(.passes == true)] | length' plans/prd.json)
    PENDING=$(jq '[.userStories[] | select(.passes == false)] | length' plans/prd.json)

    echo "    Total stories: $TOTAL"
    echo "    Complete: $COMPLETE"
    echo "    Pending: $PENDING"

    if [ "$PENDING" -gt 0 ]; then
        echo ""
        echo "    Incomplete stories:"
        jq -r '.userStories[] | select(.passes == false) | "    - \(.id): \(.title)"' plans/prd.json
    fi
fi
echo ""

echo "[ ] Progress Log"
if [ -f "plans/progress.txt" ]; then
    ENTRIES=$(grep -c "^## " plans/progress.txt 2>/dev/null || echo 0)
    echo "    Entries recorded: $ENTRIES"
fi
echo ""

echo "=== Cleanup Complete ==="</code></pre>
      </div>

      <h3 id="bmad-checklists">BMAD-METHOD Development Lifecycle Checklists</h3>

      <p>Source: <a href="https://github.com/bmad-code-org/BMAD-METHOD">bmad-code-org/BMAD-METHOD</a> - 19 specialized agents with document sharding</p>

      <p>BMAD-METHOD checklists provide structured verification at each development phase. These integrate with the 19 specialized agent roles.</p>

      <h4>BMAD Pre-Implementation Checklist</h4>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code>## BMAD Pre-Implementation Verification

### Story Readiness (BMAD Analyst Agent Role)
- [ ] Story has clear acceptance criteria
- [ ] Dependencies identified and resolved
- [ ] Affected files listed
- [ ] Estimated context budget allocated

### Context Sharding (BMAD Pattern)
- [ ] Story document contains ONLY relevant context
- [ ] No cross-cutting concerns mixed in
- [ ] Context size under 40% budget
- [ ] Progressive loading strategy defined

### BMAD Agent Assignment
- [ ] Primary agent role selected (19 options)
- [ ] Secondary validation agent assigned
- [ ] Model tier appropriate for task complexity</code></pre>
      </div>

      <h4>BMAD Post-Implementation Checklist</h4>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code>## BMAD Post-Implementation Verification

### Code Quality (BMAD Code Review Agent)
- [ ] Implementation matches acceptance criteria
- [ ] No scope creep beyond story boundaries
- [ ] Follows existing code patterns (CLAUDE.md)
- [ ] BMAD document shard updated with learnings

### Automated Verification
- [ ] npm run typecheck: PASS
- [ ] npm run test: PASS
- [ ] npm run lint: PASS (or documented exceptions)

### BMAD QA Agent Report
- [ ] .bmad/qa-results-{story}.json generated
- [ ] overall_status: "PASS"
- [ ] All verification_steps completed

### Documentation (BMAD Doc Agent)
- [ ] progress.txt appended with iteration results
- [ ] prd.json updated with passes: true
- [ ] Learnings captured for future iterations</code></pre>
      </div>

      <h3 id="litellm-checklist">LiteLLM Budget Verification Checklist</h3>

      <p>Source: <a href="https://github.com/BerriAI/litellm">BerriAI/litellm</a> - Budget-aware model routing</p>

      <h4>Pre-Session Budget Check</h4>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code>#!/bin/bash
# litellm-budget-check.sh - Verify budget before autonomous work

echo "=== LiteLLM Budget Pre-Flight ==="

# Check remaining budget
REMAINING=$(python3 -c "
from litellm import BudgetManager
bm = BudgetManager('claude-code-production')
print(bm.get_remaining_budget())
" 2>/dev/null || echo "ERROR")

if [ "$REMAINING" = "ERROR" ]; then
    echo "[ ] ERROR: LiteLLM not configured"
    exit 1
fi

echo "Remaining budget: \$$REMAINING"

# Budget thresholds
if (( $(echo "$REMAINING < 5" | bc -l) )); then
    echo "[ ] CRITICAL: Budget too low for autonomous work"
    echo "    Recommendation: Replenish budget or use manual mode"
    exit 1
elif (( $(echo "$REMAINING < 20" | bc -l) )); then
    echo "[!] WARNING: Low budget - will use Sonnet/Haiku only"
elif (( $(echo "$REMAINING < 50" | bc -l) )); then
    echo "[x] OK: Budget sufficient for moderate session"
else
    echo "[x] OK: Full budget available"
fi</code></pre>
      </div>

      <h4>LiteLLM Session Checklist</h4>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code>## LiteLLM Budget Verification

### Pre-Session
- [ ] LiteLLM configured: `~/.litellm/config.yaml` exists
- [ ] Budget remaining > $20 for autonomous work
- [ ] Fallback models configured
- [ ] Rate limit retry enabled

### During Session
- [ ] Model selection logged per iteration
- [ ] Cost tracked per task
- [ ] Budget warnings acknowledged
- [ ] No emergency downgrades (budget > $5)

### Post-Session
- [ ] Total cost recorded in metrics
- [ ] Budget report generated
- [ ] Cost per story calculated
- [ ] Alert threshold reviewed</code></pre>
      </div>

      <h3 id="swarms-checklist">Swarms Concurrent Execution Checklist</h3>

      <p>Source: <a href="https://github.com/kyegomez/swarms">kyegomez/swarms</a> - Concurrent agent execution</p>

      <h4>Swarms Pre-Execution Checklist</h4>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code>## Swarms Concurrent Setup

### Task Definition
- [ ] All tasks have unique task_id
- [ ] Dependencies explicitly declared
- [ ] No circular dependencies (DAG valid)
- [ ] Timeout appropriate for task complexity

### Resource Allocation
- [ ] max_workers <= available CPU cores
- [ ] Total concurrent cost within budget
- [ ] Model assignment per task type defined

### Swarms Configuration Verification
| Setting | Value | Verified |
|---------|-------|----------|
| max_parallel_tasks | 4 | [ ] |
| task_timeout_seconds | 300 | [ ] |
| retry_attempts | 3 | [ ] |</code></pre>
      </div>

      <h4>Swarms Post-Execution Checklist</h4>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code>## Swarms Results Verification

### Task Completion
- [ ] All tasks show status: "complete"
- [ ] No timeout failures
- [ ] Dependency order respected

### Cost Analysis
- [ ] Parallel execution saved time vs sequential
- [ ] Model routing optimized cost
- [ ] Total cost within budget

### Quality Verification
- [ ] Each task output reviewed
- [ ] Integration tests pass
- [ ] No merge conflicts between parallel tasks</code></pre>
      </div>

      <hr class="section-divider">

      <h2 id="templates">Part 4: Templates Collection</h2>

      <h3 id="dir-template">Directory Structure Template</h3>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code>project/
 CLAUDE.md                 # Project context (required)
 .claudeignore             # Files to exclude
 .claude/
    CONTEXT.md            # Auto-generated session context
    hooks.json            # Hook configuration
    skills/               # Custom skills
        my-skill.md
 plans/
    ralph.sh              # Loop script (executable)
    prompt.md             # Agent instructions
    prd.json              # Task tracking
    progress.txt          # Learning log
 .checkpoints/             # Recovery checkpoints
    chk-YYYYMMDD-HHMMSS.json
 src/                      # Your code</code></pre>
      </div>

      <h3 id="claudeignore-template">.claudeignore Template</h3>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code># Dependencies
node_modules/
vendor/
.venv/
__pycache__/

# Build outputs
dist/
build/
.next/
out/

# Secrets and credentials
.env
.env.*
*.pem
*.key
credentials.json
secrets/

# Large files
*.log
*.zip
*.tar.gz
coverage/

# IDE
.idea/
.vscode/settings.json
*.swp

# OS
.DS_Store
Thumbs.db</code></pre>
      </div>

      <h3 id="swarms-template">Swarms Task Definition Template</h3>

      <p>Source: <a href="https://github.com/kyegomez/swarms">kyegomez/swarms</a> - Concurrent agent execution</p>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code># swarms_tasks.yaml - Task definitions for concurrent Claude Code execution

tasks:
  # Phase 1: Independent tasks (run in parallel)
  - task_id: db-schema
    prompt_file: prompts/feature/db-schema.md
    model: claude-sonnet
    timeout_seconds: 300
    dependencies: []

  - task_id: api-types
    prompt_file: prompts/feature/api-types.md
    model: claude-sonnet
    timeout_seconds: 300
    dependencies: []

  - task_id: test-fixtures
    prompt_file: prompts/feature/test-fixtures.md
    model: claude-haiku  # Simple task, cheaper model
    timeout_seconds: 180
    dependencies: []

  # Phase 2: Dependent on Phase 1
  - task_id: api-routes
    prompt_file: prompts/feature/api-routes.md
    model: claude-sonnet
    timeout_seconds: 300
    dependencies:
      - db-schema
      - api-types

  - task_id: api-service
    prompt_file: prompts/feature/api-service.md
    model: claude-sonnet
    timeout_seconds: 300
    dependencies:
      - db-schema
      - api-types

  # Phase 3: Integration
  - task_id: integration
    prompt_file: prompts/feature/integration.md
    model: claude-opus  # Complex reasoning needed
    timeout_seconds: 600
    dependencies:
      - api-routes
      - api-service
      - test-fixtures

swarm_config:
  max_workers: 3
  retry_attempts: 2
  cost_tracking: true</code></pre>
      </div>

      <hr class="section-divider">

      <h2 id="quick-reference">Quick Reference</h2>

      <h3>Common Commands</h3>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code># Start Ralph loop
./plans/ralph.sh 25

# Check PRD status
jq '.userStories[] | select(.passes == false) | .title' plans/prd.json

# View recent progress
tail -50 plans/progress.txt

# Pre-flight check
./scripts/preflight-check.sh

# Post-run cleanup
./scripts/cleanup-check.sh

# LiteLLM budget check
python3 -c "from litellm import BudgetManager; bm = BudgetManager('claude-code-production'); print(f'\${bm.get_remaining_budget():.2f}')"

# BMAD QA verification
./scripts/bmad-qa-check.sh plans/prd.json US-001</code></pre>
      </div>

      <h3>Environment Variables</h3>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code># Add to ~/.bashrc or ~/.zshrc

# Claude Code
export ANTHROPIC_API_KEY="your-api-key-here"

# Mobile notifications
export POKE_WEBHOOK="https://poke.io/webhook/your-id"
export NTFY_TOPIC="your-topic"

# Cost limits
export CLAUDE_MAX_COST="25.00"
export CLAUDE_MAX_ITERATIONS="50"</code></pre>
      </div>

      <h3>LiteLLM Commands</h3>

      <p>Source: <a href="https://github.com/BerriAI/litellm">BerriAI/litellm</a></p>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code># Check remaining budget
python3 -c "from litellm import BudgetManager; bm = BudgetManager('claude-code-production'); print(f'\${bm.get_remaining_budget():.2f}')"

# View cost log
tail -20 ~/.litellm/costs.log

# Start LiteLLM proxy server (for team use)
litellm --config ~/.litellm/config.yaml --port 4000

# Test LiteLLM routing
curl -X POST http://localhost:4000/chat/completions \
  -H "Content-Type: application/json" \
  -d '{"model": "claude-sonnet", "messages": [{"role": "user", "content": "test"}]}'

# Reset daily budget
python3 -c "from litellm import BudgetManager; BudgetManager('claude-code-production').reset_budget()"</code></pre>
      </div>

      <h3>BMAD-METHOD Commands</h3>

      <p>Source: <a href="https://github.com/bmad-code-org/BMAD-METHOD">bmad-code-org/BMAD-METHOD</a></p>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code># Run BMAD QA verification for a story
./scripts/bmad-qa-check.sh plans/prd.json US-001

# View BMAD QA results
cat .bmad/qa-results-US-001.json | jq .

# Check all BMAD results
for f in .bmad/qa-results-*.json; do
  echo "=== $f ==="
  jq '.overall_status' "$f"
done

# List stories by BMAD agent assignment
jq -r '.userStories[] | "\(.id): \(.bmad_agent // "unassigned")"' plans/prd.json</code></pre>
      </div>

      <h3>Swarms Commands</h3>

      <p>Source: <a href="https://github.com/kyegomez/swarms">kyegomez/swarms</a></p>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code># Run Swarms concurrent execution
python3 scripts/swarms_runner.py .swarms/tasks.yaml

# Check Swarms execution status
jq '.tasks[] | {task_id, status}' .swarms/execution-log.json

# View parallel execution time savings
jq '.summary.parallel_time_minutes, .summary.sequential_time_minutes' .swarms/execution-log.json

# Validate Swarms DAG (no circular dependencies)
python3 -c "
import yaml
tasks = yaml.safe_load(open('.swarms/tasks.yaml'))['tasks']
# Check for cycles
visited = set()
for t in tasks:
    if t['task_id'] in [d for d in t.get('dependencies', [])]:
        print(f'CIRCULAR: {t[\"task_id\"]}')
print('DAG validation complete')
"</code></pre>
      </div>

      <h3>Implementation Invariants Summary</h3>

      <table>
        <thead>
          <tr>
            <th>Invariant</th>
            <th>Implementation</th>
          </tr>
        </thead>
        <tbody>
          <tr><td>Fresh context beats extended</td><td>Never use <code>--continue</code> in loops</td></tr>
          <tr><td>60% context ceiling</td><td>Monitor and compact proactively</td></tr>
          <tr><td>External state &gt; internal memory</td><td>prd.json + progress.txt + git</td></tr>
          <tr><td>Atomic writes always</td><td>temp-file-then-rename pattern</td></tr>
          <tr><td>Append-only learning</td><td>NEVER edit progress.txt</td></tr>
          <tr><td>Explicit termination</td><td><code>&lt;promise&gt;COMPLETE&lt;/promise&gt;</code> + max iterations</td></tr>
          <tr><td>Workers don't spawn</td><td>Preamble prohibition enforced</td></tr>
          <tr><td>Verification before completion</td><td>Tests + typecheck in every criteria</td></tr>
          <tr><td>Dual-condition exit</td><td>EXIT_SIGNAL + completion_indicators &gt;= 2</td></tr>
          <tr><td>Cost tracking</td><td>Budget limits with automatic shutdown</td></tr>
        </tbody>
      </table>

      <h3>Enterprise Directory Structure</h3>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code>project/
 CLAUDE.md                     # Project context
 .claudeignore                 # Files to exclude
 .claude/
    CONTEXT.md                # Auto-generated
    hooks.json                # Hook configuration
    skills/
 plans/
    ralph.sh                  # Main loop script
    prompt.md                 # Agent instructions
    prd.json                  # Task tracking
    progress.txt              # Learning log
 .bmad/                        # BMAD-METHOD artifacts
    qa-results-US-001.json
    agent-assignments.yaml
 .litellm/                     # LiteLLM configuration
    config.yaml
    costs.log
 .swarms/                      # Swarms configuration
    tasks.yaml
    execution-log.json
 prompts/                      # Swarms task prompts
    feature/
 .checkpoints/                 # Recovery checkpoints
 src/                          # Your code</code></pre>
      </div>

      <hr class="section-divider">

      <h2 id="final-checkpoint">Final Checkpoint</h2>

      <div class="checkpoint">
        <div class="checkpoint-header">You're Ready If:</div>
        <div class="checkpoint-content">
          <ul>
            <li><strong>Context Management:</strong> You can explain the 60% rule and run FIC workflows</li>
            <li><strong>State Management:</strong> prd.json, progress.txt, and checkpoints are set up</li>
            <li><strong>Ralph Loop:</strong> Production ralph.sh is configured with proper exit detection</li>
            <li><strong>Hooks:</strong> Safety hooks (destructive, secrets) are active</li>
            <li><strong>Checklists:</strong> Pre-flight, per-iteration, and cleanup scripts are ready</li>
            <li><strong>Enterprise:</strong> LiteLLM budget controls configured (if applicable)</li>
          </ul>
        </div>
      </div>

      <h3>Quick Verification</h3>

      <p>Run this to verify your setup:</p>

      <div class="code-block">
        <button class="copy-btn">Copy</button>
        <pre><code># Run preflight
./scripts/preflight-check.sh

# Start Ralph (test with 3 iterations)
./plans/ralph.sh 3

# Check cleanup
./scripts/cleanup-check.sh</code></pre>
      </div>

      <h3>Where to Go Next</h3>

      <table>
        <thead>
          <tr>
            <th>Your Situation</th>
            <th>Next Journey</th>
          </tr>
        </thead>
        <tbody>
          <tr><td>Need to choose patterns before building</td><td><a href="../architecture/decision-framework.html">Choosing Your Architecture</a></td></tr>
          <tr><td>Ready to run what you built</td><td><a href="../operations/monitoring-cost.html">Running Production Claude</a></td></tr>
          <tr><td>Want to understand WHY these patterns work</td><td><a href="../mental-models/core-models.html">Thinking Like Staff Engineers</a></td></tr>
        </tbody>
      </table>

      <hr class="section-divider">

      <h2 id="deeper">Want to Go Deeper?</h2>

      <table>
        <thead>
          <tr>
            <th>Topic</th>
            <th>Depth Layer</th>
            <th>Link</th>
          </tr>
        </thead>
        <tbody>
          <tr><td>Ralph Variants</td><td>Ecosystem Analysis</td><td><a href="../../synthesis/ralph-ecosystem-complete.html">Ralph Ecosystem Complete</a></td></tr>
          <tr><td>CC Mirror Multi-Agent</td><td>Implementation Details</td><td><a href="../../synthesis/multi-agent-cc-mirror-complete.html">CC Mirror Complete</a></td></tr>
          <tr><td>Boris Vanilla Philosophy</td><td>Creator Workflow</td><td><a href="../../synthesis/boris-workflow-complete.html">Boris Workflow Complete</a></td></tr>
          <tr><td>Advanced Context</td><td>Techniques Deep Dive</td><td><a href="../../synthesis/technical-context-management-advanced.html">Technical Context Management</a></td></tr>
          <tr><td>Subagent Patterns</td><td>Spawning Best Practices</td><td><a href="../../synthesis/technical-subagent-spawning-best-practices.html">Subagent Best Practices</a></td></tr>
          <tr><td>Cost Economics</td><td>Cost Analysis</td><td><a href="../../synthesis/reference-cost-economics.html">Reference Cost Economics</a></td></tr>
        </tbody>
      </table>

      <hr class="section-divider">

      <h2 id="known-gaps">Known Gaps</h2>

      <p>The following topics are <strong>not fully covered</strong> in this implementation guide:</p>

      <table>
        <thead>
          <tr>
            <th>Gap</th>
            <th>Status</th>
            <th>Where to Find</th>
          </tr>
        </thead>
        <tbody>
          <tr><td><strong>MCP Ecosystem</strong></td><td>Not in D-FINAL</td><td>See extraction files and official MCP docs</td></tr>
          <tr><td><strong>Mobile Workflows</strong></td><td>Partial</td><td><a href="../../synthesis/frontier-mobile.html">frontier-mobile.html</a></td></tr>
          <tr><td><strong>Personal Panopticon</strong></td><td>Brief mention</td><td><a href="../../extractions/orchestration/001-personal-panopticon-mollycantillon.html">001-personal-panopticon-mollycantillon.html</a></td></tr>
          <tr><td><strong>Non-Code Ralph (Marketing)</strong></td><td>Not covered</td><td><a href="../../extractions/orchestration/003-ralph-wiggum-marketer-koylanai.html">003-ralph-wiggum-marketer-koylanai.html</a></td></tr>
          <tr><td><strong>Skills Framework</strong></td><td>Partial</td><td>See skills extraction files</td></tr>
          <tr><td><strong>ReasoningBank/Swarm Memory</strong></td><td>Partial</td><td><a href="../../extractions/deep/reuven-claude-flow-extraction.html">reuven-claude-flow-extraction.html</a></td></tr>
        </tbody>
      </table>

      <p><strong>Source note:</strong> This implementation guide incorporates validated patterns from 47 production repos and 10+ Ralph variants.</p>

      <!-- Footer navigation -->
      <div class="footer-nav">
        <a href="ralph-production.html" class="nav-prev">
          <span class="nav-direction">Previous</span>
          <span class="nav-title">Ralph Production</span>
        </a>
        <a href="../operations/monitoring-cost.html" class="nav-next">
          <span class="nav-direction">Next</span>
          <span class="nav-title">Monitoring & Cost</span>
        </a>
      </div>

    </main>
  </div>

  <!-- Mobile toggle button -->
  <button class="sidebar-toggle" aria-label="Open navigation">&#9776;</button>

  <script src="../../js/sidebar.js"></script>
</body>
</html>
