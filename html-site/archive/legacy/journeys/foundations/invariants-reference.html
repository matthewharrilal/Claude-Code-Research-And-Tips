<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta data-pagefind-meta="chapter" content="Journeys">
  <meta data-pagefind-meta="section" content="Foundations">
  <title>Invariants Reference - Claude Code Knowledge Base</title>
  <link rel="stylesheet" href="../../css/style.css">
  <link rel="stylesheet" href="../../css/sidebar.css">
</head>
<body>
  <div class="page-with-sidebar">
    <!-- Sidebar Navigation -->
    <nav class="sidebar">
      <button class="sidebar-close" aria-label="Close sidebar">&times;</button>
      <div class="sidebar-header">
        <h2 class="sidebar-title"><a href="../../index.html">Claude Code KB</a></h2>
      </div>
      <ul class="sidebar-nav">
        <li class="nav-section">
          <div class="nav-section-title">Start Here</div>
          <ul class="nav-subsections">
            <li class="nav-page"><a href="../../start-here/index.html">Overview</a></li>
            <li class="nav-page"><a href="../../start-here/master-playbook.html">Master Playbook</a></li>
            <li class="nav-page"><a href="../../start-here/judgment-guide.html">Judgment Guide</a></li>
          </ul>
        </li>
        <li class="nav-section">
          <div class="nav-section-title">Foundations</div>
          <ul class="nav-subsections">
            <li class="nav-page"><a href="../../foundations/index.html">Overview</a></li>
            <li class="nav-page"><a href="../../foundations/principles/core.html">Core Principles</a></li>
            <li class="nav-page"><a href="../../foundations/architecture/complexity-ladder.html">Complexity Ladder</a></li>
          </ul>
        </li>
        <li class="nav-section">
          <div class="nav-section-title">Mental Models Journey</div>
          <ul class="nav-subsections">
            <li class="nav-page"><a href="../mental-models/index.html">Overview</a></li>
            <li class="nav-page"><a href="../mental-models/core-models.html">Core Models (1-10)</a></li>
            <li class="nav-page"><a href="../mental-models/advanced-models.html">Advanced Models (11-16)</a></li>
            <li class="nav-page"><a href="../mental-models/practice-heuristics.html">Practice &amp; Heuristics</a></li>
          </ul>
        </li>
        <li class="nav-section">
          <div class="nav-section-title">Architecture Journey</div>
          <ul class="nav-subsections">
            <li class="nav-page"><a href="../architecture/index.html">Overview</a></li>
            <li class="nav-page"><a href="../architecture/decision-framework.html">Decision Framework</a></li>
            <li class="nav-page"><a href="../architecture/core-patterns.html">Core Patterns</a></li>
            <li class="nav-page"><a href="../architecture/enterprise-swarm.html">Enterprise &amp; Swarm</a></li>
            <li class="nav-page"><a href="../architecture/context-composition.html">Context &amp; Composition</a></li>
          </ul>
        </li>
        <li class="nav-section">
          <div class="nav-section-title">Implementation Journey</div>
          <ul class="nav-subsections">
            <li class="nav-page"><a href="../implementation/index.html">Overview</a></li>
            <li class="nav-page"><a href="../implementation/context-state.html">Context &amp; State</a></li>
            <li class="nav-page"><a href="../implementation/ralph-production.html">Ralph Production</a></li>
            <li class="nav-page"><a href="../implementation/hooks-enterprise.html">Hooks &amp; Enterprise</a></li>
          </ul>
        </li>
        <li class="nav-section">
          <div class="nav-section-title">Operations Journey</div>
          <ul class="nav-subsections">
            <li class="nav-page"><a href="../operations/index.html">Overview</a></li>
            <li class="nav-page"><a href="../operations/monitoring-cost.html">Monitoring &amp; Cost</a></li>
            <li class="nav-page"><a href="../operations/security-checklists.html">Security &amp; Checklists</a></li>
            <li class="nav-page"><a href="../operations/incident-response.html">Incident Response</a></li>
          </ul>
        </li>
        <li class="nav-section open">
          <div class="nav-section-title">Reference</div>
          <ul class="nav-subsections">
            <li class="nav-page current"><a href="../foundations/invariants-reference.html">Invariants Reference</a></li>
            <li class="nav-page"><a href="../../reference/index.html">Full Reference</a></li>
            <li class="nav-page"><a href="../../reference/cost-analysis.html">Cost Analysis</a></li>
          </ul>
        </li>
      </ul>
    </nav>

    <!-- Main Content -->
    <main class="main-content">
      <div class="breadcrumb">
        <a href="../../index.html">Home</a>
        <span class="breadcrumb-separator">/</span>
        <a href="../index.html">Journeys</a>
        <span class="breadcrumb-separator">/</span>
        <a href="index.html">Foundations</a>
        <span class="breadcrumb-separator">/</span>
        <span class="breadcrumb-current">Invariants Reference</span>
      </div>

      <div class="page-meta">
        <span class="page-meta-item">27 min read</span>
        <span class="page-meta-item">~800 lines</span>
      </div>

      <h1>Invariants Reference</h1>

      <div class="context-box you-are-here">
        <h3>You Are Here</h3>
        <p><strong>What this covers:</strong> The 11 invariants that appeared in EVERY practitioner studied. These are non-negotiable truths that do not change with context.</p>
        <p><strong>Key insight:</strong> Every architecture pattern that succeeds respects these invariants; every pattern that fails violates at least one.</p>
        <p><strong>Where this fits:</strong></p>
        <pre class="ascii-diagram">FOUNDATIONS
    |
    +-- Core Principles
    |
    +-- Complexity Ladder
    |
    +-- **YOU ARE HERE: Invariants Reference**</pre>
      </div>

      <p class="lead">These patterns appeared in EVERY practitioner studied, regardless of use case, scale, or personal style. 100% agreement across 47 repositories and 20+ practitioners.</p>

      <p>Invariants are non-negotiable truths. They do not change with context. Every architecture pattern that succeeds respects them; every pattern that fails violates at least one.</p>

      <div class="toc">
        <div class="toc-title">On This Page</div>
        <ul>
          <li><a href="#eleven-invariants">The 11 Invariants</a></li>
          <li><a href="#philosophy-validation">How Philosophy Repos Validate These</a></li>
          <li><a href="#quick-reference">Quick Reference Tables</a></li>
          <li><a href="#scenarios">Scenario Practice</a></li>
        </ul>
      </div>

      <hr class="section-divider">

      <!-- The 11 Invariants -->
      <section id="eleven-invariants">
        <h2>The 11 Invariants</h2>

        <h3>Invariant 1: Context Is The Constraint</h3>
        <p>Every practitioner designs around context limits. No one tries to fight them. All architecture decisions flow from accepting this constraint.</p>
        <p><strong>Evidence:</strong></p>
        <ul>
          <li>Boris Cherny: "Use Plan mode to think before acting"</li>
          <li>Steve Yegge: "20-30 short sessions, not one long one"</li>
          <li>Ralph Pattern: "Fresh context per iteration"</li>
          <li>Molly Cantillon: "8 separate domains, isolated contexts"</li>
          <li>All 47 repos: No extended context as primary mode</li>
        </ul>
        <p><strong>Universal Truth:</strong> No one has found a way to make extended context work reliably.</p>

        <h3>Invariant 2: Fresh Beats Extended</h3>
        <p>No practitioner uses long sessions as their primary mode. All prefer multiple short iterations with fresh context. This applies regardless of whether they use Ralph loops, parallel swarms, or manual sessions.</p>

        <h3>Invariant 3: External Memory Required</h3>
        <p>Files, databases, git - the specific mechanism varies, but the pattern is universal. All persistent state lives outside the agent. "In memory" does not count. "In context" does not count.</p>

        <h3>Invariant 4: Verification Non-Negotiable</h3>
        <p>No practitioner trusts "it compiles" as "it works." All have verification gates. Tests, typechecks, linting - the specific gates vary, but the requirement for programmatic verification is universal.</p>

        <h3>Invariant 5: Parallelization Essential</h3>
        <p>All practitioners who work at scale run multiple agents. No one achieves high throughput with a single agent. The numbers vary (5-100+), but the pattern is consistent.</p>

        <h3>Invariant 6: Git As Recovery</h3>
        <p>All practitioners use git commits as checkpoints for recovery. Not as version control for humans, but as state recovery for agents. "Git worktrees for parallel" is a near-universal pattern.</p>

        <h3>Invariant 7: Simplicity Bias</h3>
        <p>Every practitioner warns against over-engineering. Every war story involves complexity failing. The most productive practitioners use the simplest tools that work.</p>

        <h3>Invariant 8: Human Judgment Irreplaceable</h3>
        <p>Machines are excellent at HOW. Humans are essential for WHY and WHETHER. No practitioner has removed humans from judgment calls, architectural decisions, or exception handling.</p>

        <h3>Invariant 9: Learnings Must Persist</h3>
        <p>Institutional memory only grows through deliberate compounding. CLAUDE.md updates, progress.txt archives, learning repositories - the mechanism varies, but the principle is universal.</p>

        <h3>Invariant 10: Budget Enforcement at Scale</h3>
        <p>When running 10+ agents, you MUST configure budget controls: global caps, per-agent limits, real-time monitoring, and auto-pause on threshold breach.</p>
        <p><strong>Evidence:</strong></p>
        <ul>
          <li>LiteLLM for cost tracking at enterprise scale</li>
          <li>Alerting at 50%, 75%, 90% thresholds</li>
          <li>Pre-call budget checks before API calls</li>
        </ul>
        <p><strong>Violation Effect:</strong> Runaway costs ($1000+ in hours), agent storms (agents spawning agents), budget exhaustion mid-task.</p>
        <p><strong>Enforcement:</strong> LiteLLM proxy for cost tracking. Pre-call budget check. Alerting at thresholds.</p>

        <h3>Invariant 11: Validate Before Sharing (SONA Systems)</h3>
        <p>When an agent learns a pattern, it must: have a success metric, be validated on 3+ instances, not contradict existing knowledge, and have rollback capability.</p>
        <p><strong>Evidence:</strong></p>
        <ul>
          <li>ReasoningBank with minimum reward score thresholds</li>
          <li>Cross-validation before committing to shared knowledge</li>
          <li>Versioned pattern storage with rollback</li>
        </ul>
        <p><strong>Violation Effect:</strong> Bad patterns propagate to all agents, system quality degrades over time, no way to recover (bad knowledge is persistent).</p>
        <p><strong>Enforcement:</strong> Minimum reward score threshold. Cross-validation before commit. Versioned storage.</p>
      </section>

      <hr class="section-divider">

      <!-- Philosophy Validation -->
      <section id="philosophy-validation">
        <h2>How Philosophy Repos Validate These Invariants</h2>

        <p>The major philosophy repos do not just follow these invariants - they codify them as explicit principles.</p>

        <h3>HumanLayer's 12-Factor Agents: Invariants as Factors</h3>
        <p>The 12-Factor Agents framework explicitly encodes all 9 invariants:</p>
        <table>
          <thead>
            <tr>
              <th>Invariant</th>
              <th>12-Factor Equivalent</th>
              <th>Factor Number</th>
            </tr>
          </thead>
          <tbody>
            <tr><td>Context Is Constraint</td><td>"Own your context window"</td><td>Factor 3</td></tr>
            <tr><td>Fresh Beats Extended</td><td>"Stateless reducer" pattern</td><td>Factor 12</td></tr>
            <tr><td>External Memory Required</td><td>"Unify execution &amp; business state"</td><td>Factor 5</td></tr>
            <tr><td>Verification Non-Negotiable</td><td>"Tools are structured outputs"</td><td>Factor 4</td></tr>
            <tr><td>Parallelization Essential</td><td>"Small, focused agents"</td><td>Factor 10</td></tr>
            <tr><td>Git As Recovery</td><td>"Launch/Pause/Resume APIs"</td><td>Factor 6</td></tr>
            <tr><td>Simplicity Bias</td><td>"Own your control flow"</td><td>Factor 8</td></tr>
            <tr><td>Human Judgment Irreplaceable</td><td>"Contact humans with tools"</td><td>Factor 7</td></tr>
            <tr><td>Learnings Must Persist</td><td>"Own your prompts" (evolving)</td><td>Factor 2</td></tr>
          </tbody>
        </table>
        <p><strong>Why This Mapping Matters:</strong> When you see a 12-Factor recommendation, you are seeing a universal invariant in disguise. The framework does not invent new principles - it codifies what practitioners discovered independently.</p>
        <p><strong>The Anti-Framework Invariant:</strong> 12-Factor explicitly warns against LangChain, CrewAI, and similar abstractions because they violate multiple invariants - hiding context management, abstracting control flow, and adding complexity.</p>

        <h3>BMAD-METHOD: Invariants as Compliance Requirements</h3>
        <p>BMAD transforms invariants into auditable processes:</p>
        <p><strong>Context as Compliance:</strong> BMAD's "zero context loss guarantee" via story files is not just good practice - it is an audit requirement. Every decision must be traceable to documented context.</p>
        <p><strong>Verification as QA Philosophy:</strong> The 21-agent QA loop embodies "Verification Non-Negotiable" at scale. It is not one verification step - it is verification as the dominant activity.</p>
        <p><strong>Parallelization as Architecture:</strong> 19+ specialized agents is not a choice - it is the only way to achieve BMAD's quality guarantees. Monolithic agents cannot satisfy the compliance requirements.</p>
        <p><strong>Checklist-Driven Invariant Enforcement:</strong></p>
        <ul>
          <li>Is state externalized? (Invariant 3)</li>
          <li>Is the task atomic? (Invariant 1)</li>
          <li>Is verification programmatic? (Invariant 4)</li>
          <li>Is complexity justified? (Invariant 7)</li>
        </ul>

        <h3>Aider: Invariants Through Separation</h3>
        <p>Aider's dual-model approach enforces invariants structurally:</p>
        <p><strong>Architect vs Editor = Role-Based Invariant Enforcement:</strong></p>
        <ul>
          <li>Architect handles WHY and WHETHER (Invariant 8)</li>
          <li>Editor handles HOW (implementation)</li>
          <li>Neither can violate the other's domain</li>
        </ul>
        <p><strong>Separation Enforces Fresh Context:</strong> By making Architect and Editor separate, aider makes fresh context between phases automatic. You cannot accidentally extend - the models change.</p>
        <p><strong>Disposability = External State Requirement:</strong> If sessions are disposable (which aider assumes), all valuable state MUST be external. The architecture forces Invariant 3.</p>

        <h3>BMAD-METHOD Alignment Table</h3>
        <table>
          <thead>
            <tr>
              <th>Invariant</th>
              <th>BMAD Pattern</th>
              <th>How BMAD Enforces It</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>Context Is Primary Constraint</strong></td>
              <td>Scale-Adaptive Levels</td>
              <td>Level 0-4 adjusts planning depth to prevent overflow</td>
            </tr>
            <tr>
              <td><strong>External State Over Internal Memory</strong></td>
              <td>Document-Driven Development</td>
              <td>Markdown specs as "executable context"</td>
            </tr>
            <tr>
              <td><strong>Atomic Verifiable Tasks</strong></td>
              <td>Hyper-Detailed Story Files</td>
              <td>Each story is 2-3 sentences with acceptance criteria</td>
            </tr>
            <tr>
              <td><strong>Quality Gates Before Commit</strong></td>
              <td>21-Agent QA Layer</td>
              <td>QA (Quinn), TEA (Test Architect), Security Auditor</td>
            </tr>
            <tr>
              <td><strong>Phase Boundaries Must Compact</strong></td>
              <td>Scrum Master Role</td>
              <td>Creates compacted story files at phase boundaries</td>
            </tr>
            <tr>
              <td><strong>Budget Enforcement at Scale</strong></td>
              <td>Control Manifest</td>
              <td>Versioned guardrails before AI coding</td>
            </tr>
          </tbody>
        </table>
        <p><strong>BMAD-METHOD 21-Agent QA Layer:</strong></p>
        <div class="code-block">
          <button class="copy-btn">Copy</button>
          <pre>VALIDATION AGENTS:
+-- QA (Quinn): PRD validation, code review, test fixtures
+-- TEA (Test Enterprise Architect): Test strategy, automation setup
+-- Security Auditor: Threat modeling, security review
+-- Tech Writer: Documentation validation

RESULT: Every phase has specialized oversight</pre>
        </div>

        <h3>aider Alignment Table</h3>
        <table>
          <thead>
            <tr>
              <th>Invariant</th>
              <th>aider Pattern</th>
              <th>Evidence</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>Separation of Concerns</strong></td>
              <td>Architect/Editor Split</td>
              <td>Reasoning and editing in separate models</td>
            </tr>
            <tr>
              <td><strong>Context Is Primary Constraint</strong></td>
              <td>Repository Map</td>
              <td>Tree-sitter AST reduces context to 1,000 tokens</td>
            </tr>
            <tr>
              <td><strong>Quality Gates Before Commit</strong></td>
              <td>Automatic Git Commits</td>
              <td>Only commits after successful edits</td>
            </tr>
            <tr>
              <td><strong>Fresh Context Beats Extended</strong></td>
              <td>udiff Format</td>
              <td>3x reduction in lazy coding</td>
            </tr>
          </tbody>
        </table>
        <p><strong>aider's Invariant Enforcement:</strong></p>
        <div class="code-block">
          <button class="copy-btn">Copy</button>
          <pre># aider enforces Invariant 4 (Separation) automatically
aider --architect  # Architect phase: o1/Opus reasons
                   # Editor phase: DeepSeek/Sonnet implements

# aider enforces Invariant 6 (Quality Gates)
# Commits only after successful edit application</pre>
        </div>
      </section>

      <hr class="section-divider">

      <!-- Quick Reference -->
      <section id="quick-reference">
        <h2>Quick Reference Tables</h2>

        <h3>Invariant Summary Card</h3>
        <table>
          <thead>
            <tr>
              <th>#</th>
              <th>Invariant</th>
              <th>One-Sentence Summary</th>
            </tr>
          </thead>
          <tbody>
            <tr><td>1</td><td>Context Is Constraint</td><td>Design around context limits, never fight them</td></tr>
            <tr><td>2</td><td>Fresh Beats Extended</td><td>Multiple short sessions beat one long session</td></tr>
            <tr><td>3</td><td>External Memory Required</td><td>If it is not in a file, it does not exist</td></tr>
            <tr><td>4</td><td>Verification Non-Negotiable</td><td>Programmatic tests define "done"</td></tr>
            <tr><td>5</td><td>Parallelization Essential</td><td>Scale by adding agents, not optimizing one</td></tr>
            <tr><td>6</td><td>Git As Recovery</td><td>Commits are checkpoints for agent recovery</td></tr>
            <tr><td>7</td><td>Simplicity Bias</td><td>The simplest solution that works is best</td></tr>
            <tr><td>8</td><td>Human Judgment Irreplaceable</td><td>Machines do HOW; humans decide WHY and WHETHER</td></tr>
            <tr><td>9</td><td>Learnings Must Persist</td><td>Document mistakes so agents never repeat them</td></tr>
            <tr><td>10</td><td>Budget Enforcement at Scale</td><td>Configure cost controls before running 10+ agents</td></tr>
            <tr><td>11</td><td>Validate Before Sharing</td><td>Verify patterns work before propagating to swarm</td></tr>
          </tbody>
        </table>

        <h3>Invariant Violation Quick Check</h3>
        <table>
          <thead>
            <tr>
              <th>Symptom</th>
              <th>Likely Violated Invariant</th>
              <th>Quick Fix</th>
            </tr>
          </thead>
          <tbody>
            <tr><td>Quality degrades over time</td><td>#1, #2</td><td>Reset context, use fresh sessions</td></tr>
            <tr><td>Same mistakes repeat</td><td>#9</td><td>Document to CLAUDE.md</td></tr>
            <tr><td>Progress lost between sessions</td><td>#3</td><td>Externalize state to files</td></tr>
            <tr><td>"Done" but does not work</td><td>#4</td><td>Add programmatic verification</td></tr>
            <tr><td>Cannot scale throughput</td><td>#5</td><td>Add parallel agents</td></tr>
            <tr><td>Cannot recover from failures</td><td>#6</td><td>Commit checkpoints</td></tr>
            <tr><td>System too complex to debug</td><td>#7</td><td>Simplify architecture</td></tr>
            <tr><td>Wrong architectural decisions</td><td>#8</td><td>Add human judgment step</td></tr>
            <tr><td>Surprise API bills ($1000+ overnight)</td><td>#10</td><td>Deploy LiteLLM with budget caps</td></tr>
            <tr><td>Swarm quality degrades over time</td><td>#11</td><td>Increase minRewardScore threshold</td></tr>
          </tbody>
        </table>

        <h3>Mental Model to Invariant Mapping</h3>
        <table>
          <thead>
            <tr>
              <th>Mental Model</th>
              <th>Primary Invariant</th>
              <th>Secondary</th>
            </tr>
          </thead>
          <tbody>
            <tr><td>1: Context-First Paradigm</td><td>#1</td><td>#2</td></tr>
            <tr><td>2: External State</td><td>#3</td><td>#6</td></tr>
            <tr><td>3: Fresh Context</td><td>#2</td><td>#1</td></tr>
            <tr><td>4: Verification as Trust</td><td>#4</td><td>-</td></tr>
            <tr><td>5: Parallelization</td><td>#5</td><td>#7</td></tr>
            <tr><td>6: Human Orchestrator</td><td>#8</td><td>-</td></tr>
            <tr><td>7: Atomic Tasks</td><td>#1</td><td>#4</td></tr>
            <tr><td>8: Model Tiering</td><td>#7</td><td>#5</td></tr>
            <tr><td>9: Compounding</td><td>#9</td><td>#3</td></tr>
            <tr><td>10: Simplicity</td><td>#7</td><td>-</td></tr>
          </tbody>
        </table>

        <h3>Scale Tier Infrastructure Requirements</h3>
        <table>
          <thead>
            <tr>
              <th>Tier</th>
              <th>Agents</th>
              <th>Required Invariant Enforcement</th>
            </tr>
          </thead>
          <tbody>
            <tr><td>Solo</td><td>1-2</td><td>Basic: CLAUDE.md, git commits, manual verification</td></tr>
            <tr><td>Ralph</td><td>1-10 iter</td><td>Loop: progress.txt, automated verification, bounded iterations</td></tr>
            <tr><td>Team</td><td>3-10</td><td>Coordination: claims files, worktrees, hub orchestration</td></tr>
            <tr><td>Enterprise</td><td>10-50</td><td>Platform: observability, cost control, multi-validator</td></tr>
            <tr><td>Factory</td><td>50+</td><td>Full: LiteLLM proxy, ReasoningBank, Queen/Worker hierarchy</td></tr>
          </tbody>
        </table>

        <h3>The Complexity Ladder Quick Reference</h3>
        <div class="ascii-diagram">
Level   Scale      Pattern              Unlock Condition
------------------------------------------------------------
  0     Manual     No Agent             Baseline
  1     1 session  Single Session       Claude installed
  2     1 loop     Ralph Loop           Autonomous works for you
  3     2-5 loops  Parallel Ralph       Master single Ralph
  4     3-10       Claude Squad         Need parallelism + judgment
  5     5-10       CC Mirror            Learn task decomposition
  6     10-20      CC Mirror+           Need specialized reviewers
  7     20-30+     Gas Town             $150+/day budget, Stage 6 mastery
  8     30-100     SONA Swarm           Need cross-agent learning
  9     100+       Enterprise           SOC 2 requirement, $500+/day
        </div>

        <h3>Exit Detection Quick Reference</h3>
        <table>
          <thead>
            <tr>
              <th>Situation</th>
              <th>Strategy</th>
              <th>Implementation</th>
            </tr>
          </thead>
          <tbody>
            <tr><td>Learning/simple tasks</td><td>Simple grep</td><td><code>grep -q "&lt;promise&gt;COMPLETE&lt;/promise&gt;"</code></td></tr>
            <tr><td>Production/long-running</td><td>Dual-condition gate</td><td>Heuristic count + explicit confirmation</td></tr>
            <tr><td>Security-critical</td><td>Validator consensus</td><td>All validators must approve</td></tr>
          </tbody>
        </table>

        <h3>Model Selection Quick Reference</h3>
        <table>
          <thead>
            <tr>
              <th>Task Type</th>
              <th>Model</th>
              <th>Cost Ratio</th>
            </tr>
          </thead>
          <tbody>
            <tr><td>File fetches, searches</td><td>Haiku</td><td>1x</td></tr>
            <tr><td>Standard implementation</td><td>Sonnet</td><td>12x</td></tr>
            <tr><td>Architecture, debugging</td><td>Opus</td><td>60x</td></tr>
          </tbody>
        </table>

        <h3>Cost Optimization Decision Flow</h3>
        <div class="ascii-diagram">
Is operation deterministic?
  YES -> LLM Bypass (85% savings)
  NO  v

Is query cached?
  YES -> Return cache (250% extension)
  NO  v

Select model:
  Lookup -> Haiku (1x)
  Implement -> Sonnet (12x)
  Reason -> Opus (60x)
        </div>
      </section>

      <hr class="section-divider">

      <!-- Scenario Practice -->
      <section id="scenarios">
        <h2>Scenario Practice</h2>

        <p>Test your understanding of the invariants with these scenarios.</p>

        <h3>Scenario 1: The Long Session</h3>
        <p>You have been working with Claude for 2 hours on a complex feature. The session is going well, but you are getting close to finishing. Claude's responses are still accurate.</p>
        <p><strong>Options:</strong></p>
        <ul>
          <li>A) Continue until done - it is working</li>
          <li>B) Save state, restart, finish with fresh context</li>
          <li>C) Ask Claude if it needs a break</li>
        </ul>
        <details class="troubleshoot">
          <summary>Reveal Answer</summary>
          <div class="troubleshoot-content">
            <p><strong>Best choice: B</strong></p>
            <p><strong>Invariants that apply:</strong></p>
            <ul>
              <li>Invariant 2: Fresh Beats Extended - Even if it seems fine, quality degrades invisibly</li>
              <li>Invariant 3: External Memory Required - Save state before reset</li>
              <li>Invariant 6: Git As Recovery - Commit before resetting</li>
            </ul>
            <p><strong>Why not A:</strong> "Going well" is subjective. The 2-hour context is definitely in degradation territory. The last bit of work is at your WORST quality.</p>
            <p><strong>Why not C:</strong> Claude does not know it needs a "break" - it has no self-awareness of context degradation.</p>
          </div>
        </details>

        <h3>Scenario 2: The Super-Agent Request</h3>
        <p>Your manager wants you to build "one agent that can handle all our code review, security scanning, and documentation updates."</p>
        <p><strong>Options:</strong></p>
        <ul>
          <li>A) Build it - consolidation is efficient</li>
          <li>B) Build three specialized agents</li>
          <li>C) Explain why this is impossible</li>
        </ul>
        <details class="troubleshoot">
          <summary>Reveal Answer</summary>
          <div class="troubleshoot-content">
            <p><strong>Best choice: B</strong></p>
            <p><strong>Invariants that apply:</strong></p>
            <ul>
              <li>Invariant 1: Context Is The Constraint - One agent cannot hold all three domains' context</li>
              <li>Invariant 5: Parallelization Essential - Three agents can work in parallel</li>
              <li>Invariant 7: Simplicity Bias - Three simple agents beat one complex agent</li>
            </ul>
            <p><strong>Why not A:</strong> The super-agent will have context pollution. Security context interferes with review context. Documentation fills space needed for code analysis.</p>
            <p><strong>Why not C:</strong> It is not impossible, it is suboptimal. Do not position as "cannot" but as "here is a better way."</p>
          </div>
        </details>

        <h3>Scenario 3: The Framework Pitch</h3>
        <p>A colleague recommends LangChain for your new multi-agent system. "It handles orchestration, memory, and tool use out of the box."</p>
        <p><strong>Options:</strong></p>
        <ul>
          <li>A) Use LangChain - leverage existing tools</li>
          <li>B) Build custom - roll your own</li>
          <li>C) Evaluate based on your specific needs</li>
        </ul>
        <details class="troubleshoot">
          <summary>Reveal Answer</summary>
          <div class="troubleshoot-content">
            <p><strong>Best choice: C (leaning toward B)</strong></p>
            <p><strong>Invariants that apply:</strong></p>
            <ul>
              <li>Invariant 7: Simplicity Bias - Frameworks add complexity</li>
              <li>Invariant 1: Context Is The Constraint - Frameworks abstract away context control</li>
            </ul>
            <p><strong>Evaluation criteria:</strong></p>
            <ol>
              <li>Do you need LangChain's specific features TODAY?</li>
              <li>Do you understand what LangChain does under the hood?</li>
              <li>Can you debug LangChain when it fails?</li>
              <li>Does LangChain let you control context window usage?</li>
            </ol>
            <p>If any answer is "no": Roll your own.</p>
            <blockquote>
              "Frameworks abstract away the levers that matter: context window and control flow."
              <cite>-- Dexter Horthy</cite>
            </blockquote>
          </div>
        </details>
      </section>

      <hr class="section-divider">

      <!-- Woven Summaries Section -->
      <section id="go-deeper" class="callout-insight">
        <h2>Go Deeper: Full Guides</h2>
        <p>These invariants are distilled from comprehensive synthesis. Explore the full guides for detailed evidence and implementation patterns.</p>

        <div class="summary-card" style="background: #f0ebe3; border-radius: 8px; padding: 1.5rem; margin: 1.5rem 0; border-left: 4px solid #2a7d7d;">
          <h3 style="margin-top: 0; color: #5c4b3a;">Core Principles: The WHYs Behind Invariants</h3>
          <p>The 8 foundational principles that explain WHY each invariant exists. Covers the principle hierarchy (Context Is Finite as the primary constraint from which all others flow), derived patterns for each principle, and checkpoint questions for self-assessment.</p>
          <p><strong>Key insight:</strong> These invariants are not arbitrary rules - they are the physics of agent engineering. Understanding WHY enables adaptation to novel situations.</p>
          <p><a href="../../synthesis/principles-core.html">Read the Full Core Principles Guide</a></p>
        </div>

        <div class="summary-card" style="background: #f0ebe3; border-radius: 8px; padding: 1.5rem; margin: 1.5rem 0; border-left: 4px solid #6b9b7a;">
          <h3 style="margin-top: 0; color: #5c4b3a;">Derivation Guide: From Principles to Patterns</h3>
          <p>Learn to CREATE patterns from invariants rather than just memorizing them. The 4-step derivation process: Identify Constraint, Apply Relevant Principles, Compose Primitives, Validate Composition. Includes worked examples showing how Ralph, CC Mirror, and Gas Town were derived.</p>
          <p><strong>Key insight:</strong> Every major pattern emerged from applying invariants to specific constraints. Derivation skill is more valuable than pattern memorization.</p>
          <p><a href="../../synthesis/principles-derivation-guide.html">Read the Full Derivation Guide</a></p>
        </div>

        <div class="summary-card" style="background: #f0ebe3; border-radius: 8px; padding: 1.5rem; margin: 1.5rem 0; border-left: 4px solid #c49052;">
          <h3 style="margin-top: 0; color: #5c4b3a;">Staff Engineer Mental Model: Cross-Reference</h3>
          <p>How staff engineers think about invariants in practice. Covers the Six Waves Framework, practitioner divergences (where experts legitimately differ), and the trust gradient for autonomous work. Maps invariants to scale tiers and infrastructure requirements.</p>
          <p><strong>Key insight:</strong> Invariants do not change with scale, but their enforcement mechanisms do. Solo work uses CLAUDE.md; enterprise work uses LiteLLM proxies and ReasoningBank.</p>
          <p><a href="../../synthesis/staff-engineer-mental-model.html">Read the Full Staff Engineer Guide</a></p>
        </div>
      </section>

      <hr class="section-divider">

      <!-- The Unified View -->
      <section>
        <h2>The Unified View</h2>
        <p>All 16 mental models connect to a single meta-insight:</p>
        <blockquote>
          AI agents are capable but unreliable, fast but stateless.
        </blockquote>
        <p>Every mental model compensates for one of these limitations:</p>
        <table>
          <thead>
            <tr>
              <th>Limitation</th>
              <th>Compensation</th>
              <th>Mental Model</th>
            </tr>
          </thead>
          <tbody>
            <tr><td>Context degrades</td><td>Design around limits</td><td>Model 1</td></tr>
            <tr><td>Stateless</td><td>External state</td><td>Model 2</td></tr>
            <tr><td>Quality fades</td><td>Fresh sessions</td><td>Model 3</td></tr>
            <tr><td>Unreliable</td><td>Verification gates</td><td>Model 4</td></tr>
            <tr><td>Single agent limits</td><td>Parallelization</td><td>Model 5</td></tr>
            <tr><td>Cannot self-specify</td><td>Human orchestration</td><td>Model 6</td></tr>
            <tr><td>Misunderstands big tasks</td><td>Atomic tasks</td><td>Model 7</td></tr>
            <tr><td>Variable capability</td><td>Model tiering</td><td>Model 8</td></tr>
            <tr><td>No cross-session learning</td><td>Compounding</td><td>Model 9</td></tr>
            <tr><td>Complex systems fail</td><td>Simplicity</td><td>Model 10</td></tr>
          </tbody>
        </table>
        <p><strong>The Thinking Transformation:</strong></p>
        <p><em>Before:</em> "How do I prompt the agent better?"</p>
        <p><em>After:</em> "How do I design around agent limitations?"</p>
        <p>The shift is from "fixing the agent" to "designing the system."</p>
      </section>

      <hr class="section-divider">

      <!-- Navigation -->
      <div class="footer-nav">
        <a href="../mental-models/practice-heuristics.html" class="nav-prev">
          <span class="nav-direction">Previous</span>
          <span class="nav-title">Practice &amp; Heuristics</span>
        </a>
        <a href="../../foundations/principles/core.html" class="nav-next">
          <span class="nav-direction">Next</span>
          <span class="nav-title">Core Principles</span>
        </a>
      </div>

      <div class="related-pages">
        <h3>Related Content</h3>
        <ul>
          <li><a href="../mental-models/core-models.html">Core Mental Models (1-10)</a> - Detailed exploration of each model</li>
          <li><a href="../mental-models/advanced-models.html">Advanced Mental Models (11-16)</a> - Scale-specific models</li>
          <li><a href="../../foundations/principles/core.html">Core Principles</a> - The WHYs behind invariants</li>
          <li><a href="../../start-here/judgment-guide.html">Judgment Guide</a> - Decision trees for common situations</li>
        </ul>
      </div>
    </main>
  </div>

  <!-- Mobile sidebar toggle -->
  <button class="sidebar-toggle" aria-label="Open navigation">Menu</button>
  <div class="sidebar-overlay"></div>

  <script src="../../js/sidebar.js"></script>
</body>
</html>
