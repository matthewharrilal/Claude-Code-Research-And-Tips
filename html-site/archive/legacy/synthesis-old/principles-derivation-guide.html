<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta data-pagefind-meta="section" content="Synthesis">
  <meta data-pagefind-meta="category" content="Principles">
  <title>Deriving Patterns from First Principles - Claude Code Knowledge Base</title>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="stylesheet" href="../css/sidebar.css">
  <link rel="stylesheet" href="../css/search.css">
</head>
<body>
  <!-- Search Modal -->
  <div class="search-modal" id="searchModal" aria-hidden="true">
    <div class="search-overlay" onclick="closeSearch()"></div>
    <div class="search-content">
      <div class="search-header">
        <div class="search-input-wrapper">
          <span class="search-icon-input">&#128269;</span>
          <input type="text" id="searchInput" placeholder="Search documentation..." autocomplete="off" />
          <kbd class="search-kbd">ESC</kbd>
        </div>
      </div>
      <div class="search-filters">
        <button class="filter-btn active" data-filter="all">All</button>
        <button class="filter-btn" data-filter="synthesis">Synthesis</button>
        <button class="filter-btn" data-filter="extractions">Extractions</button>
      </div>
      <div class="search-results" id="searchResults">
        <div class="search-empty"><p>Start typing to search... (Press Cmd+K anytime)</p></div>
      </div>
      <div class="search-footer">
        <span>Up/Down Navigate</span><span>Enter Select</span><span>ESC Close</span>
      </div>
    </div>
  </div>

  <button class="search-trigger" onclick="openSearch()" aria-label="Search" style="float: right; margin-bottom: 1rem;">
    <span class="search-icon">Cmd+K</span>
    <span class="search-text">Search</span>
  </button>

  <nav class="left-nav" id="leftNav">
    <div class="px-4 mb-4">
      <a href="../index.html" class="text-xs font-semibold text-accent hover:text-accent-light uppercase tracking-wider">Claude Code KB</a>
    </div>
    <div class="nav-content"></div>
  </nav>

  <div class="container">
    <!-- Breadcrumb Navigation -->
    <nav class="nav-breadcrumb">
      <a href="../index.html">Home</a>
      <span>/</span>
      <a href="synthesis-index.html">Synthesis</a>
      <span>/</span>
      <a href="principles-master.html">Principles</a>
      <span>/</span>
      <span>Derivation Guide</span>
    </nav>

    <!-- You Are Here Context Box -->
    <div class="you-are-here" style="background: linear-gradient(135deg, #f0ebe3 0%, #fefcf3 100%); border-left: 4px solid #2a7d7d; border-radius: 8px; padding: 1.5rem; margin-bottom: 2rem;">
      <h3 style="color: #2a7d7d; margin-top: 0; font-size: 0.9em; text-transform: uppercase; letter-spacing: 0.5px;">You Are Here</h3>
      <p style="margin-bottom: 0;">This is the <strong>"teach a person to fish" guide</strong> - how to CREATE new patterns rather than just use existing ones. Read this after mastering <a href="principles-core.html">Core Principles</a> and several existing patterns. This doc transforms you from a pattern consumer into a pattern creator.</p>
    </div>

    <h1><span class="bionic">Der</span>iving <span class="bionic">Pat</span>terns from <span class="bionic">Fir</span>st <span class="bionic">Pri</span>nciples</h1>

    <p class="conversational-lead">
      Every major Claude Code pattern emerged from someone applying a few core principles to a specific constraint. Understanding this process is more valuable than memorizing patterns.
    </p>

    <!-- Table of Contents -->
    <div class="toc">
      <div class="toc-title">Contents</div>
      <ul>
        <li><a href="#core-principles">The Core Principles (Quick Reference)</a></li>
        <li><a href="#derivation-process">The Derivation Process</a></li>
        <li><a href="#primitives-catalog">The Primitives Catalog</a></li>
        <li><a href="#worked-examples">Worked Examples</a>
          <ul>
            <li><a href="#example-ralph">Deriving Ralph Wiggum</a></li>
            <li><a href="#example-cc-mirror">Deriving CC Mirror</a></li>
            <li><a href="#example-worktrees">Deriving Git Worktree Parallelism</a></li>
            <li><a href="#example-handoffs">Deriving File-Based Handoffs</a></li>
            <li><a href="#example-adversarial">Deriving Adversarial Speccing</a></li>
          </ul>
        </li>
        <li><a href="#diy-derivation">DIY Pattern Derivation Worksheet</a></li>
        <li><a href="#practice-problems">Practice Problems</a></li>
        <li><a href="#validation-checklist">Validation Checklist</a></li>
        <li><a href="#troubleshooting">Troubleshooting</a></li>
      </ul>
    </div>

    <hr class="section-divider">

    <!-- Core Principles -->
    <section id="core-principles">
      <h2>The <span class="bionic">Cor</span>e <span class="bionic">Pri</span>nciples (Quick Reference)</h2>

      <p>Before deriving any pattern, internalize these foundational truths:</p>

      <h3>Principle 1: Context Is the Primary Constraint</h3>
      <blockquote>
        <p>"Context rot: LLMs get stupider with more tokens"</p>
        <cite>-- @mattpocockuk</cite>
      </blockquote>
      <p>The ~200K token context window (effective ~100K for quality work) is a <strong>hard ceiling</strong> that shapes every architectural decision.</p>

      <h3>Principle 2: External State &gt; Internal Memory</h3>
      <blockquote>
        <p>"Each iteration spawns a NEW instance with NO memory of previous work. Continuity comes from: Git history, prd.json, progress.txt"</p>
        <cite>-- Ryan Carson</cite>
      </blockquote>
      <p><strong>Implication:</strong> Memory is files. Not conversation. Not summaries. Files.</p>

      <h3>Principle 3: Verification Is Non-Negotiable</h3>
      <p>Tests, type checks, and quality gates prevent error propagation. A task isn't complete until it's verified.</p>

      <h3>Principle 4: Separation of Concerns</h3>
      <blockquote>
        <p>"YOU DO NOT WRITE CODE. YOU DO NOT RUN COMMANDS. You are the CONDUCTOR."</p>
        <cite>-- CC Mirror philosophy</cite>
      </blockquote>
      <p>Planning and execution are fundamentally different modes. Mixing them causes context pollution.</p>

      <h3>Principle 5: Structured Data Beats Natural Language</h3>
      <p>JSON parses deterministically. Markdown has conventions. Natural language is ambiguous.</p>

      <h3>Principle 6: Fresh Context Beats Extended Sessions</h3>
      <p>New agent instances with external state beat long conversations with internal memory.</p>

      <h3>Principle 7: Isolation Enables Parallelism</h3>
      <p>Agents that share state conflict. Agents in isolated environments can work in parallel.</p>

      <!-- Checkpoint -->
      <div class="checkpoint" style="background: #f0ebe3; border-left: 4px solid #6b9b7a; border-radius: 8px; padding: 1.5rem; margin: 2rem 0;">
        <div class="checkpoint-header" style="color: #6b9b7a; font-weight: 600;">Checkpoint: Core Principles Understanding</div>
        <p><strong>You should now understand:</strong></p>
        <ul>
          <li>All 7 core principles and their implications</li>
          <li>Why context is the PRIMARY constraint that shapes all other decisions</li>
          <li>The relationship between external state and fresh context</li>
          <li>How isolation enables parallelism while separation enables clarity</li>
        </ul>
        <p><strong>If unclear:</strong> See <a href="principles-core.html">Core Principles</a> for detailed explanation of each principle before proceeding.</p>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Derivation Process -->
    <section id="derivation-process">
      <h2>The <span class="bionic">Der</span>ivation <span class="bionic">Pro</span>cess</h2>

      <p>Every pattern follows this derivation sequence:</p>

      <div class="ascii-diagram">
+---------------------------------------------------------------------+
|                    THE DERIVATION PROCESS                           |
+---------------------------------------------------------------------+
|                                                                     |
|  Step 1: IDENTIFY THE CONSTRAINT                                    |
|          What limitation or requirement are you solving for?        |
|          - Context exhaustion?                                      |
|          - Need parallelism?                                        |
|          - Long-running work?                                       |
|          - Quality degradation?                                     |
|                                                                     |
|  Step 2: APPLY RELEVANT PRINCIPLES                                  |
|          Which core principles address this constraint?             |
|          - External state for memory?                               |
|          - Fresh context for quality?                               |
|          - Separation for clarity?                                  |
|          - Isolation for parallelism?                               |
|                                                                     |
|  Step 3: COMPOSE PRIMITIVES                                         |
|          What building blocks combine to implement?                 |
|          - Loops, JSON state, file handoffs?                        |
|          - Task tool, model selection, preambles?                   |
|          - Git worktrees, branches, hooks?                          |
|                                                                     |
|  Step 4: VALIDATE COMPOSITION                                       |
|          Does the pattern actually work?                            |
|          - Does it respect context limits?                          |
|          - Is state recoverable on failure?                         |
|          - Are there verification steps?                            |
|          - Can humans intervene when needed?                        |
|                                                                     |
+---------------------------------------------------------------------+
      </div>
    </section>

    <hr class="section-divider">

    <!-- Primitives Catalog -->
    <section id="primitives-catalog">
      <h2>The <span class="bionic">Pri</span>mitives <span class="bionic">Cat</span>alog</h2>

      <p>These are the building blocks you compose into patterns:</p>

      <h3>Execution Primitives</h3>
      <div class="table-responsive">
        <table>
          <thead>
            <tr><th>Primitive</th><th>What It Does</th><th>When To Use</th></tr>
          </thead>
          <tbody>
            <tr><td><code>claude "..."</code></td><td>Single Claude invocation</td><td>Atomic task execution</td></tr>
            <tr><td><code>for</code> loop</td><td>Repeated invocations</td><td>Sequential iteration</td></tr>
            <tr><td><code>&amp;</code> (background)</td><td>Parallel execution</td><td>Independent tasks</td></tr>
            <tr><td><code>Task()</code> tool</td><td>Spawn subagent</td><td>Delegated work</td></tr>
            <tr><td>Git worktree</td><td>Isolated directory</td><td>Parallel branches</td></tr>
            <tr><td>Docker container</td><td>Isolated environment</td><td>Maximum isolation</td></tr>
          </tbody>
        </table>
      </div>

      <h3>State Primitives</h3>
      <div class="table-responsive">
        <table>
          <thead>
            <tr><th>Primitive</th><th>What It Does</th><th>When To Use</th></tr>
          </thead>
          <tbody>
            <tr><td><code>progress.txt</code></td><td>Append-only log</td><td>Cross-iteration memory</td></tr>
            <tr><td><code>prd.json</code></td><td>Task state tracking</td><td>Pass/fail status</td></tr>
            <tr><td><code>CLAUDE.md</code></td><td>Project context</td><td>Onboarding/constraints</td></tr>
            <tr><td>Git commit</td><td>Checkpoint</td><td>State preservation</td></tr>
            <tr><td>Handoff JSON</td><td>Agent communication</td><td>Multi-agent coordination</td></tr>
            <tr><td><code>status.json</code></td><td>Current state</td><td>Live monitoring</td></tr>
          </tbody>
        </table>
      </div>

      <h3>Control Primitives</h3>
      <div class="table-responsive">
        <table>
          <thead>
            <tr><th>Primitive</th><th>What It Does</th><th>When To Use</th></tr>
          </thead>
          <tbody>
            <tr><td>Completion signal</td><td><code>&lt;promise&gt;COMPLETE&lt;/promise&gt;</code></td><td>Loop termination</td></tr>
            <tr><td>Hooks</td><td>Lifecycle automation</td><td>Notifications, formatting</td></tr>
            <tr><td>Quality gates</td><td>Tests/types before commit</td><td>Verification enforcement</td></tr>
            <tr><td>Timeout</td><td>Max iterations</td><td>Safety limits</td></tr>
            <tr><td>Worker preamble</td><td>Role enforcement</td><td>Orchestrator/worker separation</td></tr>
          </tbody>
        </table>
      </div>

      <h3>Communication Primitives</h3>
      <div class="table-responsive">
        <table>
          <thead>
            <tr><th>Primitive</th><th>What It Does</th><th>When To Use</th></tr>
          </thead>
          <tbody>
            <tr><td>File handoff</td><td>JSON between agents</td><td>Async coordination</td></tr>
            <tr><td>Shared volume</td><td>Docker communication</td><td>Container patterns</td></tr>
            <tr><td>Git branch</td><td>Merge-based sync</td><td>Feature isolation</td></tr>
            <tr><td>TaskList/TaskGet</td><td>Native task API</td><td>CC Mirror orchestration</td></tr>
          </tbody>
        </table>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Worked Examples -->
    <section id="worked-examples">
      <h2><span class="bionic">Wor</span>ked <span class="bionic">Exa</span>mples</h2>

      <!-- Example 1: Ralph -->
      <div id="example-ralph" class="scenario-block">
        <div class="scenario-header">
          <span class="scenario-type">Example 1</span>
          <h3 class="scenario-title">Deriving Ralph Wiggum from Principles</h3>
        </div>
        <div class="scenario-content">
          <h4>Step 1: Identify the Constraint</h4>
          <blockquote>
            <p>"I need autonomous execution without quality degradation over time"</p>
          </blockquote>
          <p>The constraint is: <strong>long-running autonomous work that doesn't get stupider.</strong></p>

          <h4>Step 2: Apply Relevant Principles</h4>
          <p>Which principles address this?</p>
          <ul>
            <li><strong>Context Is Primary Constraint</strong> - Quality degrades with context usage</li>
            <li><strong>Fresh Context &gt; Extended Sessions</strong> - New instances don't accumulate context pollution</li>
            <li><strong>External State &gt; Internal Memory</strong> - State must persist outside conversation</li>
            <li><strong>Verification Is Non-Negotiable</strong> - Each iteration must verify its work</li>
          </ul>

          <h4>Step 3: Compose Primitives</h4>
          <div class="table-responsive">
            <table>
              <thead>
                <tr><th>Principle</th><th>Primitive Implementation</th></tr>
              </thead>
              <tbody>
                <tr><td>Fresh context</td><td>Bash loop spawning new Claude instances</td></tr>
                <tr><td>External memory</td><td><code>progress.txt</code> (append-only), <code>prd.json</code> (task state)</td></tr>
                <tr><td>Verification</td><td>Tests + types must pass before marking complete</td></tr>
                <tr><td>Termination</td><td><code>&lt;promise&gt;COMPLETE&lt;/promise&gt;</code> signal for loop exit</td></tr>
              </tbody>
            </table>
          </div>

          <h4>Step 4: Validate Composition</h4>
          <div class="code-block">
            <button class="copy-btn" onclick="copyCode(this)">Copy</button>
            <pre><code># The resulting pattern
for (( i=1; i&lt;=$MAX_ITERATIONS; i++ )); do
  claude "Review prd.json. Pick ONE task with passes: false.
          Implement it. Run tests.
          If passing, mark passes: true, commit.
          Append learnings to progress.txt.
          If ALL complete, output: &lt;promise&gt;COMPLETE&lt;/promise&gt;"

  if grep -q "&lt;promise&gt;COMPLETE&lt;/promise&gt;" output.txt; then
    break
  fi
done</code></pre>
          </div>

          <p><strong>Validation Questions:</strong></p>
          <ul>
            <li>Context limits respected? Yes - fresh instance each iteration</li>
            <li>State recoverable? Yes - git commits + files persist</li>
            <li>Verification steps? Yes - tests must pass before commit</li>
            <li>Human intervention? Yes - can CTRL+C, edit files, restart</li>
          </ul>

          <p><strong>Result:</strong> Ralph Wiggum pattern</p>
        </div>
      </div>

      <!-- Checkpoint -->
      <div class="checkpoint" style="background: #f0ebe3; border-left: 4px solid #6b9b7a; border-radius: 8px; padding: 1.5rem; margin: 2rem 0;">
        <div class="checkpoint-header" style="color: #6b9b7a; font-weight: 600;">Checkpoint: Ralph Derivation</div>
        <p><strong>You should now understand:</strong></p>
        <ul>
          <li>How to identify the constraint (long-running autonomy without degradation)</li>
          <li>Which principles address that constraint (context, fresh context, external state, verification)</li>
          <li>How to select primitives that implement those principles</li>
          <li>The validation questions that confirm a pattern works</li>
        </ul>
        <p><strong>If unclear:</strong> Re-trace the 4 steps above for Ralph before moving to the next example.</p>
      </div>

      <!-- Example 2: CC Mirror -->
      <div id="example-cc-mirror" class="scenario-block">
        <div class="scenario-header">
          <span class="scenario-type">Example 2</span>
          <h3 class="scenario-title">Deriving CC Mirror from Principles</h3>
        </div>
        <div class="scenario-content">
          <h4>Step 1: Identify the Constraint</h4>
          <blockquote>
            <p>"I need multiple agents working in parallel without chaos"</p>
          </blockquote>
          <p>The constraint is: <strong>parallelism without coordination failures.</strong></p>

          <h4>Step 2: Apply Relevant Principles</h4>
          <ul>
            <li><strong>Separation of Concerns</strong> - Planning and execution must be separate roles</li>
            <li><strong>Isolation Enables Parallelism</strong> - Workers need isolated contexts</li>
            <li><strong>External State &gt; Internal Memory</strong> - Coordination via files/APIs, not conversation</li>
            <li><strong>Verification Is Non-Negotiable</strong> - Each worker's output must be checked</li>
          </ul>

          <h4>Step 3: Compose Primitives</h4>
          <div class="table-responsive">
            <table>
              <thead>
                <tr><th>Principle</th><th>Primitive Implementation</th></tr>
              </thead>
              <tbody>
                <tr><td>Separation</td><td>Orchestrator (Opus) + Workers (Sonnet/Haiku)</td></tr>
                <tr><td>Isolation</td><td>Task tool spawns isolated subagents</td></tr>
                <tr><td>External state</td><td>TaskCreate/TaskUpdate API for coordination</td></tr>
                <tr><td>Verification</td><td>Acceptance criteria in task definitions</td></tr>
              </tbody>
            </table>
          </div>

          <h4>Step 4: Validate Composition</h4>
          <div class="code-block">
            <button class="copy-btn" onclick="copyCode(this)">Copy</button>
            <pre><code>Orchestrator:
  - Tools: Task*, AskUserQuestion, Read (minimal)
  - NEVER: Write, Edit, Bash

Worker Preamble:
  CONTEXT: You are a WORKER agent, not an orchestrator.
  RULES:
  - Complete ONLY the task described below
  - Do NOT spawn sub-agents
  - Do NOT call TaskCreate or TaskUpdate
  TASK: [specific work]</code></pre>
          </div>

          <p><strong>Result:</strong> CC Mirror (Hub-and-Spoke Orchestration) pattern</p>
        </div>
      </div>

      <!-- Example 3: Worktrees -->
      <div id="example-worktrees" class="scenario-block">
        <div class="scenario-header">
          <span class="scenario-type">Example 3</span>
          <h3 class="scenario-title">Deriving Git Worktree Parallelism</h3>
        </div>
        <div class="scenario-content">
          <h4>Constraint:</h4>
          <p>"I need multiple features developed simultaneously without file conflicts"</p>

          <h4>Principles Applied:</h4>
          <ul>
            <li><strong>Isolation Enables Parallelism</strong> - Each agent needs its own working directory</li>
            <li><strong>External State &gt; Internal Memory</strong> - Git history is shared, files are isolated</li>
            <li><strong>Fresh Context &gt; Extended</strong> - Each worktree gets fresh agent instances</li>
          </ul>

          <h4>Resulting Pattern:</h4>
          <div class="code-block">
            <button class="copy-btn" onclick="copyCode(this)">Copy</button>
            <pre><code># Create isolated worktrees
git worktree add ../wt-feature-auth feature-auth
git worktree add ../wt-feature-payments feature-payments

# Run parallel agents
(cd ../wt-feature-auth && claude "Implement auth") &
(cd ../wt-feature-payments && claude "Implement payments") &
wait

# Human merges
git checkout main
git merge feature-auth
git merge feature-payments</code></pre>
          </div>
        </div>
      </div>

      <!-- Example 4: Handoffs -->
      <div id="example-handoffs" class="scenario-block">
        <div class="scenario-header">
          <span class="scenario-type">Example 4</span>
          <h3 class="scenario-title">Deriving File-Based Handoffs</h3>
        </div>
        <div class="scenario-content">
          <h4>Constraint:</h4>
          <p>"Agents need to pass context to each other without conversation"</p>

          <h4>Principles Applied:</h4>
          <ul>
            <li><strong>External State &gt; Internal Memory</strong> - Communication via filesystem</li>
            <li><strong>Structured Data &gt; Natural Language</strong> - JSON for machine parsing</li>
            <li><strong>Context Is Primary</strong> - Handoffs should be compact, not full dumps</li>
          </ul>

          <h4>Resulting Pattern:</h4>
          <div class="code-block">
            <button class="copy-btn" onclick="copyCode(this)">Copy</button>
            <pre><code>// handoff-agent1-to-agent2.json
{
  "from": "agent1",
  "to": "agent2",
  "timestamp": "2026-01-09T10:30:00Z",
  "context": {
    "completed": ["API schema", "Database models"],
    "next_steps": ["Implement REST endpoints"],
    "blockers": [],
    "notes": "Using FastAPI, see docs in /api/README.md"
  }
}</code></pre>
          </div>
        </div>
      </div>

      <!-- Example 5: Adversarial Speccing -->
      <div id="example-adversarial" class="scenario-block">
        <div class="scenario-header">
          <span class="scenario-type">Example 5</span>
          <h3 class="scenario-title">Deriving Adversarial Speccing</h3>
        </div>
        <div class="scenario-content">
          <h4>Constraint:</h4>
          <p>"I need to stress-test designs before implementation"</p>

          <h4>Principles Applied:</h4>
          <ul>
            <li><strong>Separation of Concerns</strong> - Proposer and critic are different roles</li>
            <li><strong>Verification Is Non-Negotiable</strong> - Designs should be verified, not just code</li>
            <li><strong>Isolation Enables Parallelism</strong> - Subagents have isolated contexts</li>
          </ul>

          <h4>Resulting Pattern:</h4>
          <div class="code-block">
            <button class="copy-btn" onclick="copyCode(this)">Copy</button>
            <pre><code>Process:
1. Architect proposes design
2. Critic (persona: DHH) challenges for simplicity
3. Architect addresses concerns
4. Critic (persona: Security Engineer) challenges for security
5. Architect addresses concerns
6. Iterate until all critics approve
7. Proceed to implementation</code></pre>
          </div>
        </div>
      </div>
    </section>

    <hr class="section-divider">

    <!-- DIY Derivation -->
    <section id="diy-derivation">
      <h2><span class="bionic">DIY</span> <span class="bionic">Pat</span>tern <span class="bionic">Der</span>ivation <span class="bionic">Wor</span>ksheet</h2>

      <p>Use this worksheet when facing a new problem:</p>

      <h3>Step 1: State Your Constraint</h3>
      <div class="code-block">
        <pre><code>I need to: _________________________________________________

The core challenge is: _____________________________________

This is hard because: ______________________________________</code></pre>
      </div>

      <h3>Step 2: Identify Applicable Principles</h3>
      <div class="table-responsive">
        <table>
          <thead>
            <tr><th>Principle</th><th>Applies?</th><th>How?</th></tr>
          </thead>
          <tbody>
            <tr><td>Context is primary constraint</td><td></td><td></td></tr>
            <tr><td>External state &gt; internal memory</td><td></td><td></td></tr>
            <tr><td>Verification is non-negotiable</td><td></td><td></td></tr>
            <tr><td>Separation of concerns</td><td></td><td></td></tr>
            <tr><td>Structured data &gt; natural language</td><td></td><td></td></tr>
            <tr><td>Fresh context &gt; extended sessions</td><td></td><td></td></tr>
            <tr><td>Isolation enables parallelism</td><td></td><td></td></tr>
          </tbody>
        </table>
      </div>

      <h3>Step 3: Select Primitives</h3>
      <div class="code-block">
        <pre><code>Execution: Which execution primitives?
[ ] Single invocation  [ ] Loop  [ ] Parallel  [ ] Subagent  [ ] Worktree  [ ] Container

State: Which state primitives?
[ ] progress.txt  [ ] prd.json  [ ] CLAUDE.md  [ ] Git commits  [ ] Handoff JSON  [ ] status.json

Control: Which control primitives?
[ ] Completion signal  [ ] Hooks  [ ] Quality gates  [ ] Timeout  [ ] Worker preamble

Communication: Which communication primitives?
[ ] File handoff  [ ] Shared volume  [ ] Git branch  [ ] Task API</code></pre>
      </div>

      <h3>Step 4: Compose and Validate</h3>
      <div class="code-block">
        <pre><code>Your Pattern:
[Describe the composed pattern here]

Validation Checklist:
[ ] Respects context limits?
[ ] State recoverable on failure?
[ ] Verification steps included?
[ ] Human can intervene?
[ ] Terminates reliably?
[ ] Scales as needed?</code></pre>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Practice Problems -->
    <section id="practice-problems">
      <h2><span class="bionic">Pra</span>ctice <span class="bionic">Pro</span>blems</h2>

      <!-- Problem 1 -->
      <details>
        <summary>Problem 1: The Documentation Gap</summary>
        <div>
          <p><strong>Constraint:</strong> You need to generate comprehensive documentation for a large codebase, but reading the entire codebase would exhaust context.</p>

          <p><strong>Hints:</strong></p>
          <ul>
            <li>What principle addresses context exhaustion?</li>
            <li>How can you process the codebase in chunks?</li>
            <li>How should documentation state accumulate?</li>
          </ul>

          <details>
            <summary>One Possible Solution</summary>
            <div>
              <p><strong>Principles Applied:</strong></p>
              <ul>
                <li>Context is primary - Process in chunks</li>
                <li>External state - Accumulate docs in files</li>
                <li>Fresh context - New instance per module</li>
              </ul>

              <p><strong>Pattern:</strong></p>
              <div class="code-block">
                <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                <pre><code>for module in $(find src -type d -maxdepth 1); do
  claude "Document $module only. Write to docs/${module}.md"
done
claude "Synthesize docs/*.md into docs/README.md"</code></pre>
              </div>
            </div>
          </details>
        </div>
      </details>

      <!-- Problem 2 -->
      <details>
        <summary>Problem 2: The Security Audit</summary>
        <div>
          <p><strong>Constraint:</strong> You need multiple security perspectives reviewing code (OWASP, crypto, injection, etc.) but a single agent can't hold all expertise.</p>

          <p><strong>Hints:</strong></p>
          <ul>
            <li>What principle addresses multiple perspectives?</li>
            <li>How do specialists work without conflicting?</li>
            <li>How are findings aggregated?</li>
          </ul>

          <details>
            <summary>One Possible Solution</summary>
            <div>
              <p><strong>Principles Applied:</strong></p>
              <ul>
                <li>Separation of concerns - Specialized reviewers</li>
                <li>Isolation - Each reviewer has own context</li>
                <li>External state - Findings in shared files</li>
              </ul>

              <p><strong>Pattern:</strong></p>
              <div class="code-block">
                <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                <pre><code>Spawn in parallel:
- OWASP reviewer -> findings/owasp.md
- Crypto reviewer -> findings/crypto.md
- Injection reviewer -> findings/injection.md

Then: Aggregator synthesizes findings/security-report.md</code></pre>
              </div>
            </div>
          </details>
        </div>
      </details>

      <!-- Problem 3 -->
      <details>
        <summary>Problem 3: The Living Specification</summary>
        <div>
          <p><strong>Constraint:</strong> Requirements change during development. How do you prevent the PRD from becoming stale?</p>

          <details>
            <summary>One Possible Solution</summary>
            <div>
              <p><strong>Pattern:</strong></p>
              <div class="code-block">
                <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                <pre><code>PostToolUse hook on Edit:
  If modifying behavior -> Prompt: "Does this change require PRD update?"

Before each Ralph iteration:
  Validate: Current code matches PRD assertions

Explicit PRD update mode:
  "Update PRD for new requirement: [X]"
  Regenerate affected user stories</code></pre>
              </div>
            </div>
          </details>
        </div>
      </details>

      <!-- Problem 4 -->
      <details>
        <summary>Problem 4: The Cost Optimizer</summary>
        <div>
          <p><strong>Constraint:</strong> You're running expensive Opus calls but many tasks don't need that capability. How do you minimize cost while maintaining quality?</p>

          <details>
            <summary>One Possible Solution</summary>
            <div>
              <p><strong>Pattern:</strong></p>
              <div class="code-block">
                <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                <pre><code>{
  "task": "Implement login",
  "complexity": "simple",  // simple -> Haiku, medium -> Sonnet, complex -> Opus
  "escalated": false
}

If simple task fails twice:
  Set escalated: true
  Retry with Sonnet

If Sonnet fails:
  Escalate to Opus

Complexity heuristics:
- File lookup: simple
- Pattern implementation: medium
- Architecture decision: complex</code></pre>
              </div>
            </div>
          </details>
        </div>
      </details>

      <!-- Problem 5 -->
      <details>
        <summary>Problem 5: The Overnight Orchestrator</summary>
        <div>
          <p><strong>Constraint:</strong> You want to run CC Mirror-style multi-agent work overnight, but need to handle failures gracefully and notify you of critical issues.</p>

          <details>
            <summary>One Possible Solution</summary>
            <div>
              <p><strong>Pattern:</strong></p>
              <div class="code-block">
                <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                <pre><code>Outer Ralph loop:
  Inner CC Mirror orchestration:
    Workers with:
      - Max retry = 3
      - Checkpoint after each task
      - Notification hook on repeated failure

  If orchestrator exits cleanly:
    Check all tasks complete -> exit loop
    Else -> continue next iteration

  If orchestrator fails:
    Notification hook -> Poke/Pushover
    Wait for human input or timeout
    Resume from checkpoint</code></pre>
              </div>
            </div>
          </details>
        </div>
      </details>
    </section>

    <hr class="section-divider">

    <!-- Validation Checklist -->
    <section id="validation-checklist">
      <h2><span class="bionic">Val</span>idation <span class="bionic">Che</span>cklist</h2>

      <p>Before deploying any derived pattern, verify:</p>

      <h3>Context Management</h3>
      <ul>
        <li>Maximum context usage estimated and acceptable</li>
        <li>Fresh context strategy if long-running</li>
        <li>No unbounded state accumulation</li>
      </ul>

      <h3>State Durability</h3>
      <ul>
        <li>All state persisted to filesystem or git</li>
        <li>Can resume from any checkpoint</li>
        <li>State format is parseable (JSON/YAML/structured MD)</li>
      </ul>

      <h3>Error Handling</h3>
      <ul>
        <li>Failures detected and logged</li>
        <li>Retry strategy defined</li>
        <li>Escalation path for repeated failures</li>
        <li>Human notification for critical issues</li>
      </ul>

      <h3>Verification</h3>
      <ul>
        <li>Quality gates (tests/types) in workflow</li>
        <li>No marking complete without verification</li>
        <li>Cross-checking for multi-agent outputs</li>
      </ul>

      <h3>Human Oversight</h3>
      <ul>
        <li>Can pause at any point</li>
        <li>State is inspectable</li>
        <li>Overrides are possible</li>
        <li>Audit trail exists</li>
      </ul>

      <h3>Termination</h3>
      <ul>
        <li>Clear completion criteria</li>
        <li>Maximum iterations/timeout defined</li>
        <li>Graceful shutdown preserves state</li>
      </ul>
    </section>

    <hr class="section-divider">

    <!-- Quick Reference -->
    <section id="quick-ref">
      <h2><span class="bionic">Qui</span>ck <span class="bionic">Ref</span>erence: <span class="bionic">Pri</span>nciple - <span class="bionic">Pat</span>tern <span class="bionic">Map</span>ping</h2>

      <div class="table-responsive">
        <table>
          <thead>
            <tr><th>When You Need</th><th>Apply Principle</th><th>Consider Pattern</th></tr>
          </thead>
          <tbody>
            <tr><td>Long-running autonomy</td><td>Fresh context + External state</td><td>Ralph Loop</td></tr>
            <tr><td>Parallel work</td><td>Isolation + Separation</td><td>CC Mirror, Worktrees</td></tr>
            <tr><td>Quality consistency</td><td>Verification</td><td>CI Green Enforcement</td></tr>
            <tr><td>Multi-perspective</td><td>Separation + Isolation</td><td>Adversarial Speccing</td></tr>
            <tr><td>Persistent memory</td><td>External state</td><td>progress.txt, Claude-Mem</td></tr>
            <tr><td>Human oversight</td><td>External state + Hooks</td><td>Notification patterns</td></tr>
            <tr><td>Cost optimization</td><td>Separation</td><td>Model selection matrix</td></tr>
            <tr><td>Recovery</td><td>External state + Verification</td><td>Checkpointing</td></tr>
          </tbody>
        </table>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Troubleshooting -->
    <section id="troubleshooting">
      <h2><span class="bionic">Tro</span>ubleshooting</h2>

      <details class="troubleshoot">
        <summary>Derived Pattern Fails in Practice</summary>
        <div>
          <p><strong>Symptom:</strong> Pattern looks correct on paper but fails when executed</p>
          <p><strong>Cause:</strong> Usually a missed validation question or incomplete primitive selection</p>
          <p><strong>Fix:</strong></p>
          <ol>
            <li>Re-run the validation checklist rigorously</li>
            <li>Check for missing primitives (often: external memory, termination condition)</li>
            <li>Test with a trivial example before scaling</li>
          </ol>
        </div>
      </details>

      <details class="troubleshoot">
        <summary>Can't Identify the Right Principles</summary>
        <div>
          <p><strong>Symptom:</strong> Constraint is clear but unsure which principles apply</p>
          <p><strong>Cause:</strong> Incomplete understanding of principle implications</p>
          <p><strong>Fix:</strong> Use this mapping:</p>
          <ul>
            <li>Long-running work? - P1 (Context), P3 (Fresh), P2 (External)</li>
            <li>Quality degradation? - P3 (Fresh), P6 (Verification)</li>
            <li>Parallel work? - P7 (Isolation), P4 (Separation)</li>
            <li>Coordination needed? - P4 (Separation), P2 (External)</li>
          </ul>
        </div>
      </details>

      <details class="troubleshoot">
        <summary>Primitives Don't Compose Cleanly</summary>
        <div>
          <p><strong>Symptom:</strong> Primitives work individually but conflict when combined</p>
          <p><strong>Cause:</strong> Incompatible primitives or missing "glue" primitive</p>
          <p><strong>Fix:</strong></p>
          <ol>
            <li>Check the compatibility matrix in <a href="architecture-composition-rules.html">Architecture Composition Rules</a></li>
            <li>Add handoff mechanisms between incompatible primitives</li>
            <li>Consider if you need a wrapper/coordinator primitive</li>
          </ol>
        </div>
      </details>

      <details class="troubleshoot">
        <summary>Pattern Too Complex</summary>
        <div>
          <p><strong>Symptom:</strong> Derived pattern has 10+ primitives; hard to understand</p>
          <p><strong>Cause:</strong> Over-engineering; trying to solve too many constraints at once</p>
          <p><strong>Fix:</strong></p>
          <ol>
            <li>Decompose into smaller patterns that compose</li>
            <li>Start with minimal viable pattern, add primitives incrementally</li>
            <li>Ask: "What's the simplest pattern that addresses the primary constraint?"</li>
          </ol>
        </div>
      </details>

      <details class="troubleshoot">
        <summary>Reinventing Existing Patterns</summary>
        <div>
          <p><strong>Symptom:</strong> Spend time deriving a pattern that already exists</p>
          <p><strong>Cause:</strong> Not checking existing pattern catalog first</p>
          <p><strong>Fix:</strong></p>
          <ol>
            <li>Before deriving, search existing patterns in <a href="architecture-composition-rules.html">Architecture Composition Rules</a></li>
            <li>Ask: "Is my constraint similar to one that led to Ralph/CC Mirror/etc.?"</li>
            <li>Consider adapting an existing pattern rather than creating from scratch</li>
          </ol>
        </div>
      </details>
    </section>

    <hr class="section-divider">

    <!-- The Meta-Principle -->
    <div class="callout callout-insight">
      <div class="callout-title">The Meta-Principle</div>
      <blockquote style="border: none; background: none; padding: 0; margin: 0; font-style: normal;">
        <p>Patterns are not gospel. They are crystallized solutions to specific constraints.</p>
      </blockquote>
      <p>When your constraint changes, derive a new pattern. When principles evolve, revisit existing patterns. <strong>The derivation skill matters more than pattern memorization.</strong></p>
      <p><strong>The progression:</strong></p>
      <ol>
        <li>Learn existing patterns - Immediate productivity</li>
        <li>Understand the principles - Know when patterns apply</li>
        <li>Master derivation - Create patterns for novel constraints</li>
      </ol>
      <p>You are now at step 3.</p>
    </div>

    <hr class="section-divider">

    <!-- Related Pages -->
    <div class="related-pages">
      <h3>Related Principles Documents</h3>
      <ul>
        <li><a href="principles-core.html">Core Principles</a> - The 8 foundational principles</li>
        <li><a href="principles-learning-loops.html">Learning Loops</a> - Feedback loop engineering</li>
        <li><a href="principles-anti-patterns.html">Anti-Patterns</a> - What NOT to do and why</li>
      </ul>
    </div>

    <!-- Footer Navigation -->
    <nav class="footer-nav">
      <a href="principles-core.html" class="nav-prev">
        <span class="nav-direction">Previous</span>
        <span class="nav-title">Core Principles</span>
      </a>
      <a href="principles-learning-loops.html" class="nav-next">
        <span class="nav-direction">Next</span>
        <span class="nav-title">Learning Loops</span>
      </a>
    </nav>

    <!-- Tags -->
    <div style="margin-top: 2rem;">
      <span class="tag">#derivation</span>
      <span class="tag">#first-principles</span>
      <span class="tag">#pattern-design</span>
      <span class="tag">#meta-guide</span>
      <span class="tag">#constraint-analysis</span>
      <span class="tag">#composition</span>
      <span class="tag">#primitives</span>
      <span class="tag">#validation</span>
    </div>
  </div>

  <script src="../js/copy-code.js"></script>
  <script src="../js/search.js"></script>
  <script src="../js/global-nav.js"></script>
</body>
</html>
