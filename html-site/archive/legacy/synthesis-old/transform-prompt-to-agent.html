<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta data-pagefind-meta="section" content="Synthesis">
  <meta data-pagefind-meta="category" content="Transformations">
  <title>Prompt Engineering to Agent Engineering | Transformations | Claude Code Knowledge Base</title>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="stylesheet" href="../css/sidebar.css">
  <link rel="stylesheet" href="../css/search.css">
  <style>
    .you-are-here {
      background: linear-gradient(135deg, #f0ebe3 0%, #fefcf3 100%);
      border-left: 4px solid #2a7d7d;
      border-radius: 8px;
      padding: 1.5rem;
      margin-bottom: 2rem;
    }
    .bionic { font-weight: 700; }
    .checkpoint {
      background: #f0ebe3;
      border-left: 4px solid #6b9b7a;
      border-radius: 8px;
      padding: 1.5rem;
      margin: 2rem 0;
    }
    .checkpoint-header { color: #6b9b7a; font-weight: 600; margin-bottom: 0.5rem; }
    .milestone {
      background: linear-gradient(90deg, #6b9b7a 0%, #2a7d7d 100%);
      color: white;
      padding: 1rem 1.5rem;
      border-radius: 8px;
      text-align: center;
      margin: 2rem 0;
    }
    .before-after-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 24px;
      margin: 24px 0;
    }
    @media (max-width: 900px) {
      .before-after-container { grid-template-columns: 1fr; }
    }
    .before-box, .after-box {
      border-radius: 12px;
      padding: 20px;
    }
    .before-box {
      background: #fdf0ef;
      border: 2px solid var(--error);
    }
    .before-box h3, .before-box h4 { color: var(--error); margin-top: 0; }
    .after-box {
      background: #eef6f0;
      border: 2px solid var(--success);
    }
    .after-box h3, .after-box h4 { color: var(--success); margin-top: 0; }
    .code-block-wrapper {
      position: relative;
    }
    .troubleshoot {
      border: 1px solid #c97065;
      border-radius: 8px;
      margin: 1rem 0;
    }
    .troubleshoot summary {
      background: #fef6f5;
      padding: 1rem;
      cursor: pointer;
      color: #c97065;
      font-weight: 600;
    }
    .troubleshoot > div {
      padding: 1rem;
    }
    .d-final-box {
      background: #f5f0e8;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1rem;
      margin: 1rem 0;
      font-size: 0.9em;
    }
    .d-final-box h4 {
      margin-top: 0;
      color: var(--heading);
    }
    .era-comparison {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin: 24px 0;
    }
    .era-box {
      border-radius: 12px;
      padding: 20px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
    }
    .era-box h4 {
      margin-top: 0;
      color: var(--accent);
    }
    @media (max-width: 768px) {
      .era-comparison { grid-template-columns: 1fr; }
    }
    .capability-ladder {
      background: var(--code-bg);
      border-radius: 8px;
      padding: 20px;
      margin: 24px 0;
      font-family: 'SF Mono', Monaco, monospace;
      font-size: 0.9em;
    }
  </style>
</head>
<body>
  <!-- Search Modal -->
  <div class="search-modal" id="searchModal" aria-hidden="true">
    <div class="search-overlay" onclick="closeSearch()"></div>
    <div class="search-content">
      <div class="search-header">
        <div class="search-input-wrapper">
          <span class="search-icon-input">&#128269;</span>
          <input type="text" id="searchInput" placeholder="Search documentation..." autocomplete="off" />
          <kbd class="search-kbd">ESC</kbd>
        </div>
      </div>
      <div class="search-filters">
        <button class="filter-btn active" data-filter="all">All</button>
        <button class="filter-btn" data-filter="synthesis">Synthesis</button>
        <button class="filter-btn" data-filter="extractions">Extractions</button>
        <button class="filter-btn" data-filter="journeys">Journeys</button>
      </div>
      <div class="search-results" id="searchResults">
        <div class="search-empty"><p>Start typing to search... (Press Cmd+K anytime)</p></div>
      </div>
      <div class="search-footer">
        <span>Up/Down Navigate</span><span>Enter Select</span><span>ESC Close</span>
      </div>
    </div>
  </div>

  <button class="search-trigger" onclick="openSearch()" aria-label="Search" style="float: right; margin-bottom: 1rem;">
    <span class="search-icon">Cmd+K</span>
    <span class="search-text">Search</span>
  </button>

  <nav class="left-nav" id="leftNav">
    <div class="px-4 mb-4">
      <a href="../index.html" class="text-xs font-semibold text-accent hover:text-accent-light uppercase tracking-wider">Claude Code KB</a>
    </div>
    <div class="nav-content"></div>
  </nav>

  <div class="container">
    <nav class="nav-breadcrumb">
      <a href="../index.html">Home</a>
      <span>/</span>
      <a href="synthesis-index.html">Synthesis</a>
      <span>/</span>
      <a href="transform-master.html">Transformations</a>
      <span>/</span>
      <strong>Prompt to Agent</strong>
    </nav>

    <h1><span class="bionic">Tra</span>nsformation: <span class="bionic">Pro</span>mpt <span class="bionic">Eng</span>ineering to <span class="bionic">Age</span>nt <span class="bionic">Eng</span>ineering</h1>

    <div class="you-are-here">
      <h3 style="margin-top: 0; color: var(--accent);"><span class="bionic">You</span> Are <span class="bionic">Her</span>e</h3>
      <p>This document captures the fundamental mindset shift from crafting individual prompts to designing autonomous systems. If you're still obsessing over the perfect wording or few-shot examples, this transformation shows you the path to system-level thinking. This connects to the evolution from Level 1-2 (prompt-focused) to Level 3-5 (architecture-focused) on the complexity ladder.</p>
    </div>

    <div class="d-final-box">
      <h4>D-FINAL Integration</h4>
      <p><strong>Validates invariants:</strong> INV-1 (Context is constraint), INV-4 (Verification as trust boundary), INV-5 (Parallelization over single-agent), INV-6 (Human as orchestrator), INV-7 (Atomic tasks), INV-10 (Simplicity compensates)</p>
      <p><strong>Maps to complexity ladder:</strong> Level 1 (Single Session) to Level 2-5 (Ralph to CC Mirror)</p>
      <p><strong>Cross-references:</strong> <a href="architecture-complexity-ladder.html">Complexity Ladder</a>, <a href="JUDGMENT-GUIDE.html">Judgment Guide</a></p>
    </div>

    <div class="toc">
      <div class="toc-title">Contents</div>
      <ul>
        <li><a href="#paradigm-shift">The Paradigm Shift</a></li>
        <li><a href="#before">BEFORE: Prompt Engineering</a></li>
        <li><a href="#after">AFTER: Agent Engineering</a></li>
        <li><a href="#new-skills">The New Skills</a></li>
        <li><a href="#mental-model">Mental Model Shift</a></li>
        <li><a href="#key-questions">Key Questions Changed</a></li>
        <li><a href="#transition">How to Make the Transition</a></li>
        <li><a href="#capability-ladder">The Capability Ladder</a></li>
        <li><a href="#what-stays">What Stays the Same</a></li>
        <li><a href="#troubleshooting">Troubleshooting</a></li>
      </ul>
    </div>

    <hr class="section-divider">

    <h2 id="paradigm-shift">The <span class="bionic">Par</span>adigm <span class="bionic">Shi</span>ft</h2>

    <div class="era-comparison">
      <div class="era-box">
        <h4>Prompt Engineering Era (2023-2024)</h4>
        <ul>
          <li><strong>Focus:</strong> Crafting the perfect prompt</li>
          <li><strong>Model:</strong> Request followed by Response</li>
          <li><strong>Skill:</strong> Prompt writing</li>
          <li><strong>Time horizon:</strong> Single interaction</li>
        </ul>
      </div>
      <div class="era-box">
        <h4>Agent Engineering Era (2025-2026)</h4>
        <ul>
          <li><strong>Focus:</strong> Designing systems of agents</li>
          <li><strong>Model:</strong> Orchestration followed by Execution followed by Iteration</li>
          <li><strong>Skill:</strong> System architecture</li>
          <li><strong>Time horizon:</strong> Hours to days</li>
        </ul>
      </div>
    </div>

    <hr class="section-divider">

    <h2 id="before"><span class="bionic">BEF</span>ORE: <span class="bionic">Pro</span>mpt <span class="bionic">Eng</span>ineering</h2>

    <div class="before-box" style="margin: 24px 0;">
      <h3>Mindset</h3>
      <p><em>"How do I phrase this to get the best output?"</em></p>
      <p>The prompt engineer obsessed over wording. Every comma mattered. The perfect system prompt was a dark art. Success depended on knowing the magic words.</p>
    </div>

    <h3><span class="bionic">Act</span>ivities</h3>
    <ul>
      <li><strong>Prompt templates</strong> - Library of proven prompts for different tasks</li>
      <li><strong>Few-shot examples</strong> - Showing the model what you want via examples</li>
      <li><strong>Role prompting</strong> - "You are an expert..." incantations</li>
      <li><strong>Chain-of-thought</strong> - "Think step by step" and reasoning scaffolds</li>
      <li><strong>Output formatting</strong> - Wrestling JSON from reluctant models</li>
      <li><strong>Prompt chaining</strong> - Manual orchestration across interactions</li>
    </ul>

    <h3><span class="bionic">Lim</span>itations</h3>
    <ul>
      <li><strong>Single interaction bound</strong> - Each prompt stands alone</li>
      <li><strong>Human must stay engaged</strong> - Can't walk away mid-task</li>
      <li><strong>No persistent state</strong> - Context window is the only memory</li>
      <li><strong>Quality varies by prompt</strong> - Tiny changes cascade unpredictably</li>
      <li><strong>No self-correction</strong> - Errors require human intervention</li>
      <li><strong>Linear execution</strong> - One thing at a time</li>
    </ul>

    <hr class="section-divider">

    <h2 id="after"><span class="bionic">AFT</span>ER: <span class="bionic">Age</span>nt <span class="bionic">Eng</span>ineering</h2>

    <div class="after-box" style="margin: 24px 0;">
      <h3>Mindset</h3>
      <p><em>"How do I design a system that accomplishes this autonomously?"</em></p>
      <p>The agent engineer thinks in systems. The prompt is just one small piece. Success depends on architecture, state management, feedback loops, and orchestration patterns.</p>
    </div>

    <h3><span class="bionic">Act</span>ivities</h3>
    <ul>
      <li><strong>Architecture design</strong> - Orchestrator/worker hierarchies, domain isolation</li>
      <li><strong>State management</strong> - Files, git, databases as persistent memory</li>
      <li><strong>Feedback loops</strong> - Verification steps, learning from errors</li>
      <li><strong>Orchestration patterns</strong> - Ralph Architecture, CC Mirror Pattern</li>
      <li><strong>Tool design</strong> - What capabilities each agent needs</li>
      <li><strong>Checkpoint systems</strong> - Recovery from failures, resumable work</li>
      <li><strong>Parallel coordination</strong> - Multiple agents working simultaneously</li>
    </ul>

    <h3><span class="bionic">Cap</span>abilities</h3>
    <ul>
      <li><strong>Multi-day execution</strong> - Launch Friday, review Monday</li>
      <li><strong>Self-correcting systems</strong> - Agents verify and fix their own work</li>
      <li><strong>Compounding learning</strong> - Each iteration improves the next</li>
      <li><strong>Parallel work streams</strong> - Multiple agents, multiple threads</li>
      <li><strong>Persistent context</strong> - State lives in files, not context windows</li>
      <li><strong>Graceful degradation</strong> - Failures don't crash the whole system</li>
    </ul>

    <hr class="section-divider">

    <h2 id="new-skills">The <span class="bionic">New</span> <span class="bionic">Ski</span>lls</h2>

    <div class="table-responsive">
      <table>
        <thead>
          <tr>
            <th>Old Skill</th>
            <th>New Skill</th>
          </tr>
        </thead>
        <tbody>
          <tr><td>Prompt crafting</td><td>System architecture</td></tr>
          <tr><td>Few-shot examples</td><td>Task decomposition</td></tr>
          <tr><td>Role prompting</td><td>Worker specialization</td></tr>
          <tr><td>Output parsing</td><td>State management</td></tr>
          <tr><td>Prompt chaining</td><td>Orchestration patterns</td></tr>
          <tr><td>Temperature tuning</td><td>Feedback loop design</td></tr>
          <tr><td>Token optimization</td><td>Checkpoint strategy</td></tr>
          <tr><td>Single-model mastery</td><td>Multi-agent coordination</td></tr>
        </tbody>
      </table>
    </div>

    <hr class="section-divider">

    <h2 id="mental-model"><span class="bionic">Men</span>tal <span class="bionic">Mod</span>el <span class="bionic">Shi</span>ft</h2>

    <div class="before-after-container">
      <div class="before-box">
        <h4>OLD: Human-in-the-Loop</h4>
        <pre style="background: transparent; border: none; padding: 0;">Human crafts prompt
    |
    v
AI generates response
    |
    v
Human reviews output
    |
    v
Human refines prompt
    |
    v
[Repeat until satisfied]</pre>
      </div>
      <div class="after-box">
        <h4>NEW: Human-on-the-Loop</h4>
        <pre style="background: transparent; border: none; padding: 0;">Human designs system architecture
    |
    v
Human launches orchestrator agent
    |
    v
Orchestrator spawns worker agents
    |
    v
Workers execute, verify, iterate
    |
    v
Human sleeps / does other work
    |
    v
Human reviews completed results</pre>
      </div>
    </div>

    <hr class="section-divider">

    <h2 id="key-questions"><span class="bionic">Key</span> <span class="bionic">Que</span>stions <span class="bionic">Cha</span>nged</h2>

    <div class="before-after-container">
      <div class="before-box">
        <h4>Old Questions (Prompt Engineering)</h4>
        <ul>
          <li>"What prompt gets the best answer?"</li>
          <li>"How do I avoid hallucinations in this prompt?"</li>
          <li>"What temperature should I use?"</li>
          <li>"How many few-shot examples are enough?"</li>
          <li>"Should I use JSON or markdown output?"</li>
        </ul>
      </div>
      <div class="after-box">
        <h4>New Questions (Agent Engineering)</h4>
        <ul>
          <li>"What architecture ships code overnight?"</li>
          <li>"How do I design feedback loops that catch errors?"</li>
          <li>"Where should state live between agent sessions?"</li>
          <li>"How do I decompose this into parallelizable tasks?"</li>
          <li>"What verification steps ensure quality?"</li>
          <li>"How does the orchestrator coordinate workers?"</li>
          <li>"What happens when a worker fails mid-task?"</li>
        </ul>
      </div>
    </div>

    <hr class="section-divider">

    <h2 id="transition"><span class="bionic">How</span> to <span class="bionic">Mak</span>e the <span class="bionic">Tra</span>nsition</h2>

    <h3>1. <span class="bionic">Sto</span>p <span class="bionic">Opt</span>imizing <span class="bionic">Pro</span>mpts</h3>
    <p>The perfect prompt doesn't exist. And even if it did, it wouldn't scale. Stop spending hours on prompt tweaks. That energy goes elsewhere now.</p>

    <h3>2. <span class="bionic">Sta</span>rt <span class="bionic">Des</span>igning <span class="bionic">Sys</span>tems</h3>
    <p>Think about the whole flow:</p>
    <ul>
      <li>What's the input?</li>
      <li>What are the intermediate steps?</li>
      <li>Where does state persist?</li>
      <li>How do agents communicate?</li>
      <li>What's the verification strategy?</li>
      <li>What's the output?</li>
    </ul>

    <div class="checkpoint">
      <div class="checkpoint-header">Checkpoint: After System Design</div>
      <p><strong>Where you are:</strong> You've shifted from "what prompt works" to "what system accomplishes this."</p>
      <p><strong>What this enables:</strong> Autonomous execution. Your thinking now leads to architectures, not just prompts.</p>

      <p><strong>Verify your mindset shift:</strong></p>

      <div class="table-responsive">
        <table>
          <thead>
            <tr><th>Old Thinking</th><th>New Thinking</th><th>Check</th></tr>
          </thead>
          <tbody>
            <tr><td>"How do I phrase this?"</td><td>"How do I decompose this?"</td><td>[ ]</td></tr>
            <tr><td>"What few-shot examples?"</td><td>"What verification steps?"</td><td>[ ]</td></tr>
            <tr><td>"Which temperature?"</td><td>"Which orchestration pattern?"</td><td>[ ]</td></tr>
            <tr><td>"How do I avoid hallucination?"</td><td>"How do I detect and recover from errors?"</td><td>[ ]</td></tr>
          </tbody>
        </table>
      </div>

      <p><strong>Design checklist for your next task:</strong></p>
      <ul>
        <li>[ ] Input defined (what starts the process)</li>
        <li>[ ] Intermediate steps identified (what happens in between)</li>
        <li>[ ] State persistence chosen (files, git, database)</li>
        <li>[ ] Communication method (handoff files, Task tool)</li>
        <li>[ ] Verification strategy (tests, typecheck, browser automation)</li>
        <li>[ ] Output defined (what signals completion)</li>
      </ul>

      <p><strong>If you're still prompt-focused:</strong></p>
      <ul>
        <li>Check: Are you spending &gt;10 min on prompt wording?</li>
        <li>Check: Are you manually babysitting agent execution?</li>
        <li>Check: Does work stop when you walk away?</li>
        <li>Shift to: Think about the SYSTEM, not the SENTENCE</li>
      </ul>
    </div>

    <h3>3. <span class="bionic">Thi</span>nk in <span class="bionic">Orc</span>hestration</h3>
    <p>Single agents hit limits. Orchestration patterns unlock:</p>
    <ul>
      <li><strong>Ralph Architecture</strong> - Orchestrator + specialized workers</li>
      <li><strong>CC Mirror</strong> - Human-AI parallel development</li>
      <li><strong>Domain Isolation</strong> - Agents own vertical slices</li>
      <li><strong>Swarm Patterns</strong> - Many agents, emergent coordination</li>
    </ul>

    <h3>4. <span class="bionic">Emb</span>race <span class="bionic">Aut</span>onomy</h3>
    <p>The goal is <em>less</em> human involvement, not more. Design systems that:</p>
    <ul>
      <li>Run without supervision</li>
      <li>Self-correct errors</li>
      <li>Checkpoint progress</li>
      <li>Resume from failures</li>
      <li>Report results when done</li>
    </ul>

    <h3>5. <span class="bionic">Bui</span>ld <span class="bionic">Fee</span>dback <span class="bionic">Loo</span>ps</h3>
    <p>Agents without verification go off the rails. Every system needs:</p>
    <ul>
      <li>Output validation</li>
      <li>Error detection</li>
      <li>Quality checks</li>
      <li>Self-correction triggers</li>
      <li>Human review gates (used sparingly)</li>
    </ul>

    <div class="checkpoint">
      <div class="checkpoint-header">Checkpoint: After Feedback Loop Design</div>
      <p><strong>Where you are:</strong> You've designed verification into your agent system, not as an afterthought.</p>
      <p><strong>What this enables:</strong> Self-correcting agents. Errors get caught and fixed automatically. Quality maintained over time.</p>

      <p><strong>Your feedback loop should include:</strong></p>
      <div class="ascii-diagram">
Agent Output
    |
    v
Verification Gate
    |
    +-- Pass --&gt; Commit, Update State, Continue
    |
    +-- Fail --&gt; Error Analysis --&gt; Retry / Escalate / Log
      </div>

      <p><strong>Verification checklist:</strong></p>
      <ul>
        <li>[ ] TypeScript/type checking runs automatically</li>
        <li>[ ] Unit tests run after each change</li>
        <li>[ ] Integration tests validate system behavior</li>
        <li>[ ] Error messages are captured and logged</li>
        <li>[ ] Retry logic handles transient failures</li>
        <li>[ ] Human escalation path exists for hard problems</li>
      </ul>

      <p><strong>Test your feedback loop:</strong></p>
      <div class="code-block-wrapper">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code># Simulate a failing verification
npm run typecheck  # Should this fail, does agent detect it?
npm run test       # If tests fail, does agent retry?</code></pre>
      </div>

      <p><strong>If verification is missing:</strong></p>
      <ul>
        <li>Check: Do acceptance criteria include <code>npm run typecheck passes</code>?</li>
        <li>Check: Do you have any tests at all?</li>
        <li>Check: Is error output being captured?</li>
        <li>Add: At minimum, typecheck verification to every task</li>
      </ul>
    </div>

    <hr class="section-divider">

    <h2 id="capability-ladder">The <span class="bionic">Cap</span>ability <span class="bionic">Lad</span>der</h2>

    <div class="capability-ladder">
Level 1: Single prompt
         "Write a function that..."

Level 2: Prompt chain
         "First analyze, then design, then implement"

Level 3: Single agent with tools
         Agent reads code, edits, runs tests

Level 4: Multi-agent orchestration
         Orchestrator coordinates specialist workers

Level 5: Autonomous systems
         Self-managing agent swarms with learning
    </div>

    <p>Most practitioners jumped from Level 1 to Level 3 without mastering Level 2. That's fine. Level 2 was a bridge. But going from Level 3 to Level 4 requires genuinely new thinking.</p>

    <div class="checkpoint">
      <div class="checkpoint-header">Checkpoint: Identify Your Current Level</div>
      <p><strong>Where you are:</strong> You've read the capability ladder. Now honestly assess your current position.</p>
      <p><strong>What this enables:</strong> Focused learning. Know exactly what skill to develop next.</p>

      <p><strong>Self-assessment:</strong></p>

      <div class="table-responsive">
        <table>
          <thead>
            <tr><th>Level</th><th>Evidence</th><th>You're Here If...</th></tr>
          </thead>
          <tbody>
            <tr><td>1</td><td>Single prompts</td><td>You copy-paste prompts, tweak wording</td></tr>
            <tr><td>2</td><td>Prompt chains</td><td>You manually sequence multiple prompts</td></tr>
            <tr><td>3</td><td>Single agent + tools</td><td>You use Claude Code with file/bash access</td></tr>
            <tr><td>4</td><td>Multi-agent</td><td>You spawn workers, manage task dependencies</td></tr>
            <tr><td>5</td><td>Autonomous systems</td><td>Agents run overnight, self-correct, compound</td></tr>
          </tbody>
        </table>
      </div>

      <p><strong>Assess your workflow:</strong></p>
      <ul>
        <li>[ ] I craft individual prompts carefully &rarr; Level 1</li>
        <li>[ ] I chain prompts manually &rarr; Level 2</li>
        <li>[ ] I use Claude Code in YOLO mode &rarr; Level 3</li>
        <li>[ ] I spawn subagents for specialized tasks &rarr; Level 4</li>
        <li>[ ] My agents run while I sleep &rarr; Level 5</li>
      </ul>

      <p><strong>Your next step based on level:</strong></p>
      <ul>
        <li>Level 1-2: Start using Claude Code CLI</li>
        <li>Level 3: Try Ralph pattern (overnight loop)</li>
        <li>Level 4: Implement CC Mirror or Gas Town</li>
        <li>Level 5: You're building your own orchestrator</li>
      </ul>

      <p><strong>If you're stuck at Level 3:</strong></p>
      <ul>
        <li>Check: Have you tried running Ralph for 5+ iterations?</li>
        <li>Check: Do you have prd.json + progress.txt infrastructure?</li>
        <li>Check: Is verification automated (tests, typecheck)?</li>
        <li>Shift to: Set up file-based state, run overnight</li>
      </ul>
    </div>

    <hr class="section-divider">

    <h2 id="what-stays"><span class="bionic">Wha</span>t <span class="bionic">Sta</span>ys the <span class="bionic">Sam</span>e</h2>

    <p>Not everything changed:</p>
    <ul>
      <li>Clear instructions still matter</li>
      <li>Context still needs management</li>
      <li>Quality still needs verification</li>
      <li>Humans still define goals</li>
    </ul>

    <p>The difference: these concerns now live at the <em>system</em> level, not the <em>prompt</em> level.</p>

    <div class="milestone">
      <p><strong>Prompt Engineering:</strong> Human art of talking to AI</p>
      <p><strong>Agent Engineering:</strong> Human art of designing AI systems</p>
      <p>The question is no longer "What should I say?"</p>
      <p>The question is now "What should I build?"</p>
    </div>

    <hr class="section-divider">

    <h2 id="troubleshooting"><span class="bionic">Tro</span>ubleshooting</h2>

    <details class="troubleshoot">
      <summary>Falling Back to Prompt Tweaking</summary>
      <div>
        <p><strong>Symptom:</strong> You spend 30+ minutes rewording a prompt trying to get better output, instead of designing the system around the limitation.</p>
        <p><strong>Cause:</strong> Old habits die hard. Prompt engineering instincts are strong.</p>
        <p><strong>Fix:</strong></p>
        <div class="code-block-wrapper">
          <pre><code>STOP and ask yourself:
1. Am I tweaking words or designing systems?
2. Would a verification step catch this error?
3. Could I decompose this into smaller tasks?
4. Would parallelization help here?

If you're on iteration 3+ of prompt tweaks -&gt; STOP -&gt; design a system instead</code></pre>
        </div>
        <p><strong>Example shift:</strong></p>
        <ul>
          <li><strong>BAD:</strong> "How do I phrase this to avoid hallucinations?"</li>
          <li><strong>GOOD:</strong> "What verification step catches hallucinations before they matter?"</li>
        </ul>
      </div>
    </details>

    <details class="troubleshoot">
      <summary>Agent System Too Complex</summary>
      <div>
        <p><strong>Symptom:</strong> You designed an 8-agent orchestration system for a 30-minute task. Setup time exceeds work time.</p>
        <p><strong>Cause:</strong> Over-engineering. Agent thinking doesn't mean agent everything.</p>
        <p><strong>Fix:</strong></p>
        <div class="code-block-wrapper">
          <pre><code>Apply the complexity test:
- Task &lt; 30 min? -&gt; Single agent, maybe Ralph
- Task &lt; 2 hours? -&gt; Ralph or simple orchestrator
- Task multi-domain, multi-day? -&gt; Swarm patterns

Complexity should match workload. Simple tasks deserve simple solutions.</code></pre>
        </div>
      </div>
    </details>

    <details class="troubleshoot">
      <summary>Agents Go Off Rails Without Feedback Loops</summary>
      <div>
        <p><strong>Symptom:</strong> You designed an autonomous system but it produces garbage because there's no verification.</p>
        <p><strong>Cause:</strong> Skipped the feedback loop step. Autonomy without verification = chaos.</p>
        <p><strong>Fix:</strong></p>
        <div class="code-block-wrapper">
          <button class="copy-btn" onclick="copyCode(this)">Copy</button>
          <pre><code># Every agent system needs verification
# Minimum viable feedback loop:

# 1. Typecheck (catches 80% of errors)
npm run typecheck

# 2. Tests (catches logic errors)
npm run test

# 3. Output validation (catches hallucinations)
# Define what "done" looks like and verify it

# Add to your system design:
# Input -&gt; Process -&gt; VERIFY -&gt; Output (or retry)</code></pre>
        </div>
      </div>
    </details>

    <details class="troubleshoot">
      <summary>Can't Decompose Task Into Atomic Parts</summary>
      <div>
        <p><strong>Symptom:</strong> Task seems monolithic. "It's all connected, I can't break it apart."</p>
        <p><strong>Cause:</strong> Thinking at the wrong level of abstraction, or task genuinely needs more analysis first.</p>
        <p><strong>Fix:</strong></p>
        <div class="code-block-wrapper">
          <pre><code>Task decomposition technique:

1. List all OUTPUTS the task produces (files, changes, artifacts)
2. Each output is a candidate task
3. Identify dependencies between outputs
4. Group by domain if multi-domain
5. Each group is a worker's scope

If still can't decompose:
- The task needs PLANNING first (run single agent exploration)
- Then decompose the plan</code></pre>
        </div>
        <p><strong>Example:</strong></p>
        <div class="code-block-wrapper">
          <pre><code>"Build user auth" -&gt; Feels monolithic

Outputs:
- users table migration
- sessions table migration
- register endpoint
- login endpoint
- logout endpoint
- LoginForm component
- AuthContext provider
- tests for each

Now you have 8+ atomic tasks</code></pre>
        </div>
      </div>
    </details>

    <details class="troubleshoot">
      <summary>Orchestrator Starts Doing Work</summary>
      <div>
        <p><strong>Symptom:</strong> Your orchestrator agent is reading files, writing code, running commands - violating the Iron Law.</p>
        <p><strong>Cause:</strong> Prompt didn't enforce boundaries strongly enough, or task seemed "small enough" to do directly.</p>
        <p><strong>Fix:</strong></p>
        <div class="code-block-wrapper">
          <button class="copy-btn" onclick="copyCode(this)">Copy</button>
          <pre><code># Add to orchestrator prompt:

## IRON LAW (NON-NEGOTIABLE)
You do NOT:
- Write code
- Run commands
- Read files (except 1-2 for high-level context)
- Edit files
- Run tests

You ONLY:
- Spawn workers via Task tool
- Coordinate dependencies
- Synthesize results
- Report to human

If a task seems "too small to spawn a worker" -&gt; batch it with another task
Never violate the Iron Law, even for "quick fixes"</code></pre>
        </div>
      </div>
    </details>

    <details class="troubleshoot">
      <summary>Don't Know Which Pattern to Use</summary>
      <div>
        <p><strong>Symptom:</strong> You understand the concepts but freeze when choosing between Ralph, CC Mirror, Gas Town, etc.</p>
        <p><strong>Cause:</strong> Pattern selection paralysis. Too many options, unclear criteria.</p>
        <p><strong>Fix:</strong></p>
        <div class="code-block-wrapper">
          <pre><code>Quick pattern selector:

Q1: Does task have clear "done" criteria?
    NO  -&gt; Use single session for exploration first
    YES -&gt; Continue

Q2: Can task be done in one context window (&lt;30 min)?
    YES -&gt; Single session, maybe YOLO mode
    NO  -&gt; Continue

Q3: Is task multi-domain (frontend + backend + tests)?
    NO  -&gt; Ralph loop (single domain, iterations)
    YES -&gt; Continue

Q4: Do you need true parallelism?
    NO  -&gt; Ralph with sequential stories
    YES -&gt; CC Mirror or Git Worktrees

Start simple. Graduate to complexity only when needed.</code></pre>
        </div>
      </div>
    </details>

    <hr class="section-divider">

    <div class="related-pages">
      <h3>Related Pages</h3>
      <ul>
        <li><a href="architecture-complexity-ladder.html">Complexity Ladder (Level 0-7)</a></li>
        <li><a href="transform-single-to-autonomous.html">Transform: Single to Autonomous</a></li>
        <li><a href="transform-generalist-to-swarm.html">Transform: Generalist to Swarm</a></li>
        <li><a href="JUDGMENT-GUIDE.html">Judgment Guide</a></li>
      </ul>
    </div>

    <div class="footer-nav">
      <a href="transform-single-to-autonomous.html" class="nav-prev">
        <span class="nav-direction">&larr; Previous</span>
        <span class="nav-title">Single to Autonomous</span>
      </a>
      <a href="transform-manual-to-filesystem.html" class="nav-next">
        <span class="nav-direction">Next &rarr;</span>
        <span class="nav-title">Manual to Filesystem</span>
      </a>
    </div>

  </div>

  <script>
    function copyCode(btn) {
      const pre = btn.parentElement.querySelector('pre');
      const code = pre.querySelector('code') || pre;
      navigator.clipboard.writeText(code.textContent);
      btn.textContent = 'Copied!';
      setTimeout(() => btn.textContent = 'Copy', 2000);
    }
  </script>
  <script src="../js/copy-code.js"></script>
  <script src="../js/search.js"></script>
  <script src="../js/global-nav.js"></script>
</body>
</html>
