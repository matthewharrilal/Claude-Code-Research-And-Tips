<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta data-pagefind-meta="section" content="Synthesis">
  <meta data-pagefind-meta="category" content="Grammar">
  <title>Agent Pattern Syntax Rules - Claude Code Knowledge Base</title>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="stylesheet" href="../css/sidebar.css">
  <link rel="stylesheet" href="../css/search.css">
</head>
<body>
  <!-- Search Modal -->
  <div class="search-modal" id="searchModal" aria-hidden="true">
    <div class="search-overlay" onclick="closeSearch()"></div>
    <div class="search-content">
      <div class="search-header">
        <div class="search-input-wrapper">
          <span class="search-icon-input">&#128269;</span>
          <input type="text" id="searchInput" placeholder="Search documentation..." autocomplete="off" />
          <kbd class="search-kbd">ESC</kbd>
        </div>
      </div>
      <div class="search-filters">
        <button class="filter-btn active" data-filter="all">All</button>
        <button class="filter-btn" data-filter="synthesis">Synthesis</button>
        <button class="filter-btn" data-filter="extractions">Extractions</button>
        <button class="filter-btn" data-filter="journeys">Journeys</button>
      </div>
      <div class="search-results" id="searchResults">
        <div class="search-empty"><p>Start typing to search... (Press Cmd+K anytime)</p></div>
      </div>
      <div class="search-footer">
        <span>Up/Down Navigate</span><span>Enter Select</span><span>ESC Close</span>
      </div>
    </div>
  </div>

  <button class="search-trigger" onclick="openSearch()" aria-label="Search" style="float: right; margin-bottom: 1rem;">
    <span class="search-icon">Cmd+K</span>
    <span class="search-text">Search</span>
  </button>

  <div class="wide-container">
    <!-- Breadcrumb Navigation -->
    <nav class="nav-breadcrumb">
      <a href="../index.html">Home</a>
      <span>/</span>
      <a href="synthesis-index.html">Synthesis</a>
      <span>/</span>
      <a href="grammar-master.html">Grammar</a>
      <span>/</span>
      <span>Agent Pattern Syntax Rules</span>
    </nav>

    <!-- You Are Here Context Box -->
    <div class="you-are-here" style="background: linear-gradient(135deg, #f0ebe3 0%, #fefcf3 100%); border-left: 4px solid #2a7d7d; border-radius: 8px; padding: 1.5rem; margin-bottom: 2rem;">
      <h3 style="color: #2a7d7d; margin-top: 0; font-size: 0.9em; text-transform: uppercase; letter-spacing: 0.5px;">You Are Here</h3>
      <p style="margin-bottom: 0;"><strong>Agent Pattern Syntax Rules</strong> - This document defines how to combine primitives from the vocabulary into valid compositions. Think of <a href="grammar-vocabulary.html">grammar-vocabulary.html</a> as the dictionary (what words mean) and this document as the grammar rules (how to form sentences). Use this when designing multi-agent systems, autonomous loops, or any pattern that combines multiple primitives. If a composition fails at runtime, check here first - you may have a syntax error.</p>
    </div>

    <h1><span class="b">Age</span>nt <span class="b">Pat</span>tern <span class="b">Syn</span>tax <span class="b">Rul</span>es</h1>

    <!-- Table of Contents -->
    <div class="toc">
      <div class="toc-title">Contents</div>
      <ul>
        <li><a href="#composition-operators">1. Composition Operators</a></li>
        <li><a href="#valid-compositions">2. Valid Compositions</a></li>
        <li><a href="#invalid-compositions">3. Invalid Compositions (Syntax Errors)</a></li>
        <li><a href="#pattern-templates">4. Pattern Templates</a></li>
        <li><a href="#syntax-validation-checklist">5. Syntax Validation Checklist</a></li>
        <li><a href="#composition-grammar">6. Composition Grammar (Formal)</a></li>
        <li><a href="#quick-reference">7. Quick Reference</a></li>
        <li><a href="#troubleshooting">Troubleshooting</a></li>
      </ul>
    </div>

    <hr class="section-divider">

    <!-- Composition Operators -->
    <section id="composition-operators">
      <h2><span class="b">1.</span> <span class="b">Com</span>position <span class="b">Ope</span>rators</h2>

      <h3>Sequential (->)</h3>
      <p><strong>Meaning:</strong> A completes fully, then B starts with A's output</p>
      <p><strong>Symbol:</strong> <code>-></code> or <code>&amp;&amp;</code></p>
      <p><strong>Temporal:</strong> Strictly ordered, blocking</p>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code>Task -> Test -> Commit</code></pre>
      </div>
      <p><strong>Semantics:</strong></p>
      <ul>
        <li>A must exit successfully before B begins</li>
        <li>Output of A becomes input context for B</li>
        <li>Failure in A halts the chain (unless wrapped in error handling)</li>
      </ul>
      <p><strong>Implementation:</strong></p>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code># Shell semantics
task_execute &amp;&amp; test_run &amp;&amp; git_commit

# Explicit chaining
result_a = execute(A)
if result_a.success:
    result_b = execute(B, context=result_a)</code></pre>
      </div>

      <h3>Parallel (||)</h3>
      <p><strong>Meaning:</strong> A and B execute simultaneously, independently</p>
      <p><strong>Symbol:</strong> <code>||</code> or <code>&amp;</code></p>
      <p><strong>Temporal:</strong> Concurrent, non-blocking</p>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code>Worker1 || Worker2 || Worker3</code></pre>
      </div>
      <p><strong>Semantics:</strong></p>
      <ul>
        <li>No execution order guarantee</li>
        <li>No shared mutable state (each gets own worktree/context)</li>
        <li>Coordination happens at sync points, not during execution</li>
      </ul>
      <p><strong>Implementation:</strong></p>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code># Background processes
worker1 &amp;
worker2 &amp;
worker3 &amp;
wait  # Sync point

# Git worktrees for isolation
git worktree add ../worker1-space
git worktree add ../worker2-space</code></pre>
      </div>
      <p><strong>Constraints:</strong> Parallel units must be independent (no data dependencies). Merge conflicts resolved at sync, not during execution.</p>

      <h3>Nested (contains)</h3>
      <p><strong>Meaning:</strong> A contains B; B operates within A's context/lifecycle</p>
      <p><strong>Symbol:</strong> <code>{ }</code></p>
      <p><strong>Temporal:</strong> B's lifetime bounded by A</p>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code>Ralph { Task -> Test -> Commit }</code></pre>
      </div>
      <p><strong>Semantics:</strong></p>
      <ul>
        <li>Outer pattern provides context, state, and lifecycle management</li>
        <li>Inner pattern inherits outer's constraints</li>
        <li>Inner completion doesn't terminate outer (outer may loop)</li>
      </ul>
      <p><strong>Implementation:</strong></p>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code># Ralph contains task execution loop
class Ralph:
    def run(self):
        while not self.done:
            # Nested sequence
            task = self.get_next()
            result = self.execute(task)
            if self.quality_gate(result):
                self.commit(result)</code></pre>
      </div>

      <h3>Conditional (?)</h3>
      <p><strong>Meaning:</strong> Branch execution based on predicate</p>
      <p><strong>Symbol:</strong> <code>?</code> or <code>if/else</code></p>
      <p><strong>Temporal:</strong> Evaluation, then single branch executes</p>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code>passes? -> next : retry
test_result ? commit : (fix -> retest)</code></pre>
      </div>
      <p><strong>Semantics:</strong></p>
      <ul>
        <li>Predicate evaluated once at decision point</li>
        <li>Exactly one branch executes</li>
        <li>Can be chained for multi-way branching</li>
      </ul>
      <p><strong>Implementation:</strong></p>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code>if quality_gate(result):
    proceed_to_next()
else:
    retry_with_fix()</code></pre>
      </div>

      <h3>Loop (while)</h3>
      <p><strong>Meaning:</strong> Repeat pattern until termination condition</p>
      <p><strong>Symbol:</strong> <code>while</code>, <code>for</code></p>
      <p><strong>Temporal:</strong> Iterative, potentially infinite</p>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code>while(has_tasks): task -> test -> commit
for(task in tasks): fetch -> execute -> verify</code></pre>
      </div>
      <p><strong>Semantics:</strong></p>
      <ul>
        <li>Loop body is a complete pattern (often sequential)</li>
        <li>Termination condition checked at defined point (start or end)</li>
        <li>State persists across iterations</li>
      </ul>

      <h3>Fork-Join</h3>
      <p><strong>Meaning:</strong> Split into parallel paths, then synchronize</p>
      <p><strong>Symbol:</strong> fork then join</p>
      <p><strong>Temporal:</strong> Diverge, concurrent execution, converge</p>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code>fork(worker1 || worker2 || worker3) -> join(merge_results)</code></pre>
      </div>
      <p><strong>Semantics:</strong></p>
      <ul>
        <li>Fork creates independent execution contexts</li>
        <li>Join blocks until all paths complete</li>
        <li>Results aggregated at join point</li>
      </ul>

      <!-- Checkpoint -->
      <div class="checkpoint" style="background: #f0ebe3; border-left: 4px solid #6b9b7a; border-radius: 8px; padding: 1.5rem; margin: 2rem 0;">
        <div class="checkpoint-header" style="color: #6b9b7a; font-weight: 600;">Checkpoint: Composition Operators</div>
        <p><strong>You should now understand:</strong></p>
        <ul>
          <li>Sequential (<code>-></code>): A completes, then B starts with A's output</li>
          <li>Parallel (<code>||</code>): A and B run concurrently with isolated state</li>
          <li>Nested (<code>{ }</code>): B operates within A's lifecycle</li>
          <li>Conditional (<code>?</code>): Branch based on predicate</li>
          <li>Loop (<code>while</code>): Repeat until termination condition</li>
          <li>Fork-Join: Split, execute in parallel, merge results</li>
        </ul>
        <p><strong>If unclear:</strong> Re-read each operator's "Semantics" section, especially the constraints.</p>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Valid Compositions -->
    <section id="valid-compositions">
      <h2><span class="b">2.</span> <span class="b">Val</span>id <span class="b">Com</span>positions</h2>

      <h3>1. Loop + State + Quality</h3>
      <p><strong>Pattern:</strong> Autonomous execution with quality gates</p>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code>while has_tasks:
    task = get_next(state)
    result = execute(task)
    if quality_gate(result):
        commit(result)
        update_state(task, DONE)
    else:
        update_state(task, FAILED)
        log_failure(result)
    if all_complete(state):
        break</code></pre>
      </div>
      <p><strong>Why Valid:</strong></p>
      <ul>
        <li>Loop provides iteration</li>
        <li>State tracks progress across iterations</li>
        <li>Quality gate prevents bad commits</li>
        <li>Clear termination condition</li>
      </ul>

      <h3>2. Orchestrator + Workers + Coordination</h3>
      <p><strong>Pattern:</strong> Delegated parallel execution</p>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code>orchestrator:
    tasks = decompose(objective)
    for task in tasks:
        create_subagent(task)

workers || workers || workers:
    receive(task)
    execute_in_worktree()
    report_completion()

orchestrator:
    await all_complete
    merge_results()</code></pre>
      </div>
      <p><strong>Why Valid:</strong></p>
      <ul>
        <li>Orchestrator coordinates, doesn't execute</li>
        <li>Workers execute, don't coordinate</li>
        <li>Clear handoff points between roles</li>
        <li>Isolation via worktrees</li>
      </ul>

      <h3>3. Nested Loops with Escalation</h3>
      <p><strong>Pattern:</strong> Retry with escalation</p>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code>for task in tasks:                    # Outer: task iteration
    attempts = 0
    while attempts &lt; MAX_RETRY:       # Inner: retry loop
        result = execute(task)
        if success(result):
            commit(result)
            break
        attempts += 1
        if attempts == MAX_RETRY:
            escalate_to_human(task)</code></pre>
      </div>
      <p><strong>Why Valid:</strong></p>
      <ul>
        <li>Inner loop bounded (prevents infinite retry)</li>
        <li>Escalation path when automation fails</li>
        <li>Outer loop continues despite inner failures</li>
      </ul>

      <h3>4. Conditional Branching with Recovery</h3>
      <p><strong>Pattern:</strong> Graceful degradation</p>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code>result = execute(task)
if passes_quality_gate(result):
    commit(result)
    proceed_to_next()
elif is_recoverable(result.error):
    fix = generate_fix(result.error)
    retry_with(task, fix)
else:
    quarantine(task)
    notify_human()
    skip_to_next()</code></pre>
      </div>
      <p><strong>Why Valid:</strong></p>
      <ul>
        <li>Multiple outcomes handled</li>
        <li>Recovery attempted before escalation</li>
        <li>Failure doesn't halt entire system</li>
      </ul>

      <h3>5. Fork-Join Parallel Execution</h3>
      <p><strong>Pattern:</strong> CC Mirror style</p>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code>fork create_worktrees(n=3)
    || execute_task_a(worktree_1)
    || execute_task_b(worktree_2)
    || execute_task_c(worktree_3)
join merge_all_worktrees()</code></pre>
      </div>
      <p><strong>Why Valid:</strong></p>
      <ul>
        <li>Isolation prevents conflicts during execution</li>
        <li>Join point handles merge resolution</li>
        <li>Parallelism has clear boundaries</li>
      </ul>

      <!-- Checkpoint -->
      <div class="checkpoint" style="background: #f0ebe3; border-left: 4px solid #6b9b7a; border-radius: 8px; padding: 1.5rem; margin: 2rem 0;">
        <div class="checkpoint-header" style="color: #6b9b7a; font-weight: 600;">Checkpoint: Valid Compositions</div>
        <p><strong>You should now understand:</strong></p>
        <ul>
          <li>Loop + State + Quality: How autonomous execution with quality gates works</li>
          <li>Orchestrator + Workers: Clear role separation with handoff points</li>
          <li>Nested Loops with Escalation: Bounded retries with human fallback</li>
          <li>Fork-Join (CC Mirror): Worktree isolation for parallel execution</li>
        </ul>
        <p><strong>If unclear:</strong> Trace through Template 1 (Ralph Core) step-by-step, identifying each phase.</p>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Invalid Compositions -->
    <section id="invalid-compositions">
      <h2><span class="b">3.</span> <span class="b">Inv</span>alid <span class="b">Com</span>positions (<span class="b">Syn</span>tax <span class="b">Err</span>ors)</h2>

      <h3>Error 1: Worker Contains TaskCreate</h3>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code># INVALID
worker:
    tasks = decompose(objective)  # Workers don't coordinate!
    for t in tasks:
        spawn_subworker(t)</code></pre>
      </div>
      <p><strong>Why Invalid:</strong> Workers execute single tasks; they don't decompose or coordinate. Coordination is the orchestrator's role.</p>
      <p><strong>Fix:</strong></p>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code>orchestrator:
    tasks = decompose(objective)
    for t in tasks:
        assign_to_worker(t)

worker:
    receive(task)
    execute(task)
    report()</code></pre>
      </div>

      <h3>Error 2: Orchestrator + Direct Tool Use</h3>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code># INVALID
orchestrator:
    plan = create_plan()
    code = write_code()       # Orchestrators don't execute!
    tests = run_tests()</code></pre>
      </div>
      <p><strong>Why Invalid:</strong> Orchestrators coordinate and delegate; they don't use tools directly. This conflates orchestration with execution.</p>
      <p><strong>Fix:</strong></p>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code>orchestrator:
    plan = create_plan()
    assign_to_worker(write_code, plan)
    await worker_complete
    assign_to_worker(run_tests)
    await worker_complete</code></pre>
      </div>

      <h3>Error 3: Parallel with Shared Mutable State</h3>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code># INVALID
shared_state = {}
|| worker1: shared_state['a'] = compute_a()
|| worker2: shared_state['b'] = compute_b()  # Race condition!</code></pre>
      </div>
      <p><strong>Why Invalid:</strong> Parallel execution without isolation creates race conditions and undefined behavior.</p>
      <p><strong>Fix:</strong></p>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code>|| worker1: result_a = compute_a()  # Isolated
|| worker2: result_b = compute_b()  # Isolated
join merge:
    combined = {'a': result_a, 'b': result_b}</code></pre>
      </div>

      <h3>Error 4: Loop Without Termination</h3>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code># INVALID
while True:
    task = get_next()
    execute(task)
    # No exit condition!</code></pre>
      </div>
      <p><strong>Why Invalid:</strong> Infinite loops without termination conditions exhaust resources and never complete.</p>
      <p><strong>Fix:</strong></p>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code>while has_tasks(state):
    task = get_next(state)
    execute(task)
    update_state(task, DONE)
    if all_complete(state):
        break</code></pre>
      </div>

      <h3>Error 5: Sequential with No Context Passing</h3>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code># INVALID
task_a -> task_b -> task_c
# But no output flows between them</code></pre>
      </div>
      <p><strong>Why Invalid:</strong> Sequential composition implies data flow. Without it, there's no reason for ordering.</p>
      <p><strong>Fix:</strong></p>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code>result_a = task_a()
result_b = task_b(context=result_a)
result_c = task_c(context=result_b)

# Or use parallel if truly independent:
|| task_a
|| task_b
|| task_c</code></pre>
      </div>

      <h3>Error 6: Nested Without Lifecycle Respect</h3>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code># INVALID
outer:
    inner:
        long_running_task()
    # outer exits before inner completes</code></pre>
      </div>
      <p><strong>Why Invalid:</strong> Inner patterns must complete within outer's lifecycle. Orphaned inner processes create undefined state.</p>
      <p><strong>Fix:</strong></p>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code>outer:
    inner:
        long_running_task()
    await inner.complete  # Explicit synchronization</code></pre>
      </div>

      <h3>Error 7: Quality Gate After Commit</h3>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code># INVALID
execute(task)
commit(result)           # Already committed!
if quality_gate(result): # Too late
    proceed()</code></pre>
      </div>
      <p><strong>Why Invalid:</strong> Quality gates must precede irreversible actions. Checking after commit is pointless.</p>
      <p><strong>Fix:</strong></p>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code>execute(task)
if quality_gate(result):
    commit(result)
    proceed()
else:
    rollback()</code></pre>
      </div>

      <!-- Checkpoint -->
      <div class="checkpoint" style="background: #f0ebe3; border-left: 4px solid #6b9b7a; border-radius: 8px; padding: 1.5rem; margin: 2rem 0;">
        <div class="checkpoint-header" style="color: #6b9b7a; font-weight: 600;">Checkpoint: Syntax Errors</div>
        <p><strong>You should now understand:</strong></p>
        <ul>
          <li>Why workers must never spawn sub-workers (Error 1)</li>
          <li>Why orchestrators must never use tools directly (Error 2)</li>
          <li>Why parallel execution requires isolated state (Error 3)</li>
          <li>Why loops need termination conditions (Error 4)</li>
          <li>Why quality gates must precede commits (Error 7)</li>
        </ul>
        <p><strong>If unclear:</strong> For each error, compare the "INVALID" code with the "Fix" to see the correction.</p>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Pattern Templates -->
    <section id="pattern-templates">
      <h2><span class="b">4.</span> <span class="b">Pat</span>tern <span class="b">Tem</span>plates</h2>

      <h3>Template 1: Basic Autonomous Loop (Ralph Core)</h3>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code>initialize_state(source=PRD)

while not terminated:
    # Phase 1: Selection
    task = get_next_task(state, priority=highest_ready)
    if task is None:
        if all_complete(state):
            exit(SUCCESS)
        else:
            wait_or_request_unblock()
            continue

    # Phase 2: Execution
    mark_in_progress(task)
    result = execute(task)

    # Phase 3: Verification
    if quality_gate(result):
        commit(result)
        mark_complete(task)
        update_dependencies(task)
    else:
        mark_failed(task, result.errors)
        if retriable(task):
            schedule_retry(task)
        else:
            escalate(task)

    # Phase 4: Continuation
    persist_state()</code></pre>
      </div>

      <h3>Template 2: Parallel Worker Pool (CC Mirror Core)</h3>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code># Orchestrator
objective = parse_input()
tasks = decompose(objective)
worktrees = create_worktrees(count=len(tasks))

for task, worktree in zip(tasks, worktrees):
    spawn_worker(task, worktree)

while not all_complete(workers):
    completed = await_any(workers)
    validate_result(completed)

merge_worktrees(worktrees, strategy=sequential)
cleanup_worktrees()
report_completion()

# Worker (runs in each worktree)
task = receive()
checkout_branch(task.branch)
execute(task)
commit(task.result)
signal_complete()</code></pre>
      </div>

      <h3>Template 3: Retry with Exponential Backoff</h3>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code>MAX_ATTEMPTS = 3
BASE_DELAY = 1

for attempt in range(MAX_ATTEMPTS):
    result = execute(task)

    if success(result):
        return result

    if not retriable(result.error):
        raise UnrecoverableError(result)

    if attempt &lt; MAX_ATTEMPTS - 1:
        delay = BASE_DELAY * (2 ** attempt)
        wait(delay)
        task = refine(task, result.error)

escalate(task, all_attempts=results)</code></pre>
      </div>

      <h3>Template 4: State Machine Execution</h3>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code>states = {PENDING, IN_PROGRESS, BLOCKED, DONE, FAILED}
transitions = {
    PENDING: [IN_PROGRESS, BLOCKED],
    IN_PROGRESS: [DONE, FAILED, BLOCKED],
    BLOCKED: [PENDING],  # After unblock
    DONE: [],            # Terminal
    FAILED: [PENDING]    # After retry decision
}

def transition(task, new_state):
    if new_state not in transitions[task.state]:
        raise InvalidTransition(task.state, new_state)
    task.state = new_state
    persist(task)

def execute_state_machine(task):
    transition(task, IN_PROGRESS)
    result = execute(task)
    if success(result):
        transition(task, DONE)
    elif blocked(result):
        transition(task, BLOCKED)
        notify_blocker(task.blocker)
    else:
        transition(task, FAILED)
        handle_failure(task)</code></pre>
      </div>

      <h3>Template 5: Hierarchical Decomposition</h3>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code>def execute_hierarchical(objective, depth=0, max_depth=3):
    if depth &gt;= max_depth:
        return execute_atomic(objective)

    if is_atomic(objective):
        return execute_atomic(objective)

    subtasks = decompose(objective)
    results = []

    for subtask in subtasks:
        result = execute_hierarchical(subtask, depth+1, max_depth)
        results.append(result)

        if not success(result):
            # Decide: continue, retry, or abort
            if critical(subtask):
                abort(objective, failed_at=subtask)

    return aggregate(results)</code></pre>
      </div>

      <!-- Checkpoint -->
      <div class="checkpoint" style="background: #f0ebe3; border-left: 4px solid #6b9b7a; border-radius: 8px; padding: 1.5rem; margin: 2rem 0;">
        <div class="checkpoint-header" style="color: #6b9b7a; font-weight: 600;">Checkpoint: Pattern Templates</div>
        <p><strong>You should now understand:</strong></p>
        <ul>
          <li>Template 1 (Ralph Core): Selection -> Execution -> Verification -> Continuation</li>
          <li>Template 2 (CC Mirror): Orchestrator spawns workers in worktrees, awaits, merges</li>
          <li>Template 3 (Retry): Exponential backoff with max attempts</li>
          <li>Template 4 (State Machine): Valid state transitions prevent invalid operations</li>
        </ul>
        <p><strong>If unclear:</strong> Implement Template 1 manually in bash to internalize the flow.</p>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Syntax Validation Checklist -->
    <section id="syntax-validation-checklist">
      <h2><span class="b">5.</span> <span class="b">Syn</span>tax <span class="b">Val</span>idation <span class="b">Check</span>list</h2>

      <p>Use this checklist to verify your pattern composition is syntactically valid before implementation.</p>

      <h3>Role Separation</h3>
      <ul>
        <li>Orchestrators only coordinate (no tool use)</li>
        <li>Workers only execute (no task creation)</li>
        <li>Clear handoff points between roles</li>
      </ul>

      <h3>State Management</h3>
      <ul>
        <li>State is explicitly defined and persisted</li>
        <li>State transitions are valid (use state machine)</li>
        <li>Parallel workers have isolated state (worktrees)</li>
        <li>Shared state only modified at sync points</li>
      </ul>

      <h3>Loop Integrity</h3>
      <ul>
        <li>Every loop has a termination condition</li>
        <li>Termination is reachable (not infinitely blocked)</li>
        <li>Progress is made each iteration</li>
        <li>State is persisted across iterations (resume capability)</li>
      </ul>

      <h3>Parallel Safety</h3>
      <ul>
        <li>Parallel units are independent</li>
        <li>No shared mutable state during parallel execution</li>
        <li>Clear fork and join points</li>
        <li>Merge strategy defined for joining</li>
      </ul>

      <h3>Sequential Flow</h3>
      <ul>
        <li>Data flows from predecessor to successor</li>
        <li>Error handling at each step</li>
        <li>No orphaned outputs</li>
        <li>Context preserved across steps</li>
      </ul>

      <h3>Quality Gates</h3>
      <ul>
        <li>Gates precede irreversible actions</li>
        <li>Clear pass/fail criteria</li>
        <li>Failure paths defined</li>
        <li>No commits before verification</li>
      </ul>

      <h3>Error Handling</h3>
      <ul>
        <li>All paths handle failure</li>
        <li>Retry logic is bounded</li>
        <li>Escalation path to human exists</li>
        <li>Cleanup runs even on failure</li>
      </ul>

      <h3>Lifecycle Respect</h3>
      <ul>
        <li>Inner patterns complete before outer exits</li>
        <li>Resources cleaned up on all paths</li>
        <li>No orphaned processes</li>
        <li>Proper shutdown signaling</li>
      </ul>
    </section>

    <hr class="section-divider">

    <!-- Composition Grammar -->
    <section id="composition-grammar">
      <h2><span class="b">6.</span> <span class="b">Com</span>position <span class="b">Gra</span>mmar (<span class="b">For</span>mal)</h2>

      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code>pattern     ::= primitive | composition
primitive   ::= task | state | quality_gate | human_checkpoint
composition ::= sequential | parallel | nested | conditional | loop

sequential  ::= pattern '->' pattern
parallel    ::= pattern '||' pattern
nested      ::= pattern '{' pattern '}'
conditional ::= predicate '?' pattern ':' pattern
loop        ::= 'while' predicate ':' pattern
              | 'for' iterator ':' pattern

predicate   ::= quality_check | state_check | completion_check
quality_check    ::= 'passes(' result ')'
state_check      ::= 'has_tasks(' state ')' | 'all_complete(' state ')'
completion_check ::= 'done' | 'timeout' | 'interrupted'

fork_join   ::= 'fork' parallel_group '->' 'join' merge_strategy
parallel_group ::= pattern ('||' pattern)*
merge_strategy ::= 'sequential' | 'octopus' | 'resolve_conflicts'</code></pre>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Quick Reference -->
    <section id="quick-reference">
      <h2><span class="b">7.</span> <span class="b">Qui</span>ck <span class="b">Ref</span>erence</h2>

      <h3>Operator Summary</h3>
      <div class="table-responsive">
        <table>
          <thead>
            <tr><th>Operator</th><th>Symbol</th><th>Meaning</th><th>Key Constraint</th></tr>
          </thead>
          <tbody>
            <tr><td>Sequential</td><td><code>-></code></td><td>A then B</td><td>A must complete successfully</td></tr>
            <tr><td>Parallel</td><td><code>||</code></td><td>A and B concurrently</td><td>Must be independent</td></tr>
            <tr><td>Nested</td><td><code>{ }</code></td><td>A contains B</td><td>B lifecycle contained in A lifecycle</td></tr>
            <tr><td>Conditional</td><td><code>?:</code></td><td>If X then A else B</td><td>Exactly one branch</td></tr>
            <tr><td>Loop</td><td><code>while</code></td><td>Repeat until condition</td><td>Must terminate</td></tr>
            <tr><td>Fork-Join</td><td><code>fork/join</code></td><td>Split and merge</td><td>Defined merge strategy</td></tr>
          </tbody>
        </table>
      </div>

      <h3>Common Anti-Patterns</h3>
      <div class="table-responsive">
        <table>
          <thead>
            <tr><th>Anti-Pattern</th><th>Symptom</th><th>Resolution</th></tr>
          </thead>
          <tbody>
            <tr><td>God Worker</td><td>Worker does coordination</td><td>Split into orchestrator + worker</td></tr>
            <tr><td>Phantom State</td><td>State not persisted</td><td>Add explicit persistence</td></tr>
            <tr><td>Runaway Loop</td><td>Never terminates</td><td>Add termination condition</td></tr>
            <tr><td>Race Condition</td><td>Parallel + shared state</td><td>Isolate with worktrees</td></tr>
            <tr><td>Late Gate</td><td>Quality check after commit</td><td>Move gate before commit</td></tr>
            <tr><td>Orphan Process</td><td>Inner outlives outer</td><td>Await inner completion</td></tr>
            <tr><td>Silent Failure</td><td>Error swallowed</td><td>Add error handling path</td></tr>
            <tr><td>Infinite Retry</td><td>Unbounded retry loop</td><td>Add max attempts</td></tr>
          </tbody>
        </table>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Troubleshooting -->
    <section id="troubleshooting">
      <h2><span class="b">Trou</span>bleshooting</h2>

      <details class="troubleshoot">
        <summary>Loop Never Terminates</summary>
        <div>
          <p><strong>Symptom:</strong> Ralph loop runs forever, burning API costs</p>
          <p><strong>Cause:</strong> No reachable termination condition, or stop-condition never triggers</p>
          <p><strong>Fix:</strong></p>
          <div class="code-block">
            <button class="copy-btn" onclick="copyCode(this)">Copy</button>
            <pre><code># 1. Verify your stop-condition is detectable:
grep -r "COMPLETE" .

# 2. Verify detection logic
if grep -q "&lt;promise&gt;COMPLETE&lt;/promise&gt;" output.txt; then
    echo "Would exit here"
fi

# 3. Add bounded iteration as safety:
for (( i=1; i&lt;=25; i++ )); do
    output=$(claude -p "$(cat PROMPT.md)")
    echo "$output" | tee output.txt
    if grep -q "&lt;promise&gt;COMPLETE&lt;/promise&gt;" output.txt; then
        echo "Completed at iteration $i"
        break
    fi
done</code></pre>
          </div>
        </div>
      </details>

      <details class="troubleshoot">
        <summary>Parallel Workers Conflict</summary>
        <div>
          <p><strong>Symptom:</strong> Merge conflicts, overwritten changes, race conditions</p>
          <p><strong>Cause:</strong> Parallel workers sharing mutable state (same branch, same files)</p>
          <p><strong>Fix:</strong> Use worktree isolation:</p>
          <div class="code-block">
            <button class="copy-btn" onclick="copyCode(this)">Copy</button>
            <pre><code># Create isolated worktrees for each worker
git worktree add ../worker-1 -b feature-auth
git worktree add ../worker-2 -b feature-payment
git worktree add ../worker-3 -b feature-notifications

# Workers operate in isolation
cd ../worker-1 &amp;&amp; claude "implement auth"
cd ../worker-2 &amp;&amp; claude "implement payment"
cd ../worker-3 &amp;&amp; claude "implement notifications"

# Merge sequentially at join point
git checkout main
git merge feature-auth
git merge feature-payment
git merge feature-notifications

# Cleanup
git worktree remove ../worker-1
git worktree remove ../worker-2
git worktree remove ../worker-3</code></pre>
          </div>
        </div>
      </details>

      <details class="troubleshoot">
        <summary>Orchestrator Doing Worker's Job</summary>
        <div>
          <p><strong>Symptom:</strong> Orchestrator context fills up, quality degrades, no task isolation</p>
          <p><strong>Cause:</strong> Orchestrator writing code instead of delegating to workers</p>
          <p><strong>Fix:</strong> Verify orchestrator tool usage:</p>
          <div class="code-block">
            <button class="copy-btn" onclick="copyCode(this)">Copy</button>
            <pre><code>ALLOWED for Orchestrators:
- Read (1-2 files max for orientation)
- Task, TaskCreate, TaskUpdate, TaskList, TaskGet
- AskUserQuestion

FORBIDDEN for Orchestrators:
- Write, Edit (code modification)
- Bash (command execution)
- Grep, Glob (extensive searching)

# If orchestrator needs to understand code, spawn a research subagent:
# Instead of:
orchestrator.read_many_files()  # Pollutes context

# Do this:
Task("Analyze the auth module and summarize key patterns")</code></pre>
          </div>
        </div>
      </details>

      <details class="troubleshoot">
        <summary>Quality Gate After Commit</summary>
        <div>
          <p><strong>Symptom:</strong> Bad code gets committed, requires manual revert</p>
          <p><strong>Cause:</strong> Gate ordering wrong - commit happens before verification</p>
          <p><strong>Fix:</strong> Always verify BEFORE commit:</p>
          <div class="code-block">
            <button class="copy-btn" onclick="copyCode(this)">Copy</button>
            <pre><code># WRONG order
git commit -m "feature"
npm test  # Too late!

# CORRECT order
npm run typecheck &amp;&amp; npm test &amp;&amp; npm run lint
if [ $? -eq 0 ]; then
    git commit -m "feature: verified"
else
    echo "Quality gate failed, not committing"
fi</code></pre>
          </div>
        </div>
      </details>

      <details class="troubleshoot">
        <summary>Sequential Chain Breaks Silently</summary>
        <div>
          <p><strong>Symptom:</strong> Later steps in sequence never run, no error visible</p>
          <p><strong>Cause:</strong> Using <code>;</code> instead of <code>&amp;&amp;</code>, or swallowing errors</p>
          <p><strong>Fix:</strong> Use explicit error handling:</p>
          <div class="code-block">
            <button class="copy-btn" onclick="copyCode(this)">Copy</button>
            <pre><code># Silent failure (bad)
task_a; task_b; task_c

# Explicit chaining (good)
task_a &amp;&amp; task_b &amp;&amp; task_c

# With error capture (better)
set -e  # Exit on any error
task_a
task_b
task_c</code></pre>
          </div>
        </div>
      </details>

      <details class="troubleshoot">
        <summary>Pattern Doesn't Fit Grammar</summary>
        <div>
          <p><strong>Symptom:</strong> Can't express your design using the composition operators</p>
          <p><strong>Cause:</strong> Either the pattern is invalid, or it needs decomposition</p>
          <p><strong>Fix:</strong></p>
          <div class="code-block">
            <button class="copy-btn" onclick="copyCode(this)">Copy</button>
            <pre><code># 1. Break pattern into smaller pieces:
# Too complex
ComplexPattern

# Decomposed
Part1 -> Part2 -> Part3
where Part2 = SubA || SubB

# 2. Check against the formal grammar (EBNF section)
# 3. If truly valid but not expressible, document as grammar extension candidate</code></pre>
          </div>
        </div>
      </details>
    </section>

    <hr class="section-divider">

    <!-- Related Pages -->
    <div class="related-pages">
      <h3>Related Pages</h3>
      <ul>
        <li><a href="grammar-vocabulary.html">Agent Pattern Vocabulary</a> - Core terms and definitions</li>
        <li><a href="grammar-plugins.html">Plugin & Extension Grammar</a> - How plugins extend vocabulary</li>
        <li><a href="compare-orchestration.html">Orchestration Approaches Compared</a> - Ralph, CC Mirror, Gas Town</li>
      </ul>
    </div>

    <!-- Footer Navigation -->
    <nav class="footer-nav">
      <a href="grammar-plugins.html" class="nav-prev">
        <span class="nav-direction">Previous</span>
        <span class="nav-title">Plugin & Extension Grammar</span>
      </a>
      <a href="grammar-vocabulary.html" class="nav-next">
        <span class="nav-direction">Next</span>
        <span class="nav-title">Agent Pattern Vocabulary</span>
      </a>
    </nav>

  </div>

  <script src="../js/search.js"></script>
  <script src="../js/sidebar.js"></script>
  <script src="../js/global-nav.js"></script>
  <script>
    function copyCode(button) {
      const codeBlock = button.parentElement.querySelector('code');
      navigator.clipboard.writeText(codeBlock.textContent);
      button.textContent = 'Copied!';
      button.classList.add('copied');
      setTimeout(() => {
        button.textContent = 'Copy';
        button.classList.remove('copied');
      }, 2000);
    }
  </script>
</body>
</html>
