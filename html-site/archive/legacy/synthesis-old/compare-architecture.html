<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta data-pagefind-meta="section" content="Synthesis">
  <meta data-pagefind-meta="category" content="Comparisons">
  <title>Agent Architecture Compared - Claude Code Knowledge Base</title>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="stylesheet" href="../css/sidebar.css">
  <link rel="stylesheet" href="../css/search.css">
</head>
<body>
  <!-- Search Modal -->
  <div class="search-modal" id="searchModal" aria-hidden="true">
    <div class="search-overlay" onclick="closeSearch()"></div>
    <div class="search-content">
      <div class="search-header">
        <div class="search-input-wrapper">
          <span class="search-icon-input">&#128269;</span>
          <input type="text" id="searchInput" placeholder="Search documentation..." autocomplete="off" />
          <kbd class="search-kbd">ESC</kbd>
        </div>
      </div>
      <div class="search-filters">
        <button class="filter-btn active" data-filter="all">All</button>
        <button class="filter-btn" data-filter="synthesis">Synthesis</button>
        <button class="filter-btn" data-filter="extractions">Extractions</button>
        <button class="filter-btn" data-filter="journeys">Journeys</button>
      </div>
      <div class="search-results" id="searchResults">
        <div class="search-empty"><p>Start typing to search... (Press Cmd+K anytime)</p></div>
      </div>
      <div class="search-footer">
        <span>Up/Down Navigate</span><span>Enter Select</span><span>ESC Close</span>
      </div>
    </div>
  </div>

  <button class="search-trigger" onclick="openSearch()" aria-label="Search" style="float: right; margin-bottom: 1rem;">
    <span class="search-icon">Cmd+K</span>
    <span class="search-text">Search</span>
  </button>

  <div class="wide-container">
    <!-- Breadcrumb Navigation -->
    <nav class="nav-breadcrumb">
      <a href="../index.html">Home</a>
      <span>/</span>
      <a href="synthesis-index.html">Synthesis</a>
      <span>/</span>
      <a href="compare-master.html">Comparisons</a>
      <span>/</span>
      <span>Architecture</span>
    </nav>

    <!-- You Are Here Context Box -->
    <div class="you-are-here" style="background: linear-gradient(135deg, #f0ebe3 0%, #fefcf3 100%); border-left: 4px solid #2a7d7d; border-radius: 8px; padding: 1.5rem; margin-bottom: 2rem;">
      <h3 style="color: #2a7d7d; margin-top: 0; font-size: 0.9em; text-transform: uppercase; letter-spacing: 0.5px;">You Are Here</h3>
      <p style="margin-bottom: 0;"><strong><span class="b">Ag</span>ent <span class="b">Arch</span>itecture <span class="b">Com</span>pared</strong> - A decision framework for choosing between four agent architectures (Single, Subagents, Swarm, Hierarchical) based on your project's scale, complexity, and budget. Use this when you know you need AI agents but are unsure which pattern fits your situation.</p>
    </div>

    <h1><span class="b">Ag</span>ent <span class="b">Arch</span>itecture <span class="b">Com</span>pared</h1>

    <!-- Table of Contents -->
    <div class="toc">
      <div class="toc-title">Contents</div>
      <ul>
        <li><a href="#the-same-goal">The Same Goal</a></li>
        <li><a href="#single-agent">Architecture 1: Single Agent</a></li>
        <li><a href="#subagents">Architecture 2: Subagents</a></li>
        <li><a href="#swarm">Architecture 3: Swarm (CC Mirror)</a></li>
        <li><a href="#hierarchical">Architecture 4: Hierarchical (Gas Town)</a></li>
        <li><a href="#comparison-matrix">Comparison Matrix</a></li>
        <li><a href="#selection-criteria">Selection Criteria</a></li>
        <li><a href="#decision-tree">Decision Tree</a></li>
        <li><a href="#migration-path">Migration Path</a></li>
        <li><a href="#troubleshooting">Troubleshooting</a></li>
      </ul>
    </div>

    <hr class="section-divider">

    <!-- The Same Goal -->
    <section id="the-same-goal">
      <h2><span class="b">The</span> Same <span class="b">Go</span>al</h2>

      <p><strong>Complete complex multi-part work.</strong></p>

      <p>Whether you are building a feature, shipping overnight, or running a development team simulation, all agent architectures aim to transform requirements into working code. The difference lies in how they distribute cognitive load, manage context, enable parallelism, and scale.</p>
    </section>

    <hr class="section-divider">

    <!-- Architecture 1: Single Agent -->
    <section id="single-agent">
      <h2><span class="b">Arch</span>itecture 1: <span class="b">Sin</span>gle Agent</h2>

      <h3>Structure</h3>
      <div class="ascii-diagram">
Human --> Agent --> Output
            |
            +---> Tools (Read, Write, Bash, etc.)</div>

      <p>The baseline. One conversation, one context window, one agent doing everything.</p>

      <h3>Pros</h3>
      <ul>
        <li><strong>Simple</strong> - No coordination overhead, no setup required</li>
        <li><strong>No coordination</strong> - No handoffs, no message passing, no sync issues</li>
        <li><strong>Fast for small tasks</strong> - Direct path from request to result</li>
        <li><strong>Full context awareness</strong> - Everything the agent learns stays in one place</li>
        <li><strong>Interactive</strong> - Human remains in the loop for real-time guidance</li>
      </ul>

      <h3>Cons</h3>
      <ul>
        <li><strong>Context limits</strong> - 128K-200K tokens, then you hit the wall</li>
        <li><strong>No parallelism</strong> - One thing at a time, sequentially</li>
        <li><strong>Jack of all trades</strong> - Same agent does architecture, coding, testing, docs</li>
        <li><strong>Human bottleneck</strong> - Requires your attention throughout</li>
        <li><strong>Context rot</strong> - Long sessions accumulate noise</li>
      </ul>

      <h3>Best For</h3>
      <ul>
        <li>Small, focused tasks (debugging, code review, exploratory work)</li>
        <li>Learning and experimentation</li>
        <li>Quick fixes and investigations</li>
        <li>Tasks completable in under an hour</li>
      </ul>

      <h3>Real-World Example</h3>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code>claude "Fix the null pointer exception in auth.py line 47"</code></pre>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Architecture 2: Subagents -->
    <section id="subagents">
      <h2><span class="b">Arch</span>itecture 2: <span class="b">Sub</span>agents</h2>

      <h3>Structure</h3>
      <div class="ascii-diagram">
Main Agent (maintains overall context)
|
+-- spawns --> Subagent A (research task)
|                   |
|                   +---> Returns summary
|
+-- spawns --> Subagent B (validation task)
                    |
                    +---> Returns result</div>

      <p>Parent agent stays strategic. Children handle tactical work in isolated contexts.</p>

      <h3>Pros</h3>
      <ul>
        <li><strong>Delegation</strong> - Offload work without losing main context</li>
        <li><strong>Specialization</strong> - Each subagent can have focused expertise</li>
        <li><strong>Still simple</strong> - No complex infrastructure, built into Claude Code</li>
        <li><strong>Context isolation</strong> - Research doesn't pollute main agent's memory</li>
        <li><strong>Summarized returns</strong> - Children return distilled results, not raw context</li>
      </ul>

      <h3>Cons</h3>
      <ul>
        <li><strong>Sequential</strong> - Subagents run one at a time (mostly)</li>
        <li><strong>Main context still fills</strong> - Parent accumulates summaries over time</li>
        <li><strong>Limited scale</strong> - 2-5 subagents practical, more becomes unwieldy</li>
        <li><strong>Spawn overhead</strong> - Each subagent takes time to initialize</li>
        <li><strong>Coordination on parent</strong> - Parent must manage all orchestration</li>
      </ul>

      <h3>Best For</h3>
      <ul>
        <li>Medium complexity projects</li>
        <li>Research that would pollute main context</li>
        <li>Adversarial validation (critic subagent challenges design)</li>
        <li>Exploratory work requiring multiple investigation threads</li>
      </ul>

      <h3>Real-World Example</h3>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code>Main Agent: "I need to implement authentication"

Spawns researcher: "Survey existing auth patterns in codebase"
                   --> Returns: "Using JWT with middleware pattern"

Spawns implementer: "Add OAuth2 support following JWT pattern"
                    --> Returns: "Implemented in /src/auth/oauth.py"

Spawns tester: "Verify OAuth2 implementation against security checklist"
               --> Returns: "7/8 checks pass, needs rate limiting"</code></pre>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Architecture 3: Swarm -->
    <section id="swarm">
      <h2><span class="b">Arch</span>itecture 3: <span class="b">Sw</span>arm (CC Mirror Pattern)</h2>

      <h3>Structure</h3>
      <div class="ascii-diagram">
            +---------------------+
            |    ORCHESTRATOR     |
            |    (Opus 4.5)       |
            |  NEVER writes code  |
            +----------+----------+
                       |
                       | Task(run_in_background=True)
                       |
       +---------------+---------------+
       |               |               |
       v               v               v
+----------+    +----------+    +----------+
| Worker 1 |    | Worker 2 |    | Worker 3 |
| (Sonnet) |    | (Sonnet) |    | (Haiku)  |
|  Coder   |    |  Tester  |    |   Docs   |
+----------+    +----------+    +----------+
  (parallel execution)</div>

      <p>Central orchestrator dispatches to specialized workers running in parallel.</p>

      <h3>Pros</h3>
      <ul>
        <li><strong>Full parallelism</strong> - Workers run simultaneously, not sequentially</li>
        <li><strong>Specialization</strong> - Each worker type tuned for its role</li>
        <li><strong>Scale</strong> - Can handle large features with many moving parts</li>
        <li><strong>Clear separation</strong> - Orchestrator coordinates, workers execute</li>
        <li><strong>Model efficiency</strong> - Use expensive models only where needed</li>
      </ul>

      <h3>Cons</h3>
      <ul>
        <li><strong>Coordination needed</strong> - Orchestrator must track all worker states</li>
        <li><strong>More setup</strong> - Requires CC Mirror or similar infrastructure</li>
        <li><strong>Orchestrator design</strong> - Getting the delegation strategy right takes work</li>
        <li><strong>Worker conflicts</strong> - Parallel workers may touch same files</li>
        <li><strong>Higher cost</strong> - Multiple parallel agents consume more tokens</li>
      </ul>

      <h3>The Iron Law</h3>
      <div class="callout callout-warning">
        <div class="callout-title">Critical Rule</div>
        <p><strong>An agent that ORCHESTRATES must NEVER directly EXECUTE.</strong><br>
        <strong>An agent that EXECUTES must NEVER directly ORCHESTRATE.</strong></p>
        <p>Mixing these roles causes:</p>
        <ul>
          <li>Context pollution (orchestrator loses strategic view)</li>
          <li>Verification bypass (same agent writes and approves)</li>
          <li>Uncontrolled recursion (workers spawning workers)</li>
        </ul>
      </div>

      <h3>Tool Ownership</h3>
      <div class="table-responsive">
        <table>
          <thead>
            <tr><th>Role</th><th>Tools Used</th><th>Tools NEVER Used</th></tr>
          </thead>
          <tbody>
            <tr><td><strong>Orchestrator</strong></td><td>Read (minimal), Task*, AskUser</td><td>Write, Edit, Bash, Glob, Grep</td></tr>
            <tr><td><strong>Worker</strong></td><td>Read, Write, Edit, Bash, Glob, Grep</td><td>Task*, sub-spawning</td></tr>
          </tbody>
        </table>
      </div>

      <h3>Best For</h3>
      <ul>
        <li>Large features requiring multiple specialists</li>
        <li>Team project simulation</li>
        <li>Parallel feature development</li>
        <li>Situations where time-to-completion matters more than cost</li>
      </ul>
    </section>

    <hr class="section-divider">

    <!-- Architecture 4: Hierarchical -->
    <section id="hierarchical">
      <h2><span class="b">Arch</span>itecture 4: <span class="b">Hier</span>archical (Gas Town Model)</h2>

      <h3>Structure</h3>
      <div class="ascii-diagram">
                    +-------------+
                    |  OVERSEER   |  <-- Human (inbox-based)
                    |    (YOU)    |
                    +------+------+
                           |
                    +------+------+
                    |    MAYOR    |  <-- Town coordination
                    +------+------+
                           |
     +---------------------+---------------------+
     |           |           |           |       |
+--------+ +----------+ +--------+ +--------+ +--------+
| DEACON | | REFINERY | |  DOGS  | | POLECAT| | WITNESS|
|(quality)| | (planning)| | (code) | | (test) | |(monitor)|
+--------+ +----------+ +--------+ +--------+ +--------+
     |                       |           |
     v                       v           v
+--------+              +---------+ +---------+
|  CREW  |              | Polecat | | Polecat |
|(ephemeral)            |  Alpha  | |  Beta   |
+--------+              +---------+ +---------+</div>

      <p>Full "agent town" with named persistent workers, ephemeral crews, and specialized roles.</p>

      <h3>The 7 Specialized Roles</h3>
      <div class="table-responsive">
        <table>
          <thead>
            <tr><th>Role</th><th>Function</th><th>Persistence</th></tr>
          </thead>
          <tbody>
            <tr><td><strong>Mayor</strong></td><td>Town-level coordination, resource allocation</td><td>Persistent</td></tr>
            <tr><td><strong>Deacon</strong></td><td>Monitoring, health checks, handshakes between agents</td><td>Persistent</td></tr>
            <tr><td><strong>Dogs</strong></td><td>Quality gates, watchdogs, enforcement</td><td>Persistent</td></tr>
            <tr><td><strong>Refinery</strong></td><td>Task decomposition, story breakdown</td><td>On-demand</td></tr>
            <tr><td><strong>Polecat</strong></td><td>Named persistent workers with specific expertise</td><td>Persistent</td></tr>
            <tr><td><strong>Crew</strong></td><td>Ephemeral workers for one-off tasks</td><td>Ephemeral</td></tr>
            <tr><td><strong>Witness</strong></td><td>Per-rig observer, audit trail</td><td>Persistent</td></tr>
          </tbody>
        </table>
      </div>

      <h3>Pros</h3>
      <ul>
        <li><strong>Maximum specialization</strong> - Each role has deep expertise in its domain</li>
        <li><strong>Clear roles</strong> - No ambiguity about who does what</li>
        <li><strong>Self-improving</strong> - Built-in quality gates and monitoring</li>
        <li><strong>Production ready</strong> - Designed for real enterprise deployment</li>
        <li><strong>Persistent memory</strong> - Named workers accumulate expertise over time</li>
        <li><strong>Human as inbox</strong> - Async communication, not blocking</li>
      </ul>

      <h3>Cons</h3>
      <ul>
        <li><strong>Complex setup</strong> - Significant infrastructure investment</li>
        <li><strong>High overhead</strong> - Many moving parts to configure and maintain</li>
        <li><strong>Needs scale</strong> - Overkill for small projects</li>
        <li><strong>Budget intensive</strong> - Multiple persistent agents running</li>
        <li><strong>Steep learning curve</strong> - Philosophy + tools + configuration</li>
        <li><strong>tmux expertise required</strong> - Managing multiple terminal sessions</li>
      </ul>

      <h3>Best For</h3>
      <ul>
        <li>Production systems at enterprise scale</li>
        <li>Teams running 10+ parallel agents</li>
        <li>Continuous development operations</li>
        <li>Organizations ready for "agent village" paradigm</li>
      </ul>

      <blockquote>
        <p>"You just make up features, design them, file the implementation plans, and sling work around to your polecats and crew."</p>
        <cite>-- Steve Yegge</cite>
      </blockquote>

      <h3>Prerequisites</h3>
      <ul>
        <li>Stage 7+ in Claude Code evolution (comfortable with 10+ agents)</li>
        <li>Significant budget (multiple Claude accounts)</li>
        <li>Comfort with chaos</li>
        <li>tmux mastery</li>
        <li>Willingness to invest in the ecosystem</li>
      </ul>
    </section>

    <hr class="section-divider">

    <!-- Comparison Matrix -->
    <section id="comparison-matrix">
      <h2><span class="b">Com</span>parison <span class="b">Mat</span>rix</h2>

      <div class="table-responsive">
        <table class="comparison-table">
          <thead>
            <tr>
              <th>Factor</th>
              <th>Single</th>
              <th>Subagents</th>
              <th>Swarm</th>
              <th>Hierarchical</th>
            </tr>
          </thead>
          <tbody>
            <tr><td><strong>Complexity</strong></td><td>Low</td><td>Medium</td><td>Medium</td><td>High</td></tr>
            <tr><td><strong>Parallelism</strong></td><td>None</td><td>Limited</td><td>Full</td><td>Full</td></tr>
            <tr><td><strong>Specialization</strong></td><td>None</td><td>Some</td><td>Good</td><td>Maximum</td></tr>
            <tr><td><strong>Scale</strong></td><td>Small</td><td>Medium</td><td>Large</td><td>Enterprise</td></tr>
            <tr><td><strong>Setup Time</strong></td><td>Zero</td><td>Minutes</td><td>Hours</td><td>Days</td></tr>
            <tr><td><strong>Cost</strong></td><td>$</td><td>$$</td><td>$$$</td><td>$$$$</td></tr>
            <tr><td><strong>Human Involvement</strong></td><td>High</td><td>Medium</td><td>Low</td><td>Async</td></tr>
            <tr><td><strong>Context Isolation</strong></td><td>None</td><td>Per-subagent</td><td>Per-worker</td><td>Per-role</td></tr>
            <tr><td><strong>Failure Recovery</strong></td><td>Manual</td><td>Parent retries</td><td>Orchestrator manages</td><td>Self-healing</td></tr>
            <tr><td><strong>Debugging</strong></td><td>Easy</td><td>Medium</td><td>Hard</td><td>Complex</td></tr>
          </tbody>
        </table>
      </div>

      <h3>Extended Comparison</h3>
      <div class="table-responsive">
        <table>
          <thead>
            <tr>
              <th>Dimension</th>
              <th>Single</th>
              <th>Subagents</th>
              <th>Swarm</th>
              <th>Hierarchical</th>
            </tr>
          </thead>
          <tbody>
            <tr><td><strong>Context Window</strong></td><td>Shared</td><td>Isolated returns</td><td>Isolated workers</td><td>Fully isolated</td></tr>
            <tr><td><strong>Model Selection</strong></td><td>Fixed</td><td>Can vary</td><td>Role-based</td><td>Role + tier</td></tr>
            <tr><td><strong>Coordination</strong></td><td>N/A</td><td>Parent-child</td><td>Hub-and-spoke</td><td>Multi-level</td></tr>
            <tr><td><strong>Persistence</strong></td><td>Session</td><td>Session</td><td>Task-based</td><td>Named agents</td></tr>
            <tr><td><strong>Conflict Handling</strong></td><td>N/A</td><td>Sequential</td><td>Orchestrator</td><td>Specialized roles</td></tr>
            <tr><td><strong>Quality Gates</strong></td><td>Manual</td><td>Ad-hoc</td><td>Can include</td><td>Built-in (Dogs)</td></tr>
          </tbody>
        </table>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Selection Criteria -->
    <section id="selection-criteria">
      <h2><span class="b">Sel</span>ection <span class="b">Crit</span>eria</h2>

      <h3>Choose Single Agent When:</h3>
      <ul>
        <li>Task completable in one session (under 2 hours)</li>
        <li>No need for parallel work</li>
        <li>Exploring or debugging</li>
        <li>Learning the codebase</li>
        <li>Quick fixes and investigations</li>
      </ul>

      <h3>Choose Subagents When:</h3>
      <ul>
        <li>Need isolated research/exploration</li>
        <li>Want adversarial validation</li>
        <li>Main context getting polluted</li>
        <li>2-5 distinct subtasks</li>
        <li>Medium complexity, single session</li>
      </ul>

      <h3>Choose Swarm When:</h3>
      <ul>
        <li>Parallel work needed for speed</li>
        <li>Different specialists required (coder, tester, docs)</li>
        <li>Large feature with multiple components</li>
        <li>Team simulation beneficial</li>
        <li>Budget allows higher token consumption</li>
      </ul>

      <h3>Choose Hierarchical When:</h3>
      <ul>
        <li>Running 10+ agents regularly</li>
        <li>Production system requiring quality gates</li>
        <li>Continuous development operations</li>
        <li>Ready for significant infrastructure investment</li>
        <li>Need persistent agent memory across sessions</li>
        <li>Want async human-agent interaction</li>
      </ul>
    </section>

    <hr class="section-divider">

    <!-- Decision Tree -->
    <section id="decision-tree">
      <h2><span class="b">Dec</span>ision <span class="b">Tr</span>ee</h2>

      <div class="ascii-diagram">
START: "I need agents to complete complex work"
  |
  +-- How long will it take?
  |     |
  |     +-- < 2 hours --> SINGLE AGENT
  |     |
  |     +-- 2-8 hours --> Continue...
  |     |
  |     +-- Overnight/days --> Continue...
  |
  +-- Need parallel execution?
  |     |
  |     +-- No, sequential is fine --> SUBAGENTS
  |     |
  |     +-- Yes, speed matters --> Continue...
  |
  +-- How many specialists needed?
  |     |
  |     +-- 2-5 workers --> SWARM (CC Mirror)
  |     |
  |     +-- 7+ roles --> Continue...
  |
  +-- Production scale? Quality gates?
        |
        +-- No --> SWARM (simpler)
        |
        +-- Yes --> HIERARCHICAL (Gas Town)</div>
    </section>

    <hr class="section-divider">

    <!-- Checkpoint -->
    <div class="checkpoint" style="background: #f0ebe3; border-left: 4px solid #6b9b7a; border-radius: 8px; padding: 1.5rem; margin: 2rem 0;">
      <div class="checkpoint-header" style="color: #6b9b7a; font-weight: 600;">Checkpoint: Architecture Selection</div>
      <p><strong>You should now understand:</strong></p>
      <ul>
        <li>The four main architectures and their characteristics</li>
        <li>When to use each architecture based on project needs</li>
        <li>The Iron Law of orchestration (orchestrate vs execute)</li>
        <li>Tool ownership rules for orchestrators vs workers</li>
      </ul>
      <p><strong>If unclear:</strong> Re-read the "Best For" sections under each architecture or use the Decision Tree above.</p>
    </div>

    <hr class="section-divider">

    <!-- Migration Path -->
    <section id="migration-path">
      <h2><span class="b">Mig</span>ration <span class="b">Pa</span>th</h2>

      <div class="ascii-diagram">
SINGLE --> SUBAGENTS --> SWARM --> HIERARCHICAL
  |            |            |            |
  |  "I need   |  "Need     |  "Running  |
  |  to offload|  parallel  |  10+ agents|
  |  research" |  workers"  |  daily"    |
  |            |            |            |
  v            v            v            v
 Hours       Hours-Days    Days       Weeks</div>

      <p>Most users should start at Single, graduate to Subagents, and only move to Swarm when parallelism becomes essential. Hierarchical is for organizations, not individuals.</p>

      <h3>Quick Reference</h3>
      <div class="table-responsive">
        <table>
          <thead>
            <tr><th>Architecture</th><th>Best Example</th><th>Key Command/Pattern</th></tr>
          </thead>
          <tbody>
            <tr><td><strong>Single</strong></td><td>Debug session</td><td><code>claude "fix bug in auth.py"</code></td></tr>
            <tr><td><strong>Subagents</strong></td><td>Research + implement</td><td><code>Task(subagent_type="researcher")</code></td></tr>
            <tr><td><strong>Swarm</strong></td><td>Feature development</td><td>CC Mirror orchestrator pattern</td></tr>
            <tr><td><strong>Hierarchical</strong></td><td>Production ops</td><td>Gas Town with full role cast</td></tr>
          </tbody>
        </table>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Troubleshooting -->
    <section id="troubleshooting">
      <h2><span class="b">Trou</span>bleshooting</h2>

      <details class="troubleshoot">
        <summary>Context Window Exhaustion (Single Agent)</summary>
        <div>
          <p><strong>Symptom:</strong> Claude starts forgetting instructions, repeating itself, or producing lower-quality output mid-session.</p>
          <p><strong>Cause:</strong> Single agent has accumulated too much context (typically > 150K tokens).</p>
          <p><strong>Fix:</strong> Either use <code>/compact</code> to summarize context, start a fresh session, or migrate to subagents to isolate work.</p>
        </div>
      </details>

      <details class="troubleshoot">
        <summary>Subagent Spawn Overhead</summary>
        <div>
          <p><strong>Symptom:</strong> Tasks take much longer than expected; lots of "starting subagent" messages.</p>
          <p><strong>Cause:</strong> Too many subagents being spawned for small tasks (each spawn has initialization cost).</p>
          <p><strong>Fix:</strong> Batch small tasks together or complete them in the main agent. Reserve subagents for substantial work (> 5-10 minute tasks).</p>
        </div>
      </details>

      <details class="troubleshoot">
        <summary>Worker Conflicts in Swarm</summary>
        <div>
          <p><strong>Symptom:</strong> Multiple workers editing the same files; merge conflicts; inconsistent code state.</p>
          <p><strong>Cause:</strong> Parallel workers assigned overlapping file domains without coordination.</p>
          <p><strong>Fix:</strong> Ensure orchestrator assigns non-overlapping file boundaries to each worker. Use git worktrees for full isolation if needed.</p>
        </div>
      </details>

      <details class="troubleshoot">
        <summary>Gas Town Runaway Costs</summary>
        <div>
          <p><strong>Symptom:</strong> API costs spike dramatically; many agents running but little progress.</p>
          <p><strong>Cause:</strong> Workers spawning sub-workers (violates Iron Law), or inefficient task decomposition.</p>
          <p><strong>Fix:</strong> Audit worker preambles to ensure "DO NOT spawn sub-agents" rule. Check Refinery task sizing. Consider starting with minimal Gas Town before scaling.</p>
        </div>
      </details>

      <details class="troubleshoot">
        <summary>Architecture Over-Engineering</summary>
        <div>
          <p><strong>Symptom:</strong> Spending more time configuring multi-agent systems than doing actual work.</p>
          <p><strong>Cause:</strong> Chose hierarchical architecture for a task that only needed single agent or subagents.</p>
          <p><strong>Fix:</strong> Start simple. Only upgrade architecture when the simpler approach demonstrably fails. Most tasks can be done with single agent or basic subagents.</p>
        </div>
      </details>
    </section>

    <hr class="section-divider">

    <!-- Related Pages -->
    <div class="related-pages">
      <h3>Related Pages</h3>
      <ul>
        <li><a href="compare-orchestration.html">Orchestration Approaches Compared</a> - Compare Ralph, PRD-Ralph, CC Mirror, Gas Town</li>
        <li><a href="compare-memory.html">Memory Approaches Compared</a> - progress.txt, Git, AGENTS.md, Claude-Mem</li>
        <li><a href="../journeys/architecture/core-patterns.html">Core Patterns Journey</a> - Guided learning path</li>
      </ul>
    </div>

    <!-- Footer Navigation -->
    <nav class="footer-nav">
      <a href="compare-master.html" class="nav-prev">
        <span class="nav-direction">Previous</span>
        <span class="nav-title">Comparisons Index</span>
      </a>
      <a href="compare-orchestration.html" class="nav-next">
        <span class="nav-direction">Next</span>
        <span class="nav-title">Orchestration Compared</span>
      </a>
    </nav>

  </div>

  <nav class="left-nav" id="leftNav">
    <div class="px-4 mb-4">
      <a href="../index.html" class="text-xs font-semibold text-accent hover:text-accent-light uppercase tracking-wider">Claude Code KB</a>
    </div>
    <div class="nav-content"></div>
  </nav>

  <script src="../js/search.js"></script>
  <script src="../js/sidebar.js"></script>
  <script src="../js/global-nav.js"></script>
  <script>
    function copyCode(button) {
      const codeBlock = button.parentElement.querySelector('code');
      navigator.clipboard.writeText(codeBlock.textContent);
      button.textContent = 'Copied!';
      button.classList.add('copied');
      setTimeout(() => {
        button.textContent = 'Copy';
        button.classList.remove('copied');
      }, 2000);
    }
  </script>
</body>
</html>
