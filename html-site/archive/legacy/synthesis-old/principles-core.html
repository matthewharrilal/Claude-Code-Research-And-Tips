<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta data-pagefind-meta="section" content="Synthesis">
  <meta data-pagefind-meta="category" content="Principles">
  <title>Core Principles of Agent Engineering - Claude Code Knowledge Base</title>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="stylesheet" href="../css/sidebar.css">
  <link rel="stylesheet" href="../css/search.css">
</head>
<body>
  <!-- Search Modal -->
  <div class="search-modal" id="searchModal" aria-hidden="true">
    <div class="search-overlay" onclick="closeSearch()"></div>
    <div class="search-content">
      <div class="search-header">
        <div class="search-input-wrapper">
          <span class="search-icon-input">&#128269;</span>
          <input type="text" id="searchInput" placeholder="Search documentation..." autocomplete="off" />
          <kbd class="search-kbd">ESC</kbd>
        </div>
      </div>
      <div class="search-filters">
        <button class="filter-btn active" data-filter="all">All</button>
        <button class="filter-btn" data-filter="synthesis">Synthesis</button>
        <button class="filter-btn" data-filter="extractions">Extractions</button>
      </div>
      <div class="search-results" id="searchResults">
        <div class="search-empty"><p>Start typing to search... (Press Cmd+K anytime)</p></div>
      </div>
      <div class="search-footer">
        <span>Up/Down Navigate</span><span>Enter Select</span><span>ESC Close</span>
      </div>
    </div>
  </div>

  <button class="search-trigger" onclick="openSearch()" aria-label="Search" style="float: right; margin-bottom: 1rem;">
    <span class="search-icon">Cmd+K</span>
    <span class="search-text">Search</span>
  </button>

  <nav class="left-nav" id="leftNav">
    <div class="px-4 mb-4">
      <a href="../index.html" class="text-xs font-semibold text-accent hover:text-accent-light uppercase tracking-wider">Claude Code KB</a>
    </div>
    <div class="nav-content"></div>
  </nav>

  <div class="container">
    <!-- Breadcrumb Navigation -->
    <nav class="nav-breadcrumb">
      <a href="../index.html">Home</a>
      <span>/</span>
      <a href="synthesis-index.html">Synthesis</a>
      <span>/</span>
      <a href="principles-master.html">Principles</a>
      <span>/</span>
      <span>Core Principles</span>
    </nav>

    <!-- You Are Here Context Box -->
    <div class="you-are-here" style="background: linear-gradient(135deg, #f0ebe3 0%, #fefcf3 100%); border-left: 4px solid #2a7d7d; border-radius: 8px; padding: 1.5rem; margin-bottom: 2rem;">
      <h3 style="color: #2a7d7d; margin-top: 0; font-size: 0.9em; text-transform: uppercase; letter-spacing: 0.5px;">You Are Here</h3>
      <p style="margin-bottom: 0;">This is the <strong>philosophical foundation</strong> - the 8 core principles that explain WHY every Claude Code pattern works the way it does. Read this before trying to understand specific patterns, and return here when patterns fail to understand what went wrong. This is the "physics" from which all "engineering" derives.</p>
    </div>

    <h1><span class="bionic">Pri</span>nciples of <span class="bionic">Age</span>nt <span class="bionic">Eng</span>ineering</h1>

    <p class="conversational-lead">
      The <span class="bionic">fun</span>damental WHYs behind every pattern in Claude Code agent engineering. These principles are the bedrock from which all patterns derive. Understanding them enables you to create new patterns, adapt existing ones, and diagnose failures.
    </p>

    <!-- Table of Contents -->
    <div class="toc">
      <div class="toc-title">Contents</div>
      <ul>
        <li><a href="#principle-hierarchy">The Principle Hierarchy</a></li>
        <li><a href="#principle-1">Principle 1: Context Is The Primary Constraint</a></li>
        <li><a href="#principle-2">Principle 2: External State &gt; Internal Memory</a></li>
        <li><a href="#principle-3">Principle 3: Fresh Context &gt; Extended Sessions</a></li>
        <li><a href="#principle-4">Principle 4: Separation of Concerns</a></li>
        <li><a href="#principle-5">Principle 5: Atomic, Verifiable Task Sizing</a></li>
        <li><a href="#principle-6">Principle 6: Quality Gates Before Commit</a></li>
        <li><a href="#principle-7">Principle 7: Isolation Prevents Contamination</a></li>
        <li><a href="#principle-8">Principle 8: Explicit Communication Over Implicit</a></li>
        <li><a href="#derivation">Deriving New Patterns from Principles</a></li>
        <li><a href="#quick-reference">Quick Reference</a></li>
        <li><a href="#troubleshooting">Troubleshooting</a></li>
      </ul>
    </div>

    <hr class="section-divider">

    <!-- Principle Hierarchy -->
    <section id="principle-hierarchy">
      <h2>The <span class="bionic">Pri</span>nciple <span class="bionic">Hie</span>rarchy</h2>

      <p>Before diving into individual principles, understand their relationship:</p>

      <div class="ascii-diagram">
                    +----------------------------------+
                    |  PRINCIPLE 1: CONTEXT IS FINITE  |
                    |  (The Primary Constraint)        |
                    +----------------+-----------------+
                                     |
              Everything flows from this limitation
                                     |
        +----------------------------+----------------------------+
        |                            |                            |
        v                            v                            v
+-------------------+    +-------------------+    +-------------------+
| PRINCIPLE 2:      |    | PRINCIPLE 3:      |    | PRINCIPLE 4:      |
| External State    |    | Fresh Context     |    | Separation of     |
| > Internal Memory |    | > Extended        |    | Concerns          |
|                   |    |   Sessions        |    | (Orch/Worker)     |
+---------+---------+    +---------+---------+    +---------+---------+
          |                        |                        |
          +------------------------+------------------------+
                                   |
                      +------------+------------+
                      |                         |
                      v                         v
            +-------------------+    +-------------------+
            | PRINCIPLE 5:      |    | PRINCIPLE 6:      |
            | Atomic, Verifiable|    | Quality Gates     |
            | Task Sizing       |    | Before Commit     |
            +-------------------+    +-------------------+
      </div>
    </section>

    <hr class="section-divider">

    <!-- Principle 1 -->
    <section id="principle-1">
      <h2><span class="bionic">Pri</span>nciple 1: <span class="bionic">Con</span>text Is The <span class="bionic">Pri</span>mary <span class="bionic">Con</span>straint</h2>

      <h3>The WHY</h3>
      <p><strong>LLMs degrade with filled context windows.</strong> This is not a minor inconvenience - it is the fundamental constraint that shapes all agent engineering patterns.</p>

      <blockquote>
        <p>"Context rot: LLMs get stupider with more tokens"</p>
        <cite>-- @mattpocockuk</cite>
      </blockquote>

      <p>Claude's context window (~200K tokens nominal, ~100K effective for quality work) is a hard ceiling. As tokens accumulate:</p>

      <div class="table-responsive">
        <table>
          <thead>
            <tr><th>Context Level</th><th>Quality Impact</th></tr>
          </thead>
          <tbody>
            <tr><td>0-50%</td><td>Full capability</td></tr>
            <tr><td>50-70%</td><td>Slight degradation possible</td></tr>
            <tr><td>70-85%</td><td>Noticeable quality loss</td></tr>
            <tr><td>85-95%</td><td>Significant degradation, instructions forgotten</td></tr>
            <tr><td>95%+</td><td>Failure mode - hallucinations, contradictions, amnesia</td></tr>
          </tbody>
        </table>
      </div>

      <h3>What Context Rot Looks Like</h3>
      <ol>
        <li><strong>Repetition</strong> - Claude starts repeating earlier statements</li>
        <li><strong>Amnesia</strong> - Forgets work done 10 minutes ago</li>
        <li><strong>Instruction Drift</strong> - CLAUDE.md directives ignored</li>
        <li><strong>Truncation</strong> - Code cut off mid-function</li>
        <li><strong>Hallucination</strong> - References files that don't exist</li>
        <li><strong>False Completion</strong> - Marks tasks done without verification</li>
      </ol>

      <h3>Implications</h3>
      <p>Every pattern, every tool, every workflow decision must answer: <strong>"How does this affect context consumption?"</strong></p>
      <ul>
        <li>If it consumes context, is the benefit worth it?</li>
        <li>If it persists across iterations, should it?</li>
        <li>If it compounds (grows over time), how do we bound it?</li>
      </ul>

      <h3>Derived Patterns</h3>
      <div class="table-responsive">
        <table>
          <thead>
            <tr><th>Pattern</th><th>How It Addresses Context</th></tr>
          </thead>
          <tbody>
            <tr><td>Ralph Loops (fresh context)</td><td>Kill and restart - zero accumulation</td></tr>
            <tr><td>File-based state</td><td>Externalize - don't store in context</td></tr>
            <tr><td>Git as memory</td><td>History lives outside context</td></tr>
            <tr><td>Subagent delegation</td><td>Expensive ops in isolated contexts</td></tr>
            <tr><td>.claudeignore</td><td>Prevent irrelevant files from loading</td></tr>
            <tr><td>CLAUDE.md brevity</td><td>Fixed context cost, minimize it</td></tr>
            <tr><td>Task sizing</td><td>Complete before overflow</td></tr>
            <tr><td>Compaction</td><td>Emergency pressure release</td></tr>
          </tbody>
        </table>
      </div>

      <div class="callout callout-insight">
        <div class="callout-title">Core Insight</div>
        <p><strong>"Memory is external. The agent is stateless."</strong> -- Ryan Carson</p>
        <p>This isn't a bug. It's the architecture that enables reliability. Fighting it leads to failure; embracing it leads to robust systems.</p>
      </div>

      <!-- Checkpoint -->
      <div class="checkpoint" style="background: #f0ebe3; border-left: 4px solid #6b9b7a; border-radius: 8px; padding: 1.5rem; margin: 2rem 0;">
        <div class="checkpoint-header" style="color: #6b9b7a; font-weight: 600;">Checkpoint: Principle 1</div>
        <p><strong>You should now understand:</strong></p>
        <ul>
          <li>Why context windows have effective limits (~100K for quality work)</li>
          <li>The 6 symptoms of context rot (repetition, amnesia, instruction drift, etc.)</li>
          <li>How every pattern must answer "how does this affect context consumption?"</li>
          <li>Why memory must be external, not internal</li>
        </ul>
        <p><strong>If unclear:</strong> See <a href="principles-anti-patterns.html">Anti-Patterns</a> Section "Context Anti-Patterns" for detailed failure examples.</p>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Principle 2 -->
    <section id="principle-2">
      <h2><span class="bionic">Pri</span>nciple 2: <span class="bionic">Ext</span>ernal <span class="bionic">Sta</span>te &gt; <span class="bionic">Int</span>ernal <span class="bionic">Mem</span>ory</h2>

      <h3>The WHY</h3>
      <p><strong>Sessions end. Context clears. Memory evaporates.</strong> Any information stored only in the LLM's context will be lost when:</p>
      <ul>
        <li>The session ends normally</li>
        <li>Context window fills and forces reset</li>
        <li>An error crashes the session</li>
        <li>The user starts fresh</li>
      </ul>

      <p><strong>Therefore:</strong> All state that must persist beyond a single operation must be externalized to durable storage.</p>

      <h3>The Fundamental Architecture</h3>
      <div class="ascii-diagram">
+-------------------------------------------------------------+
|                    THE AGENT                                |
|  +-------------------------------------------------------+  |
|  |                CONTEXT WINDOW                         |  |
|  |                                                       |  |
|  |   [Ephemeral: dies when session ends]                 |  |
|  |   - Current reasoning                                 |  |
|  |   - Active task details                               |  |
|  |   - Recent tool outputs                               |  |
|  |                                                       |  |
|  +-------------------------------------------------------+  |
+-------------------------------------------------------------+
                           |
                    Read / Write
                           |
+-------------------------------------------------------------+
|                 EXTERNAL STATE                              |
|  +---------------+  +---------------+  +-------------+      |
|  |   FILESYSTEM  |  |      GIT      |  |  DATABASE   |      |
|  |               |  |               |  |             |      |
|  | progress.txt  |  | Commits       |  | claude-mem  |      |
|  | prd.json      |  | Branches      |  | SQLite      |      |
|  | CLAUDE.md     |  | History       |  | Checkpoints |      |
|  | handoffs/     |  | Diffs         |  |             |      |
|  |               |  |               |  |             |      |
|  +---------------+  +---------------+  +-------------+      |
|                                                             |
|  [Persistent: survives sessions, crashes, resets]           |
+-------------------------------------------------------------+
      </div>

      <h3>The Three Core Files Pattern</h3>
      <div class="table-responsive">
        <table>
          <thead>
            <tr><th>File</th><th>Purpose</th><th>Format</th><th>Rule</th></tr>
          </thead>
          <tbody>
            <tr><td><code>progress.txt</code></td><td>Memory across iterations</td><td>Markdown</td><td>APPEND ONLY - never edit</td></tr>
            <tr><td><code>prd.json</code></td><td>Task state tracking</td><td>JSON</td><td>Machine-readable, <code>passes: true/false</code></td></tr>
            <tr><td><code>CLAUDE.md</code></td><td>Project context</td><td>Markdown</td><td>Under 500 tokens, essential info only</td></tr>
          </tbody>
        </table>
      </div>

      <h3>The Anti-Pattern</h3>
      <p><strong>Extended sessions</strong> that rely on in-context memory for continuity. The longer the session, the more accumulated context, the worse the performance. Even "successful" long sessions degrade imperceptibly until failure.</p>

      <blockquote>
        <p>"Each iteration spawns a NEW Amp instance with NO memory of previous work. Continuity comes from: Git history, prd.json, progress.txt"</p>
        <cite>-- Ryan Carson</cite>
      </blockquote>

      <!-- Checkpoint -->
      <div class="checkpoint" style="background: #f0ebe3; border-left: 4px solid #6b9b7a; border-radius: 8px; padding: 1.5rem; margin: 2rem 0;">
        <div class="checkpoint-header" style="color: #6b9b7a; font-weight: 600;">Checkpoint: Principle 2</div>
        <p><strong>You should now understand:</strong></p>
        <ul>
          <li>The three core files pattern: progress.txt, prd.json, CLAUDE.md</li>
          <li>Why git commits are a form of external memory</li>
          <li>The architecture diagram of ephemeral context vs. persistent external state</li>
          <li>That compaction is lossy, but file storage is not</li>
        </ul>
        <p><strong>If unclear:</strong> See <a href="architecture-primitives.html">Architecture Primitives</a> for detailed file format specifications.</p>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Principle 3 -->
    <section id="principle-3">
      <h2><span class="bionic">Pri</span>nciple 3: <span class="bionic">Fre</span>sh <span class="bionic">Con</span>text &gt; <span class="bionic">Ext</span>ended <span class="bionic">Ses</span>sions</h2>

      <h3>The WHY</h3>
      <p><strong>Context accumulation is entropy.</strong> Every operation adds tokens. Every token added slightly degrades future operations. This compounds over time until quality collapse.</p>
      <p><strong>Fresh context is regeneration.</strong> A new instance starts at 0% context usage, at peak capability. There is no accumulated noise, no degraded performance, no risk of context rot.</p>

      <h3>The Mathematical Reality</h3>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code>Extended Session Quality:
Q(t) = Q_max * decay(context_usage(t))

Fresh Context Quality:
Q(t) = Q_max  (constant per iteration)</code></pre>
      </div>

      <p>Extended sessions guarantee degradation. Fresh context guarantees consistent quality.</p>

      <h3>The Fresh Context Pattern</h3>
      <div class="ascii-diagram">
+-------------------------------------------------------------+
|  Iteration 1 (fresh Claude instance)                        |
|  -> Read state from files (PRD, progress, git)              |
|  -> Pick highest priority incomplete task                   |
|  -> Implement + verify                                      |
|  -> Commit if passing                                       |
|  -> Update external state                                   |
|  -> Exit                                                    |
+-------------------------------------------------------------+
              | (no memory carried forward)
+-------------------------------------------------------------+
|  Iteration 2 (fresh Claude instance)                        |
|  -> Read state from files (now updated)                     |
|  -> Repeat...                                               |
+-------------------------------------------------------------+
      </div>

      <h3>Why Not Compaction?</h3>
      <p><strong>Compaction is lossy.</strong> When you compact, you summarize. When you summarize, you lose detail. Lost detail can mean:</p>
      <ul>
        <li>Forgotten edge cases</li>
        <li>Missed requirements</li>
        <li>Lost context on decisions</li>
      </ul>
      <p><strong>Fresh context is lossless.</strong> Files preserve full detail. Git preserves full history. Nothing is summarized away.</p>

      <h3>When Extended Sessions Are Acceptable</h3>
      <p>Only for:</p>
      <ul>
        <li>Single, small tasks (&lt; 30 min)</li>
        <li>Exploratory work where loss is acceptable</li>
        <li>Debugging where context accumulation aids investigation</li>
      </ul>
      <p>Even then, monitor context usage and reset before 70%.</p>

      <!-- Checkpoint -->
      <div class="checkpoint" style="background: #f0ebe3; border-left: 4px solid #6b9b7a; border-radius: 8px; padding: 1.5rem; margin: 2rem 0;">
        <div class="checkpoint-header" style="color: #6b9b7a; font-weight: 600;">Checkpoint: Principle 3</div>
        <p><strong>You should now understand:</strong></p>
        <ul>
          <li>The mathematical reality: extended sessions degrade, fresh context is constant quality</li>
          <li>Why compaction is lossy but fresh context with file state is lossless</li>
          <li>The fresh context pattern: read state, work, write state, exit</li>
          <li>When extended sessions are acceptable (single small tasks, exploratory work)</li>
        </ul>
        <p><strong>If unclear:</strong> See <a href="principles-learning-loops.html">Learning Loops</a> for how to maintain continuity across fresh contexts.</p>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Principle 4 -->
    <section id="principle-4">
      <h2><span class="bionic">Pri</span>nciple 4: <span class="bionic">Sep</span>aration of <span class="bionic">Con</span>cerns</h2>

      <h3>The WHY</h3>
      <p><strong>Mixing coordination with execution causes two failures:</strong></p>
      <ol>
        <li><strong>Context pollution</strong> - The orchestrator fills its context with execution details it doesn't need</li>
        <li><strong>Role confusion</strong> - The agent oscillates between planning and doing, doing neither well</li>
      </ol>

      <blockquote>
        <p>"YOU DO NOT WRITE CODE. YOU DO NOT RUN COMMANDS. YOU DO NOT EXPLORE CODEBASES. You are the CONDUCTOR. Your agents play the instruments."</p>
        <cite>-- @nummanali (CC Mirror)</cite>
      </blockquote>

      <h3>The Fundamental Separation</h3>
      <div class="ascii-diagram">
+================================================================+
|                        ORCHESTRATOR                            |
|                                                                |
|   DOES:                          DOES NOT:                     |
|   - Decompose tasks              - Write code                  |
|   - Assign to workers            - Run commands                |
|   - Track dependencies           - Explore codebase            |
|   - Monitor progress             - Debug errors                |
|   - Synthesize results           - Make implementation         |
|   - Make coordination decisions    decisions                   |
|                                                                |
|   TOOLS: Task*, Read (1-2 files), AskUserQuestion              |
|                                                                |
+================================================================+
                              |
                    Delegates | Reports
                              |
+================================================================+
|                         WORKERS                                |
|                                                                |
|   DOES:                          DOES NOT:                     |
|   - Execute specific tasks       - Spawn sub-agents            |
|   - Use tools directly           - Manage task graphs          |
|   - Report results               - Make coordination           |
|   - Follow instructions            decisions                   |
|   - Complete and exit            - Plan beyond current task    |
|                                                                |
|   TOOLS: Read, Write, Edit, Bash, Glob, Grep, WebFetch, LSP    |
|                                                                |
+================================================================+
      </div>

      <h3>The Worker Preamble Pattern</h3>
      <p>Workers need explicit role definition to prevent role creep:</p>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code>CONTEXT: You are a WORKER agent, not an orchestrator.

RULES:
- Complete ONLY the task described below
- Use tools directly (Read, Write, Edit, Bash, etc.)
- Do NOT spawn sub-agents
- Do NOT call TaskCreate or TaskUpdate
- Report your results with absolute file paths

TASK:
[Your specific task here]</code></pre>
      </div>

      <h3>Model Selection by Role</h3>
      <div class="table-responsive">
        <table>
          <thead>
            <tr><th>Role</th><th>Recommended Model</th><th>Rationale</th></tr>
          </thead>
          <tbody>
            <tr><td>Orchestrator</td><td>Opus</td><td>Complex reasoning, coordination decisions</td></tr>
            <tr><td>Complex worker</td><td>Opus</td><td>Architecture, ambiguous tasks</td></tr>
            <tr><td>Standard worker</td><td>Sonnet</td><td>Implementation, testing, following patterns</td></tr>
            <tr><td>Simple worker</td><td>Haiku</td><td>File lookup, grep, simple transforms</td></tr>
          </tbody>
        </table>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Principle 5 -->
    <section id="principle-5">
      <h2><span class="bionic">Pri</span>nciple 5: <span class="bionic">Ato</span>mic, <span class="bionic">Ver</span>ifiable <span class="bionic">Task</span> Sizing</h2>

      <h3>The WHY</h3>
      <p><strong>Large tasks fail for predictable reasons:</strong></p>
      <ol>
        <li><strong>Context overflow</strong> - Task requires more tokens than window allows</li>
        <li><strong>Scope creep</strong> - Undefined boundaries expand during execution</li>
        <li><strong>Verification impossible</strong> - Can't test something that isn't complete</li>
        <li><strong>Recovery lost</strong> - Partial failure means losing all progress</li>
      </ol>

      <blockquote>
        <p>"Each story must be completable in ONE iteration (~one context window)"</p>
        <cite>-- Ryan Carson</cite>
      </blockquote>

      <h3>The 2-3 Sentence Test</h3>
      <p><strong>If you can't describe the task in 2-3 sentences, it's too big.</strong></p>
      <ul>
        <li><strong>Good:</strong> "Add investorType column to users table with default value 'cold'. Create migration. Run npm typecheck."</li>
        <li><strong>Bad:</strong> "Implement the investor management system with types, filtering, and reporting."</li>
      </ul>

      <h3>What "Verifiable" Means</h3>
      <p><strong>Acceptance criteria must be checkable by the agent itself.</strong></p>

      <p>Good criteria (verifiable):</p>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code>{
  "acceptanceCriteria": [
    "Column 'investorType' exists with default 'cold'",
    "npm run typecheck passes",
    "npm run test passes"
  ]
}</code></pre>
      </div>

      <p>Bad criteria (vague):</p>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code>{
  "acceptanceCriteria": [
    "Works correctly",
    "Good UX",
    "Handles edge cases"
  ]
}</code></pre>
      </div>

      <h3>Task Sizing Reference</h3>
      <div class="table-responsive">
        <table>
          <thead>
            <tr><th>Size</th><th>Lines of Code</th><th>Files</th><th>Iterations</th><th>Example</th></tr>
          </thead>
          <tbody>
            <tr><td>XS</td><td>1-20</td><td>1</td><td>1</td><td>Add column, fix typo</td></tr>
            <tr><td>S</td><td>20-100</td><td>1-2</td><td>1</td><td>New component, endpoint</td></tr>
            <tr><td>M</td><td>100-300</td><td>2-5</td><td>1-2</td><td>Feature piece, integration</td></tr>
            <tr><td>L</td><td>300-1000</td><td>5-10</td><td>3-5</td><td>Small feature, refactor</td></tr>
            <tr><td>XL</td><td>1000+</td><td>10+</td><td>5+</td><td>Full feature (MUST DECOMPOSE!)</td></tr>
          </tbody>
        </table>
      </div>
      <p><strong>Rule:</strong> XL tasks MUST be decomposed into S/M tasks.</p>
    </section>

    <hr class="section-divider">

    <!-- Principle 6 -->
    <section id="principle-6">
      <h2><span class="bionic">Pri</span>nciple 6: <span class="bionic">Qua</span>lity <span class="bionic">Gat</span>es <span class="bionic">Bef</span>ore <span class="bionic">Com</span>mit</h2>

      <h3>The WHY</h3>
      <p><strong>Broken code propagates.</strong> If iteration N commits broken code, iteration N+1 inherits a broken baseline. Now N+1 must:</p>
      <ol>
        <li>Understand the break</li>
        <li>Fix it</li>
        <li>THEN do its assigned work</li>
      </ol>
      <p>This compounds. Broken code creates debugging spirals that consume context and time.</p>
      <p><strong>Working code accumulates.</strong> If every commit passes tests, every future iteration starts from a working baseline. Progress is monotonic.</p>

      <h3>The Gate Pattern</h3>
      <div class="ascii-diagram">
+-------------------------------------------------------------+
|                    QUALITY GATES                            |
+-------------------------------------------------------------+
|                                                             |
|  BEFORE ANY COMMIT:                                         |
|                                                             |
|  1. Type checking     --> npm run typecheck                 |
|  2. Unit tests        --> npm test                          |
|  3. Lint              --> npm run lint                      |
|  4. Integration tests --> npm run test:integration          |
|                                                             |
|  ALL PASS? --> Commit allowed                               |
|  ANY FAIL? --> Fix BEFORE commit, retry gates               |
|                                                             |
+-------------------------------------------------------------+
      </div>

      <blockquote>
        <p>"Claude's tendency to mark features complete without proper testing... did much better at verifying end-to-end once explicitly prompted to use browser automation tools"</p>
        <cite>-- Anthropic Best Practices</cite>
      </blockquote>

      <h3>The CI Green Mandate</h3>
      <blockquote>
        <p>"Tests + types must pass every commit. No broken code inheritance."</p>
        <cite>-- Ralph Pattern</cite>
      </blockquote>
      <p>This is non-negotiable. Breaking this rule causes debugging spirals, context waste, lost progress, and compound failures.</p>
    </section>

    <hr class="section-divider">

    <!-- Principle 7 -->
    <section id="principle-7">
      <h2><span class="bionic">Pri</span>nciple 7: <span class="bionic">Iso</span>lation <span class="bionic">Pre</span>vents <span class="bionic">Con</span>tamination</h2>

      <h3>The WHY</h3>
      <p><strong>Shared state causes conflicts.</strong> When multiple agents operate on the same files:</p>
      <ul>
        <li>Edits overwrite each other</li>
        <li>Merge conflicts arise</li>
        <li>Partial changes break builds</li>
        <li>Context gets polluted with conflict resolution</li>
      </ul>

      <p><strong>Isolation enables parallelization.</strong> When each agent has its own space:</p>
      <ul>
        <li>No conflicts possible</li>
        <li>Parallel execution is safe</li>
        <li>Failures are contained</li>
        <li>Recovery is straightforward</li>
      </ul>

      <h3>Isolation Strategies</h3>
      <div class="table-responsive">
        <table>
          <thead>
            <tr><th>Strategy</th><th>Mechanism</th><th>Best For</th></tr>
          </thead>
          <tbody>
            <tr><td>Directory isolation</td><td>Each agent owns a directory</td><td>Domain specialization</td></tr>
            <tr><td>Branch isolation</td><td>Each agent works on its own branch</td><td>Feature parallelism</td></tr>
            <tr><td>Worktree isolation</td><td>Git worktrees share repo, isolate checkouts</td><td>Heavy parallelism</td></tr>
            <tr><td>Container isolation</td><td>Docker containers with volume mounts</td><td>Production systems</td></tr>
            <tr><td>Process isolation</td><td>Separate Claude processes per directory</td><td>Simple parallelism</td></tr>
          </tbody>
        </table>
      </div>

      <h3>The Worktree Pattern</h3>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code># Main repo
~/project/
  |- .git/           # Shared git database
  |- src/            # Main working directory

# Worktrees (parallel agent checkouts)
~/project-worktrees/
  |- feature-a/      # Agent 1's isolated directory
  |- feature-b/      # Agent 2's isolated directory
  |- bugfix-c/       # Agent 3's isolated directory</code></pre>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Principle 8 -->
    <section id="principle-8">
      <h2><span class="bionic">Pri</span>nciple 8: <span class="bionic">Exp</span>licit <span class="bionic">Com</span>munication Over <span class="bionic">Imp</span>licit</h2>

      <h3>The WHY</h3>
      <p><strong>LLMs don't share memory.</strong> Unlike human teams who build shared context through conversation, each agent instance starts with zero knowledge of others.</p>

      <p><strong>Implicit coordination fails.</strong> Agents cannot:</p>
      <ul>
        <li>Sense what other agents are doing</li>
        <li>Know if a file is being edited elsewhere</li>
        <li>Coordinate timing without signals</li>
        <li>Share learnings automatically</li>
      </ul>

      <h3>Communication Mechanisms</h3>
      <div class="table-responsive">
        <table>
          <thead>
            <tr><th>Mechanism</th><th>Use Case</th><th>Example</th></tr>
          </thead>
          <tbody>
            <tr><td>File-based handoffs</td><td>Agent-to-agent context transfer</td><td><code>handoff-agent1-to-agent2.json</code></td></tr>
            <tr><td>Git commits</td><td>Progress signaling</td><td>Commit message as communication</td></tr>
            <tr><td>Progress.txt</td><td>Learning propagation</td><td>Append-only log</td></tr>
            <tr><td>Task status files</td><td>Coordination state</td><td><code>prd.json</code> with passes/fails</td></tr>
            <tr><td>Event files</td><td>Real-time signals</td><td><code>/tmp/agent-events/</code></td></tr>
          </tbody>
        </table>
      </div>

      <h3>The Handoff Protocol</h3>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code>// handoff-agent1-to-agent2.json
{
  "from": "agent1",
  "to": "agent2",
  "timestamp": "2026-01-09T10:30:00Z",
  "context": {
    "completed": ["API schema", "Database models"],
    "next_steps": ["Implement REST endpoints"],
    "blockers": [],
    "notes": "Using FastAPI, see docs in /api/README.md"
  }
}</code></pre>
      </div>

      <h3>The Promise Pattern</h3>
      <p>Explicit completion signals:</p>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code>If all tasks complete, output: &lt;promise&gt;COMPLETE&lt;/promise&gt;</code></pre>
      </div>
      <p>The controlling loop greps for this signal. No ambiguity.</p>
    </section>

    <hr class="section-divider">

    <!-- Deriving New Patterns -->
    <section id="derivation">
      <h2><span class="bionic">Der</span>iving New <span class="bionic">Pat</span>terns from <span class="bionic">Pri</span>nciples</h2>

      <p>The true power of understanding principles is the ability to <strong>derive new patterns</strong> for novel situations.</p>

      <h3>The Derivation Process</h3>
      <ol>
        <li><strong>Identify the constraint</strong> - What's the primary challenge?</li>
        <li><strong>Map to principles</strong> - Which principles apply?</li>
        <li><strong>Check for conflicts</strong> - Do any principles conflict in this case?</li>
        <li><strong>Combine mechanisms</strong> - What implementations serve multiple principles?</li>
        <li><strong>Validate</strong> - Does the derived pattern satisfy the constraints?</li>
      </ol>

      <h3>The Principle Compatibility Matrix</h3>
      <p>When combining principles, some reinforce each other:</p>
      <div class="table-responsive">
        <table>
          <thead>
            <tr><th>Principle</th><th>Reinforces</th><th>Tension With</th></tr>
          </thead>
          <tbody>
            <tr><td>P1 (Context)</td><td>P3 (Fresh), P2 (External), P5 (Atomic)</td><td>Extended sessions</td></tr>
            <tr><td>P2 (External)</td><td>P3 (Fresh), P8 (Explicit)</td><td>In-context memory</td></tr>
            <tr><td>P3 (Fresh)</td><td>P1 (Context), P2 (External)</td><td>Session continuity</td></tr>
            <tr><td>P4 (Separation)</td><td>P1 (Context), P7 (Isolation)</td><td>Simple single-agent</td></tr>
            <tr><td>P5 (Atomic)</td><td>P6 (Gates), P3 (Fresh)</td><td>Large monolithic tasks</td></tr>
            <tr><td>P6 (Gates)</td><td>P5 (Atomic), P2 (External)</td><td>Speed-first development</td></tr>
            <tr><td>P7 (Isolation)</td><td>P4 (Separation), P8 (Explicit)</td><td>Shared state</td></tr>
            <tr><td>P8 (Explicit)</td><td>P7 (Isolation), P2 (External)</td><td>Implicit coordination</td></tr>
          </tbody>
        </table>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Quick Reference -->
    <section id="quick-reference">
      <h2><span class="bionic">Qui</span>ck <span class="bionic">Ref</span>erence</h2>

      <h3>When Things Break, Check Principles</h3>
      <div class="table-responsive">
        <table>
          <thead>
            <tr><th>Symptom</th><th>Likely Violated Principle</th><th>Fix</th></tr>
          </thead>
          <tbody>
            <tr><td>Agent forgets previous work</td><td>P2 (External state)</td><td>Externalize to files</td></tr>
            <tr><td>Quality degrades over time</td><td>P1/P3 (Context/Fresh)</td><td>Reset more frequently</td></tr>
            <tr><td>Workers spawn their own agents</td><td>P4 (Separation)</td><td>Explicit worker preamble</td></tr>
            <tr><td>Tasks never complete</td><td>P5 (Atomic sizing)</td><td>Smaller stories</td></tr>
            <tr><td>Broken code accumulates</td><td>P6 (Quality gates)</td><td>Enforce tests before commit</td></tr>
            <tr><td>Agents conflict on files</td><td>P7 (Isolation)</td><td>Worktrees or ownership</td></tr>
            <tr><td>Agents don't coordinate</td><td>P8 (Explicit comms)</td><td>File-based handoffs</td></tr>
          </tbody>
        </table>
      </div>

      <h3>The Principle Checklist</h3>
      <p>Before any multi-session or multi-agent work:</p>
      <ul>
        <li>Is state externalized to survive session death? (P2)</li>
        <li>Is each task completable in one context window? (P5)</li>
        <li>Are quality gates defined and enforced? (P6)</li>
        <li>Is orchestrator separated from workers? (P4)</li>
        <li>Are agents isolated from each other? (P7)</li>
        <li>Is communication explicit via files? (P8)</li>
        <li>Is fresh context preferred over extended sessions? (P3)</li>
        <li>Is context budget tracked and respected? (P1)</li>
      </ul>

      <h3>Summary: The Eight Principles</h3>
      <ol>
        <li><strong>Context Is The Primary Constraint</strong> - All patterns optimize around finite context windows</li>
        <li><strong>External State &gt; Internal Memory</strong> - Files persist, context evaporates</li>
        <li><strong>Fresh Context &gt; Extended Sessions</strong> - New instances beat long conversations</li>
        <li><strong>Separation of Concerns</strong> - Orchestrators coordinate, workers execute</li>
        <li><strong>Atomic, Verifiable Tasks</strong> - Complete in one iteration, verify before commit</li>
        <li><strong>Quality Gates Before Commit</strong> - Tests must pass, no broken code inheritance</li>
        <li><strong>Isolation Prevents Contamination</strong> - Own your space, don't conflict</li>
        <li><strong>Explicit Communication</strong> - File-based handoffs, not implicit coordination</li>
      </ol>

      <div class="callout callout-insight">
        <div class="callout-title">The Meta-Principle</div>
        <p>When in doubt, <strong>externalize, isolate, verify, and restart fresh</strong>.</p>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Troubleshooting -->
    <section id="troubleshooting">
      <h2><span class="bionic">Tro</span>ubleshooting</h2>

      <details class="troubleshoot">
        <summary>Principle Violation Goes Unnoticed Until Failure</summary>
        <div>
          <p><strong>Symptom:</strong> Pattern works for small tasks but fails catastrophically on larger ones</p>
          <p><strong>Cause:</strong> Subtle principle violations that only manifest at scale</p>
          <p><strong>Fix:</strong> Use the principle checklist before any multi-session or multi-agent work</p>
        </div>
      </details>

      <details class="troubleshoot">
        <summary>Fresh Context Pattern Feels Inefficient</summary>
        <div>
          <p><strong>Symptom:</strong> Startup overhead each iteration seems wasteful</p>
          <p><strong>Cause:</strong> Misunderstanding the tradeoff between consistency and speed</p>
          <p><strong>Fix:</strong></p>
          <ol>
            <li>Accept that reading state takes ~5-10 seconds but prevents hours of debugging</li>
            <li>Measure: fresh context iterations are MORE efficient over 10+ iterations</li>
            <li>The "inefficiency" is the feature - it prevents context rot</li>
          </ol>
        </div>
      </details>

      <details class="troubleshoot">
        <summary>Orchestrator Keeps "Helping" With Implementation</summary>
        <div>
          <p><strong>Symptom:</strong> Orchestrator context fills with code; loses coordination capacity</p>
          <p><strong>Cause:</strong> Unclear role boundaries or orchestrator prompt too permissive</p>
          <p><strong>Fix:</strong></p>
          <ol>
            <li>Add explicit prohibition: "YOU DO NOT WRITE CODE. YOU DO NOT RUN COMMANDS."</li>
            <li>Restrict orchestrator tools to: TaskCreate, TaskUpdate, Task, AskUserQuestion, Read (1-2 files max)</li>
            <li>If orchestrator needs file content, spawn a Haiku worker to summarize</li>
          </ol>
        </div>
      </details>

      <details class="troubleshoot">
        <summary>Tasks Never Seem "Atomic" Enough</summary>
        <div>
          <p><strong>Symptom:</strong> Tasks keep expanding scope; never complete in one iteration</p>
          <p><strong>Cause:</strong> Acceptance criteria too vague or task boundaries unclear</p>
          <p><strong>Fix:</strong> Apply the 2-3 sentence test:</p>
          <ul>
            <li>If you can't describe the task in 2-3 sentences, split it</li>
            <li>Good: "Add investorType column to users table with default 'cold'. Run typecheck."</li>
            <li>Bad: "Implement investor management with types, filtering, and reporting"</li>
          </ul>
        </div>
      </details>

      <details class="troubleshoot">
        <summary>Quality Gates Slow Things Down</summary>
        <div>
          <p><strong>Symptom:</strong> Tests take too long; tempted to skip them</p>
          <p><strong>Cause:</strong> Misunderstanding the cost of broken code propagation</p>
          <p><strong>Fix:</strong></p>
          <ol>
            <li>Broken code in iteration N means iteration N+1 must debug first</li>
            <li>Debugging spirals can consume 5-10x the time saved by skipping tests</li>
            <li>If tests are too slow, invest in faster tests - don't skip them</li>
          </ol>
        </div>
      </details>

      <details class="troubleshoot">
        <summary>Isolation Prevents Necessary Coordination</summary>
        <div>
          <p><strong>Symptom:</strong> Agents can't share information; work duplicated</p>
          <p><strong>Cause:</strong> Over-isolation without handoff mechanism</p>
          <p><strong>Fix:</strong></p>
          <ol>
            <li>Isolation doesn't mean no communication - it means EXPLICIT communication</li>
            <li>Use file-based handoffs: <code>handoff-agent1-to-agent2.json</code></li>
            <li>The rule is: if it's not in a file, it doesn't exist</li>
          </ol>
        </div>
      </details>
    </section>

    <hr class="section-divider">

    <!-- Related Pages -->
    <div class="related-pages">
      <h3>Related Principles Documents</h3>
      <ul>
        <li><a href="principles-derivation-guide.html">Derivation Guide</a> - How to create new patterns from principles</li>
        <li><a href="principles-learning-loops.html">Learning Loops</a> - Feedback loop engineering</li>
        <li><a href="principles-anti-patterns.html">Anti-Patterns</a> - What NOT to do and why</li>
      </ul>
    </div>

    <!-- Footer Navigation -->
    <nav class="footer-nav">
      <span></span>
      <a href="principles-derivation-guide.html" class="nav-next">
        <span class="nav-direction">Next</span>
        <span class="nav-title">Derivation Guide</span>
      </a>
    </nav>

    <!-- Tags -->
    <div style="margin-top: 2rem;">
      <span class="tag">#core-principles</span>
      <span class="tag">#context-management</span>
      <span class="tag">#external-state</span>
      <span class="tag">#fresh-context</span>
      <span class="tag">#orchestrator-worker</span>
      <span class="tag">#atomic-tasks</span>
      <span class="tag">#quality-gates</span>
      <span class="tag">#isolation</span>
      <span class="tag">#explicit-communication</span>
    </div>
  </div>

  <script src="../js/copy-code.js"></script>
  <script src="../js/search.js"></script>
  <script src="../js/global-nav.js"></script>
</body>
</html>
