<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta data-pagefind-meta="section" content="Synthesis">
  <meta data-pagefind-meta="category" content="Transformations">
  <title>Generalist Agent to Specialized Swarm | Transformations | Claude Code Knowledge Base</title>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="stylesheet" href="../css/sidebar.css">
  <link rel="stylesheet" href="../css/search.css">
  <style>
    .you-are-here {
      background: linear-gradient(135deg, #f0ebe3 0%, #fefcf3 100%);
      border-left: 4px solid #2a7d7d;
      border-radius: 8px;
      padding: 1.5rem;
      margin-bottom: 2rem;
    }
    .bionic { font-weight: 700; }
    .checkpoint {
      background: #f0ebe3;
      border-left: 4px solid #6b9b7a;
      border-radius: 8px;
      padding: 1.5rem;
      margin: 2rem 0;
    }
    .checkpoint-header { color: #6b9b7a; font-weight: 600; margin-bottom: 0.5rem; }
    .milestone {
      background: linear-gradient(90deg, #6b9b7a 0%, #2a7d7d 100%);
      color: white;
      padding: 1rem 1.5rem;
      border-radius: 8px;
      text-align: center;
      margin: 2rem 0;
    }
    .before-after-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 24px;
      margin: 24px 0;
    }
    @media (max-width: 900px) {
      .before-after-container { grid-template-columns: 1fr; }
    }
    .before-box, .after-box {
      border-radius: 12px;
      padding: 20px;
    }
    .before-box {
      background: #fdf0ef;
      border: 2px solid var(--error);
    }
    .before-box h3, .before-box h4 { color: var(--error); margin-top: 0; }
    .after-box {
      background: #eef6f0;
      border: 2px solid var(--success);
    }
    .after-box h3, .after-box h4 { color: var(--success); margin-top: 0; }
    .code-block-wrapper {
      position: relative;
    }
    .troubleshoot {
      border: 1px solid #c97065;
      border-radius: 8px;
      margin: 1rem 0;
    }
    .troubleshoot summary {
      background: #fef6f5;
      padding: 1rem;
      cursor: pointer;
      color: #c97065;
      font-weight: 600;
    }
    .troubleshoot > div {
      padding: 1rem;
    }
    .d-final-box {
      background: #f5f0e8;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1rem;
      margin: 1rem 0;
      font-size: 0.9em;
    }
    .d-final-box h4 {
      margin-top: 0;
      color: var(--heading);
    }
    .architecture-diagram {
      background: var(--code-bg);
      border-radius: 8px;
      padding: 20px;
      margin: 24px 0;
      font-family: 'SF Mono', Monaco, monospace;
      font-size: 0.85em;
      line-height: 1.4;
      overflow-x: auto;
    }
    .quality-bar {
      background: #e0d5c5;
      border-radius: 4px;
      height: 20px;
      margin: 8px 0;
      overflow: hidden;
    }
    .quality-fill {
      height: 100%;
      display: flex;
      align-items: center;
      padding-left: 8px;
      color: white;
      font-size: 0.8em;
      font-weight: 600;
    }
    .quality-fill.low { background: var(--error); }
    .quality-fill.medium { background: var(--warning); }
    .quality-fill.high { background: var(--success); }
    .anti-pattern {
      background: #fdf0ef;
      border-left: 4px solid var(--error);
      border-radius: 0 8px 8px 0;
      padding: 16px 20px;
      margin: 16px 0;
    }
    .anti-pattern h4 {
      color: var(--error);
      margin-top: 0;
      margin-bottom: 8px;
    }
  </style>
</head>
<body>
  <!-- Search Modal -->
  <div class="search-modal" id="searchModal" aria-hidden="true">
    <div class="search-overlay" onclick="closeSearch()"></div>
    <div class="search-content">
      <div class="search-header">
        <div class="search-input-wrapper">
          <span class="search-icon-input">&#128269;</span>
          <input type="text" id="searchInput" placeholder="Search documentation..." autocomplete="off" />
          <kbd class="search-kbd">ESC</kbd>
        </div>
      </div>
      <div class="search-filters">
        <button class="filter-btn active" data-filter="all">All</button>
        <button class="filter-btn" data-filter="synthesis">Synthesis</button>
        <button class="filter-btn" data-filter="extractions">Extractions</button>
        <button class="filter-btn" data-filter="journeys">Journeys</button>
      </div>
      <div class="search-results" id="searchResults">
        <div class="search-empty"><p>Start typing to search... (Press Cmd+K anytime)</p></div>
      </div>
      <div class="search-footer">
        <span>Up/Down Navigate</span><span>Enter Select</span><span>ESC Close</span>
      </div>
    </div>
  </div>

  <button class="search-trigger" onclick="openSearch()" aria-label="Search" style="float: right; margin-bottom: 1rem;">
    <span class="search-icon">Cmd+K</span>
    <span class="search-text">Search</span>
  </button>

  <nav class="left-nav" id="leftNav">
    <div class="px-4 mb-4">
      <a href="../index.html" class="text-xs font-semibold text-accent hover:text-accent-light uppercase tracking-wider">Claude Code KB</a>
    </div>
    <div class="nav-content"></div>
  </nav>

  <div class="container">
    <nav class="nav-breadcrumb">
      <a href="../index.html">Home</a>
      <span>/</span>
      <a href="synthesis-index.html">Synthesis</a>
      <span>/</span>
      <a href="transform-master.html">Transformations</a>
      <span>/</span>
      <strong>Generalist to Swarm</strong>
    </nav>

    <h1><span class="bionic">Tra</span>nsformation: <span class="bionic">Gen</span>eralist <span class="bionic">Age</span>nt to <span class="bionic">Spe</span>cialized <span class="bionic">Swa</span>rm</h1>

    <div class="you-are-here">
      <h3 style="margin-top: 0; color: var(--accent);"><span class="bionic">You</span> Are <span class="bionic">Her</span>e</h3>
      <p>This document shows how to evolve from a single agent doing everything (poorly) to specialized workers doing their domains excellently. If your full-stack features have inconsistent quality or take forever due to context dilution, the swarm pattern solves this. This connects to Level 5-6 (CC Mirror Hub-and-Spoke) on the complexity ladder and enables true parallel execution with domain expertise.</p>
      <p><strong>The paradigm shift from single-context everything to orchestrated domain specialists</strong></p>
    </div>

    <div class="d-final-box">
      <h4>D-FINAL Integration</h4>
      <p><strong>Validates invariants:</strong> INV-1 (Context is constraint), INV-3 (Fresh context beats extended), INV-5 (Parallelization over single-agent), INV-8 (Model tiering), INV-14 (Claims-based coordination)</p>
      <p><strong>Maps to complexity ladder:</strong> Level 1-2 (Single/Ralph) to Level 5-6 (CC Mirror Hub-and-Spoke)</p>
      <p><strong>Cross-references:</strong> <a href="taxonomy-architectures.html">Architecture Taxonomy</a>, <a href="architecture-domain-isolation.html">Domain Isolation</a></p>
    </div>

    <div class="toc">
      <div class="toc-title">Contents</div>
      <ul>
        <li><a href="#workload">The Workload</a></li>
        <li><a href="#before">BEFORE: Single Generalist Agent</a></li>
        <li><a href="#after">AFTER: Specialized Swarm (CC Mirror)</a></li>
        <li><a href="#comparison">Comparison Matrix</a></li>
        <li><a href="#implementation">Implementation Patterns</a></li>
        <li><a href="#when-to-use">When to Use Each Approach</a></li>
        <li><a href="#anti-patterns">Anti-Patterns to Avoid</a></li>
        <li><a href="#monitoring">Monitoring the Swarm</a></li>
        <li><a href="#troubleshooting">Troubleshooting</a></li>
      </ul>
    </div>

    <hr class="section-divider">

    <h2 id="workload">The <span class="bionic">Wor</span>kload</h2>

    <p>Build a full-stack feature: <strong>User Authentication System</strong></p>

    <p><strong>Requirements:</strong></p>
    <ul>
      <li>Database schema (users table, sessions table, password hashing)</li>
      <li>API endpoints (register, login, logout, refresh token)</li>
      <li>Frontend components (login form, registration form, auth context)</li>
      <li>Tests (unit tests, integration tests, E2E flow)</li>
    </ul>

    <hr class="section-divider">

    <h2 id="before"><span class="bionic">BEF</span>ORE: <span class="bionic">Sin</span>gle <span class="bionic">Gen</span>eralist <span class="bionic">Age</span>nt</h2>

    <div class="before-box" style="margin: 24px 0;">
      <h3>Approach</h3>
      <p>One Claude instance handles everything sequentially:</p>
    </div>

    <div class="architecture-diagram">
+-------------------------------------------------------------+
|                    GENERALIST AGENT                          |
|                     (Single Instance)                        |
+-------------------------------------------------------------+
|                                                              |
|   Context Window (filling up...)                            |
|   +-----------------------------------------------------+   |
|   | DB schema design decisions...                        |   |
|   | SQL migration syntax...                              |   |
|   | API route patterns...                                |   |
|   | JWT token implementation...                          |   |
|   | React component structure...                         |   |
|   | Form validation patterns...                          |   |
|   | Test setup boilerplate...                           |   |
|   | Mock configuration...                                |   |
|   | [CONTEXT GETTING CROWDED]                           |   |
|   +-----------------------------------------------------+   |
|                                                              |
|   Execution: Sequential                                     |
|   Step 1: Design schema          [45 min]                   |
|   Step 2: Write migrations       [30 min]                   |
|   Step 3: Implement API          [60 min]                   |
|   Step 4: Build UI components    [45 min]                   |
|   Step 5: Write tests            [60 min]                   |
|   -------------------------------------------               |
|   Total:                         [240 min = 4 hours]        |
|                                                              |
+-------------------------------------------------------------+
    </div>

    <h3><span class="bionic">Ses</span>sion <span class="bionic">Tra</span>nscript (<span class="bionic">Ill</span>ustrative)</h3>

    <div class="code-block-wrapper">
      <pre><code>Human: Build a user authentication system with DB, API, UI, and tests.

Agent: I'll start by designing the database schema.

[Agent reads existing schema files]
[Agent writes users table migration]
[Agent writes sessions table migration]
[Agent runs migrations]

Agent: Now I'll implement the API endpoints.

[Agent reads API patterns from codebase]
[Agent implements register endpoint]
[Agent implements login endpoint]
[Agent implements logout endpoint]
[Agent implements token refresh]

Agent: Moving on to the frontend components.

[Agent reads existing component patterns]
[Agent creates LoginForm component]
[Agent creates RegistrationForm component]
[Agent creates AuthContext provider]
[Agent updates app routing]

Agent: Finally, I'll write the tests.

[Agent reads test patterns]
[Agent writes unit tests for API]
[Agent writes unit tests for components]
[Agent writes integration tests]
[Agent writes E2E test]

Agent: Done! The authentication system is complete.</code></pre>
    </div>

    <h3><span class="bionic">Pro</span>blems with This <span class="bionic">App</span>roach</h3>

    <div class="table-responsive">
      <table>
        <thead>
          <tr>
            <th>Problem</th>
            <th>Impact</th>
          </tr>
        </thead>
        <tbody>
          <tr><td><strong>Context Dilution</strong></td><td>By the time we reach tests, early schema decisions are pushed out of context window. Agent may forget why certain choices were made.</td></tr>
          <tr><td><strong>Domain Switching Overhead</strong></td><td>Mental model shifts: SQL thinking to Node.js thinking to React thinking to testing thinking. Each switch has cognitive cost.</td></tr>
          <tr><td><strong>No Parallelism</strong></td><td>4 hours sequential. Human waits the entire time.</td></tr>
          <tr><td><strong>Jack of All Trades</strong></td><td>Agent is adequate at everything but expert at nothing. Backend code has frontend patterns; tests miss edge cases.</td></tr>
          <tr><td><strong>Single Point of Failure</strong></td><td>If context corrupts at hour 3, all progress since last commit at risk.</td></tr>
          <tr><td><strong>No Specialization</strong></td><td>Same prompt patterns for schema design and UI components. No domain-specific optimization.</td></tr>
        </tbody>
      </table>
    </div>

    <h3><span class="bionic">Qua</span>lity <span class="bionic">Dis</span>tribution</h3>

    <p><strong>Quality Across Domains (Generalist)</strong></p>

    <p><strong>Database:</strong></p>
    <div class="quality-bar"><div class="quality-fill medium" style="width: 40%;">40%</div></div>
    <p style="font-size: 0.9em; color: var(--text-muted);">adequate but not optimal</p>

    <p><strong>API:</strong></p>
    <div class="quality-bar"><div class="quality-fill medium" style="width: 50%;">50%</div></div>
    <p style="font-size: 0.9em; color: var(--text-muted);">working but inconsistent</p>

    <p><strong>Frontend:</strong></p>
    <div class="quality-bar"><div class="quality-fill low" style="width: 30%;">30%</div></div>
    <p style="font-size: 0.9em; color: var(--text-muted);">functional, rough edges</p>

    <p><strong>Tests:</strong></p>
    <div class="quality-bar"><div class="quality-fill low" style="width: 20%;">20%</div></div>
    <p style="font-size: 0.9em; color: var(--text-muted);">basic coverage, context exhausted</p>

    <p><strong>Average: 35% of potential quality</strong></p>

    <p><strong>Why tests suffer most:</strong> They come last, when context is most crowded with implementation details from three different domains.</p>

    <hr class="section-divider">

    <h2 id="after"><span class="bionic">AFT</span>ER: <span class="bionic">Spe</span>cialized <span class="bionic">Swa</span>rm (CC <span class="bionic">Mir</span>ror <span class="bionic">Pat</span>tern)</h2>

    <div class="after-box" style="margin: 24px 0;">
      <h3>Architecture</h3>
      <p>Orchestrator coordinates specialized workers, each with focused context.</p>
    </div>

    <div class="architecture-diagram">
+=================================================================+
|                         SPECIALIZED SWARM                        |
+=================================================================+
|                                                                  |
|              +-------------------------------+                   |
|              |       ORCHESTRATOR            |                   |
|              |       (Opus 4.5)              |                   |
|              |                               |                   |
|              |  "I coordinate. I never code."|                   |
|              |                               |                   |
|              |  Tools: Task*, Read (minimal) |                   |
|              +---------------+---------------+                   |
|                              |                                   |
|           +------------------+------------------+                 |
|           |                  |                  |                 |
|           v                  v                  v                 |
|  +-------------+    +-------------+    +-------------+           |
|  |  BACKEND    |    |  FRONTEND   |    |   TEST      |           |
|  |  WORKER     |    |  WORKER     |    |   WORKER    |           |
|  |  (Sonnet)   |    |  (Sonnet)   |    |  (Haiku)    |           |
|  |             |    |             |    |             |           |
|  | DB schema   |    | UI comps    |    | Integration |           |
|  | Migrations  |    | Forms       |    | tests       |           |
|  | API routes  |    | Auth ctx    |    | E2E tests   |           |
|  +-------------+    +-------------+    +-------------+           |
|                                                                  |
|  Execution:                                                      |
|  +-- Backend Worker    ========== [60 min]                       |
|  +-- Frontend Worker   ========== [45 min] (parallel after APIs) |
|  +-- Test Worker       ====== [30 min] (after both complete)     |
|  ----------------------------------------------                  |
|  Total Wall Clock:     [~90 min with dependencies]               |
|                                                                  |
+=================================================================+
    </div>

    <h3><span class="bionic">Imp</span>lementation</h3>

    <div class="tutorial-block">
      <div class="tutorial-header">Step 1: Orchestrator Prompt</div>
      <div class="tutorial-content">
        <div class="code-block-wrapper">
          <button class="copy-btn" onclick="copyCode(this)">Copy</button>
          <pre><code># ORCHESTRATOR SYSTEM PROMPT

You are the orchestrator for building a user authentication system.

## IRON LAW
- You do NOT write code
- You do NOT run commands
- You do NOT explore codebases directly
- You ONLY coordinate workers

## YOUR TOOLS
- Task (to spawn workers)
- Read (only for high-level overview, 1-2 files max)

## TASK BREAKDOWN

1. **Backend Task** (blocked_by: none)
   - Design and implement users/sessions schema
   - Create API endpoints: register, login, logout, refresh
   - Run backend tests before reporting complete

2. **Frontend Task** (blocked_by: Backend Task)
   - Create LoginForm, RegistrationForm components
   - Implement AuthContext provider
   - Wire up to API endpoints
   - Run component tests before reporting complete

3. **Test Task** (blocked_by: Frontend Task)
   - Write integration tests for auth flow
   - Write E2E test for complete user journey
   - Verify all tests pass

## WORKFLOW
1. Spawn Backend Worker (run_in_background: true)
2. Wait for Backend completion
3. Spawn Frontend Worker (run_in_background: true)
4. Wait for Frontend completion
5. Spawn Test Worker
6. Synthesize results and report to human</code></pre>
        </div>
      </div>
    </div>

    <div class="tutorial-block">
      <div class="tutorial-header">Step 2: Backend Worker Preamble</div>
      <div class="tutorial-content">
        <div class="code-block-wrapper">
          <button class="copy-btn" onclick="copyCode(this)">Copy</button>
          <pre><code># WORKER CONTEXT

ROLE: Backend Worker
SCOPE: Database schema and API endpoints ONLY

## RULES
- Complete ONLY the task described below
- Use tools directly (Read, Write, Edit, Bash, Glob, Grep)
- Do NOT spawn sub-agents
- Do NOT call Task or TaskCreate
- Report results with absolute file paths

## AVAILABLE TOOLS
Read, Write, Edit, Bash, Glob, Grep, WebSearch

## TASK
Implement user authentication backend:

1. Database Schema
   - users table (id, email, password_hash, created_at, updated_at)
   - sessions table (id, user_id, token, expires_at, created_at)
   - Use existing migration patterns in /db/migrations/

2. API Endpoints
   - POST /auth/register
   - POST /auth/login
   - POST /auth/logout
   - POST /auth/refresh
   - Follow patterns in /src/api/

3. Verification
   - Run: npm run test:backend
   - All tests must pass before reporting complete

## DELIVERABLES
Report with:
- Files created/modified (absolute paths)
- Any blockers encountered
- Test results summary</code></pre>
        </div>
      </div>
    </div>

    <div class="tutorial-block">
      <div class="tutorial-header">Step 3: Frontend Worker Preamble</div>
      <div class="tutorial-content">
        <div class="code-block-wrapper">
          <button class="copy-btn" onclick="copyCode(this)">Copy</button>
          <pre><code># WORKER CONTEXT

ROLE: Frontend Worker
SCOPE: UI components and auth state ONLY

## RULES
- Complete ONLY the task described below
- Use tools directly (Read, Write, Edit, Bash, Glob, Grep)
- Do NOT spawn sub-agents
- Do NOT call Task or TaskCreate
- Report results with absolute file paths

## AVAILABLE TOOLS
Read, Write, Edit, Bash, Glob, Grep

## TASK
Implement authentication UI:

1. Components (follow patterns in /src/components/)
   - LoginForm.tsx (email, password, submit, error handling)
   - RegistrationForm.tsx (email, password, confirm, submit)
   - Protected route wrapper

2. Auth Context
   - AuthProvider with user state
   - useAuth hook
   - Token storage and refresh logic

3. Verification
   - Run: npm run test:components
   - All component tests must pass

## API ENDPOINTS (from Backend Worker)
- POST /auth/register { email, password }
- POST /auth/login { email, password }
- POST /auth/logout
- POST /auth/refresh

## DELIVERABLES
Report with:
- Files created/modified (absolute paths)
- Any blockers encountered
- Test results summary</code></pre>
        </div>
      </div>
    </div>

    <h3><span class="bionic">Orc</span>hestrator <span class="bionic">Exe</span>cution <span class="bionic">Flo</span>w</h3>

    <div class="code-block-wrapper">
      <pre><code>ORCHESTRATOR LOG
================================================================

[00:00] Received task: Build user authentication system

[00:01] Decomposing into worker tasks...
        Task 1: Backend (DB + API)     [no dependencies]
        Task 2: Frontend (UI + State)  [depends on: Backend]
        Task 3: Tests (Integration/E2E) [depends on: Frontend]

[00:02] Spawning Backend Worker (run_in_background: true)
        -&gt; Worker ID: backend-auth-001

[00:45] Backend Worker completed
        -&gt; Files modified: 8
        -&gt; /db/migrations/20260109_users.sql
        -&gt; /db/migrations/20260109_sessions.sql
        -&gt; /src/api/auth/register.ts
        -&gt; /src/api/auth/login.ts
        -&gt; /src/api/auth/logout.ts
        -&gt; /src/api/auth/refresh.ts
        -&gt; /src/api/auth/index.ts
        -&gt; /src/api/auth/__tests__/auth.test.ts
        -&gt; Tests: 12 passed, 0 failed

[00:46] Spawning Frontend Worker (run_in_background: true)
        -&gt; Worker ID: frontend-auth-001

[01:15] Frontend Worker completed
        -&gt; Files modified: 6
        -&gt; /src/components/auth/LoginForm.tsx
        -&gt; /src/components/auth/RegistrationForm.tsx
        -&gt; /src/components/auth/ProtectedRoute.tsx
        -&gt; /src/context/AuthContext.tsx
        -&gt; /src/hooks/useAuth.ts
        -&gt; /src/components/auth/__tests__/auth.test.tsx
        -&gt; Tests: 8 passed, 0 failed

[01:16] Spawning Test Worker
        -&gt; Worker ID: test-auth-001

[01:35] Test Worker completed
        -&gt; Files created: 2
        -&gt; /tests/integration/auth.integration.test.ts
        -&gt; /tests/e2e/auth.e2e.spec.ts
        -&gt; Integration tests: 6 passed
        -&gt; E2E tests: 4 passed

[01:36] SYNTHESIS
        ========================================

        Authentication system complete.

        Total files: 16
        Total tests: 30 (all passing)

        Backend:  /src/api/auth/
        Frontend: /src/components/auth/, /src/context/
        Tests:    /tests/integration/, /tests/e2e/

        Ready for human review.

================================================================</code></pre>
    </div>

    <h3><span class="bionic">Ben</span>efits of the <span class="bionic">Swa</span>rm <span class="bionic">App</span>roach</h3>

    <div class="table-responsive">
      <table>
        <thead>
          <tr>
            <th>Benefit</th>
            <th>Explanation</th>
          </tr>
        </thead>
        <tbody>
          <tr><td><strong>Parallel Execution</strong></td><td>Backend can complete while frontend waits. Total time: ~90 min vs 4 hours sequential.</td></tr>
          <tr><td><strong>Domain Specialization</strong></td><td>Each worker loads only relevant patterns. Backend worker doesn't pollute context with React.</td></tr>
          <tr><td><strong>Focused Context</strong></td><td>Each worker's context window is 100% dedicated to its domain. No context dilution.</td></tr>
          <tr><td><strong>Better Quality per Domain</strong></td><td>Workers can go deep on their specialty without breadth pressure.</td></tr>
          <tr><td><strong>Fault Isolation</strong></td><td>If frontend worker fails, backend work is preserved. Retry just the failed piece.</td></tr>
          <tr><td><strong>Scale Horizontally</strong></td><td>Need more features? Add more workers. Orchestrator scales the coordination.</td></tr>
          <tr><td><strong>Model Optimization</strong></td><td>Use Opus for orchestration (complex reasoning), Sonnet for implementation, Haiku for simple tests.</td></tr>
        </tbody>
      </table>
    </div>

    <h3><span class="bionic">Qua</span>lity <span class="bionic">Dis</span>tribution (<span class="bionic">Swa</span>rm)</h3>

    <p><strong>Database:</strong></p>
    <div class="quality-bar"><div class="quality-fill high" style="width: 85%;">85%</div></div>
    <p style="font-size: 0.9em; color: var(--text-muted);">specialist worker, focused</p>

    <p><strong>API:</strong></p>
    <div class="quality-bar"><div class="quality-fill high" style="width: 80%;">80%</div></div>
    <p style="font-size: 0.9em; color: var(--text-muted);">same worker, coherent design</p>

    <p><strong>Frontend:</strong></p>
    <div class="quality-bar"><div class="quality-fill high" style="width: 75%;">75%</div></div>
    <p style="font-size: 0.9em; color: var(--text-muted);">specialist, fresh context</p>

    <p><strong>Tests:</strong></p>
    <div class="quality-bar"><div class="quality-fill high" style="width: 80%;">80%</div></div>
    <p style="font-size: 0.9em; color: var(--text-muted);">specialist, comprehensive</p>

    <p><strong>Average: 80% of potential quality</strong></p>

    <p><strong>Why quality improves across all domains:</strong> Each worker starts fresh, loads only relevant context, and can focus entirely on its specialty.</p>

    <hr class="section-divider">

    <h2 id="comparison"><span class="bionic">Com</span>parison <span class="bionic">Mat</span>rix</h2>

    <div class="table-responsive">
      <table class="comparison-table">
        <thead>
          <tr>
            <th>Aspect</th>
            <th>Generalist</th>
            <th>Specialized Swarm</th>
          </tr>
        </thead>
        <tbody>
          <tr><td><strong>Parallelism</strong></td><td>None (sequential)</td><td>Full (with dependency awareness)</td></tr>
          <tr><td><strong>Specialization</strong></td><td>None (one agent does all)</td><td>Per-worker domain focus</td></tr>
          <tr><td><strong>Context</strong></td><td>Shared/diluted across domains</td><td>Focused per domain</td></tr>
          <tr><td><strong>Speed</strong></td><td>Linear (4 hours)</td><td>Parallel (~90 min with deps)</td></tr>
          <tr><td><strong>Quality</strong></td><td>Averages down (35%)</td><td>High per domain (80%)</td></tr>
          <tr><td><strong>Fault Tolerance</strong></td><td>Single point of failure</td><td>Isolated failures, retry individual workers</td></tr>
          <tr><td><strong>Cost</strong></td><td>Lower (one agent)</td><td>Higher (multiple agents)</td></tr>
          <tr><td><strong>Complexity</strong></td><td>Simple to run</td><td>Requires orchestration setup</td></tr>
          <tr><td><strong>Debugging</strong></td><td>Single context to examine</td><td>Multiple contexts, need monitoring</td></tr>
          <tr><td><strong>Scaling</strong></td><td>Add more time</td><td>Add more workers</td></tr>
        </tbody>
      </table>
    </div>

    <hr class="section-divider">

    <h2 id="implementation"><span class="bionic">Imp</span>lementation <span class="bionic">Pat</span>terns</h2>

    <h3><span class="bionic">Sta</span>rting <span class="bionic">Sim</span>ple: <span class="bionic">Man</span>ual <span class="bionic">Swa</span>rm</h3>

    <p>Before investing in CC Mirror or Gas Town, you can manually orchestrate:</p>

    <div class="code-block-wrapper">
      <button class="copy-btn" onclick="copyCode(this)">Copy</button>
      <pre><code># Terminal 1: Backend Worker
cd ~/project
claude --print "You are a backend worker. Implement auth DB and API..." &gt; backend.log &amp;

# Wait for backend to complete (monitor backend.log)
# Then Terminal 2: Frontend Worker
claude --print "You are a frontend worker. Implement auth UI..." &gt; frontend.log &amp;

# Wait for frontend to complete
# Then Terminal 3: Test Worker
claude --print "You are a test worker. Write integration tests..." &gt; test.log</code></pre>
    </div>

    <div class="checkpoint">
      <div class="checkpoint-header">Checkpoint: After Manual Swarm Setup</div>
      <p><strong>Where you are:</strong> You've launched workers manually in separate terminals with dedicated log files.</p>
      <p><strong>What this enables:</strong> Testing swarm patterns without infrastructure. Validates the concept before investing in tooling.</p>

      <p><strong>Verify your state:</strong></p>
      <div class="code-block-wrapper">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code># Check workers are running (if backgrounded)
jobs -l

# Check log files exist
ls -la backend.log frontend.log test.log

# Check backend completed (look for exit indicator)
tail -20 backend.log</code></pre>
      </div>

      <div class="expected-output">
        <p><strong>You should see:</strong></p>
        <pre>[1]  + 12345 running    claude --print ...   &larr; Worker running
[2]  + 12346 running    claude --print ...   &larr; Worker running

-rw-r--r--  backend.log                      &larr; Logs being written
-rw-r--r--  frontend.log

# In backend.log, near end:
Files modified:
- /src/api/auth/register.ts
- /src/api/auth/login.ts                     &larr; Work completed</pre>
      </div>

      <p><strong>Monitor workers:</strong></p>
      <div class="code-block-wrapper">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code># Watch backend progress
tail -f backend.log

# In another terminal, watch frontend
tail -f frontend.log</code></pre>
      </div>
    </div>

    <h3><span class="bionic">Int</span>ermediate: Git <span class="bionic">Wor</span>ktrees</h3>

    <p>Isolate workers by filesystem:</p>

    <div class="code-block-wrapper">
      <button class="copy-btn" onclick="copyCode(this)">Copy</button>
      <pre><code># Create worktrees for each worker
git worktree add ../auth-backend feature/auth-backend
git worktree add ../auth-frontend feature/auth-frontend
git worktree add ../auth-tests feature/auth-tests

# Run workers in parallel
(cd ../auth-backend &amp;&amp; claude "Implement auth backend...") &amp;
(cd ../auth-frontend &amp;&amp; claude "Implement auth frontend...") &amp;
wait

# Sequential tests after parallel work completes
cd ../auth-tests &amp;&amp; claude "Write auth tests..."

# Merge back
git checkout main
git merge feature/auth-backend
git merge feature/auth-frontend
git merge feature/auth-tests</code></pre>
    </div>

    <div class="checkpoint">
      <div class="checkpoint-header">Checkpoint: After Git Worktrees Setup</div>
      <p><strong>Where you are:</strong> You have isolated filesystem environments for parallel agent work via git worktrees.</p>
      <p><strong>What this enables:</strong> True parallel execution without file conflicts. Each agent has complete isolation.</p>

      <p><strong>Verify your state:</strong></p>
      <div class="code-block-wrapper">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code># List all worktrees
git worktree list

# Check each worktree is on correct branch
cd ../auth-backend &amp;&amp; git branch --show-current
cd ../auth-frontend &amp;&amp; git branch --show-current

# Verify worktrees are independent
ls ../auth-backend/src &amp;&amp; ls ../auth-frontend/src</code></pre>
      </div>

      <div class="expected-output">
        <p><strong>You should see:</strong></p>
        <pre>/Users/you/project           abc1234 [main]
/Users/you/auth-backend      def5678 [feature/auth-backend]   &larr; Worktree 1
/Users/you/auth-frontend     ghi9012 [feature/auth-frontend]  &larr; Worktree 2
/Users/you/auth-tests        jkl3456 [feature/auth-tests]     &larr; Worktree 3

feature/auth-backend    &larr; On correct branch
feature/auth-frontend   &larr; On correct branch

# Both directories have src/ but are independent copies</pre>
      </div>
    </div>

    <h3><span class="bionic">Adv</span>anced: CC <span class="bionic">Mir</span>ror <span class="bionic">Nat</span>ive</h3>

    <p>Use Claude Code's native Task tool with orchestrator prompt:</p>

    <div class="code-block-wrapper">
      <button class="copy-btn" onclick="copyCode(this)">Copy</button>
      <pre><code># .claude/orchestrator.md

You are an orchestrator. Your only tool is Task.

For this session, break work into:
1. Backend tasks (subagent_type: "coder")
2. Frontend tasks (subagent_type: "coder")
3. Test tasks (subagent_type: "coder")

Each worker prompt must include:
- WORKER CONTEXT header
- Explicit scope boundaries
- "Do NOT spawn sub-agents" rule
- Required verification steps</code></pre>
    </div>

    <hr class="section-divider">

    <h2 id="when-to-use"><span class="bionic">Whe</span>n to <span class="bionic">Use</span> <span class="bionic">Eac</span>h <span class="bionic">App</span>roach</h2>

    <div class="recommendation">
      <p><strong>Use Generalist When:</strong></p>
      <ul>
        <li>Task is simple (&lt; 30 min equivalent human time)</li>
        <li>Single domain (backend only, frontend only)</li>
        <li>Exploratory/research work</li>
        <li>Quick iterations with human feedback</li>
        <li>Budget constraints (one agent is cheaper)</li>
        <li>Learning the codebase (context sharing is valuable)</li>
      </ul>
    </div>

    <div class="recommendation">
      <p><strong>Use Swarm When:</strong></p>
      <ul>
        <li>Multi-domain work (full-stack features)</li>
        <li>Task size would exhaust context window</li>
        <li>Parallelism provides significant time savings</li>
        <li>Quality requirements are high per domain</li>
        <li>Team is comfortable with orchestration overhead</li>
        <li>Overnight/AFK execution desired</li>
      </ul>
    </div>

    <div class="recommendation">
      <p><strong>Hybrid Approach:</strong></p>
      <ul>
        <li>Use generalist for planning and exploration</li>
        <li>Spawn swarm for execution once plan is clear</li>
        <li>Generalist synthesizes and reviews swarm output</li>
      </ul>
    </div>

    <hr class="section-divider">

    <h2 id="anti-patterns"><span class="bionic">Ant</span>i-Patterns to <span class="bionic">Avo</span>id</h2>

    <div class="anti-pattern">
      <h4>1. Spawning Workers for Simple Tasks</h4>
      <p><strong>BAD:</strong> Orchestrator spawns worker to add a comment</p>
      <p><strong>GOOD:</strong> Just do it directly (if generalist) or batch with other work</p>
    </div>

    <div class="anti-pattern">
      <h4>2. Deep Worker Nesting</h4>
      <p><strong>BAD:</strong> Orchestrator &rarr; Worker &rarr; SubWorker &rarr; SubSubWorker</p>
      <p><strong>GOOD:</strong> Orchestrator &rarr; Worker (flat structure, max 2 levels)</p>
    </div>

    <div class="anti-pattern">
      <h4>3. Orchestrator Doing Code</h4>
      <p><strong>BAD:</strong> Orchestrator: "Let me just quickly fix this bug..."</p>
      <p><strong>GOOD:</strong> Orchestrator: "Spawning bugfix worker for issue #123..."</p>
    </div>

    <div class="anti-pattern">
      <h4>4. Workers Spawning Workers</h4>
      <p><strong>BAD:</strong> Backend Worker spawns "DB Worker" and "API Worker"</p>
      <p><strong>GOOD:</strong> Backend Worker does all backend work, reports to orchestrator</p>
    </div>

    <div class="anti-pattern">
      <h4>5. No Verification Before Complete</h4>
      <p><strong>BAD:</strong> Worker: "I wrote the code, marking complete"</p>
      <p><strong>GOOD:</strong> Worker: "Tests pass: 12/12. Files: [...]. Marking complete."</p>
    </div>

    <hr class="section-divider">

    <h2 id="monitoring"><span class="bionic">Mon</span>itoring the <span class="bionic">Swa</span>rm</h2>

    <h3><span class="bionic">Cla</span>ude HUD for <span class="bionic">Con</span>text <span class="bionic">Tra</span>cking</h3>

    <div class="architecture-diagram">
[Opus 4.5] Orchestrator    ====------ 15% context
[Sonnet]   Backend Worker  ========== 95% context (completing)
[Sonnet]   Frontend Worker ========-- 70% context (in progress)
[Haiku]    Test Worker     ---------- waiting
    </div>

    <h3><span class="bionic">rpa</span>i for <span class="bionic">tmu</span>x <span class="bionic">Man</span>agement</h3>

    <div class="architecture-diagram">
+-------------------------------------------------------------+
| rpai - Agent Monitor                                         |
+-------------------------------------------------------------+
| 1. [IDLE]    orchestrator-main     Last: 2m ago             |
| 2. [ACTIVE]  backend-worker-001    "Writing login endpoint" |
| 3. [ACTIVE]  frontend-worker-001   "Creating LoginForm"     |
| 4. [WAITING] test-worker-001       Blocked by: 2, 3         |
+-------------------------------------------------------------+
    </div>

    <hr class="section-divider">

    <h2 id="troubleshooting"><span class="bionic">Tro</span>ubleshooting</h2>

    <details class="troubleshoot">
      <summary>Workers Interfere With Each Other's Files</summary>
      <div>
        <p><strong>Symptom:</strong> Merge conflicts when combining worker output. One worker overwrites another's changes.</p>
        <p><strong>Cause:</strong> Workers are operating on overlapping file scopes without isolation.</p>
        <p><strong>Fix:</strong></p>
        <div class="code-block-wrapper">
          <button class="copy-btn" onclick="copyCode(this)">Copy</button>
          <pre><code># Option 1: Git worktrees (filesystem isolation)
git worktree add ../backend-work feature/backend
git worktree add ../frontend-work feature/frontend

# Run workers in separate worktrees
(cd ../backend-work &amp;&amp; claude "Backend worker task...") &amp;
(cd ../frontend-work &amp;&amp; claude "Frontend worker task...") &amp;
wait

# Merge back
git merge feature/backend
git merge feature/frontend

# Option 2: Clear scope boundaries in prompts
# Each worker prompt must include explicit file scope:
# "SCOPE: Only modify files in /src/api/** - do NOT touch /src/components/**"</code></pre>
        </div>
      </div>
    </details>

    <details class="troubleshoot">
      <summary>Orchestrator Waits Too Long (No Parallelism)</summary>
      <div>
        <p><strong>Symptom:</strong> Workers run sequentially when they could run in parallel. Total time = sum of all workers.</p>
        <p><strong>Cause:</strong> Dependencies defined too conservatively, or <code>run_in_background: true</code> not used.</p>
        <p><strong>Fix:</strong></p>
        <div class="code-block-wrapper">
          <button class="copy-btn" onclick="copyCode(this)">Copy</button>
          <pre><code># Check which workers have no dependencies
# These can run in parallel

# In orchestrator prompt, explicitly mark parallel-safe tasks:
# Task 1: Backend DB schema (no dependencies) -&gt; run_in_background: true
# Task 2: Frontend static components (no dependencies) -&gt; run_in_background: true
# Task 3: Integration tests (depends on 1+2) -&gt; wait for both, then run

# Manual parallel launch:
claude "Backend task..." &amp;
claude "Frontend task..." &amp;
wait  # Wait for both to complete
claude "Test task..."  # Sequential after parallel</code></pre>
        </div>
      </div>
    </details>

    <details class="troubleshoot">
      <summary>Worker Spawns Sub-Workers (Nesting)</summary>
      <div>
        <p><strong>Symptom:</strong> Backend worker spawns "DB worker" and "API worker". Deep hierarchy, hard to track.</p>
        <p><strong>Cause:</strong> Worker prompt didn't prohibit Task tool usage, or task was too large for single worker.</p>
        <p><strong>Fix:</strong></p>
        <div class="code-block-wrapper">
          <button class="copy-btn" onclick="copyCode(this)">Copy</button>
          <pre><code># Add to EVERY worker preamble:

## WORKER RULES (NON-NEGOTIABLE)
- Do NOT spawn sub-agents
- Do NOT call Task, TaskCreate, or TaskList
- Complete the ENTIRE task yourself
- If task is too large, report back to orchestrator

# If tasks genuinely need splitting, do it at orchestrator level:
# BAD:  Orchestrator -&gt; Backend Worker -&gt; DB Worker + API Worker
# GOOD: Orchestrator -&gt; DB Worker + API Worker (flat)</code></pre>
        </div>
      </div>
    </details>

    <details class="troubleshoot">
      <summary>Worker Reports Complete But Verification Fails</summary>
      <div>
        <p><strong>Symptom:</strong> Worker says "Done!" but tests fail when orchestrator checks.</p>
        <p><strong>Cause:</strong> Worker prompt didn't require verification before reporting, or verification command is wrong.</p>
        <p><strong>Fix:</strong></p>
        <div class="code-block-wrapper">
          <button class="copy-btn" onclick="copyCode(this)">Copy</button>
          <pre><code># Add to worker preamble:

## VERIFICATION REQUIREMENTS
Before reporting complete, you MUST:
1. Run: npm run typecheck
2. Run: npm run test:[domain]
3. Include test results in your report

If any verification fails:
- Fix the issue
- Re-run verification
- Only report complete when ALL pass

## REPORT FORMAT
Files modified:
- /path/to/file.ts (what changed)

Verification:
- typecheck: PASS (0 errors)
- tests: PASS (12/12)

# Orchestrator should verify claims independently</code></pre>
        </div>
      </div>
    </details>

    <details class="troubleshoot">
      <summary>Swarm Cost Is Too High</summary>
      <div>
        <p><strong>Symptom:</strong> Multiple workers + orchestrator = 3-5x the token cost of a generalist approach.</p>
        <p><strong>Cause:</strong> Swarm pattern has overhead. Not all tasks benefit from it.</p>
        <p><strong>Fix:</strong></p>
        <div class="code-block-wrapper">
          <pre><code>Cost-benefit analysis before swarm:

Generalist cost: ~50K tokens x 1 agent = 50K tokens
Swarm cost: ~30K tokens x 4 agents = 120K tokens

BUT:
Generalist time: 4 hours sequential
Swarm time: 90 minutes parallel

When to accept higher cost:
- Time savings justify cost (billing rate &gt; token cost)
- Quality improvement justifies cost (fewer bugs to fix later)
- Parallelism is required (deadline)

When to use generalist:
- Task &lt; 30 minutes
- Single domain (no parallelism benefit)
- Exploration/learning (context sharing valuable)
- Budget constrained</code></pre>
        </div>
      </div>
    </details>

    <details class="troubleshoot">
      <summary>Can't Monitor Swarm Progress</summary>
      <div>
        <p><strong>Symptom:</strong> Multiple workers running, no idea what's happening, anxiety increases.</p>
        <p><strong>Cause:</strong> No monitoring infrastructure set up.</p>
        <p><strong>Fix:</strong></p>
        <div class="code-block-wrapper">
          <button class="copy-btn" onclick="copyCode(this)">Copy</button>
          <pre><code># Option 1: Log files per worker
(cd ../backend &amp;&amp; claude "..." &gt; backend.log 2&gt;&amp;1) &amp;
(cd ../frontend &amp;&amp; claude "..." &gt; frontend.log 2&gt;&amp;1) &amp;

# Monitor in separate terminals
tail -f backend.log
tail -f frontend.log

# Option 2: tmux session with panes
tmux new-session -d -s swarm
tmux split-window -h -t swarm
tmux send-keys -t swarm:0.0 'tail -f backend.log' Enter
tmux send-keys -t swarm:0.1 'tail -f frontend.log' Enter
tmux attach -t swarm

# Option 3: Simple status check
watch -n 5 'echo "Backend:"; tail -3 backend.log; echo "Frontend:"; tail -3 frontend.log'</code></pre>
        </div>
      </div>
    </details>

    <details class="troubleshoot">
      <summary>Merge Conflicts After Worker Completion</summary>
      <div>
        <p><strong>Symptom:</strong> Workers complete successfully in worktrees, but <code>git merge</code> fails with conflicts.</p>
        <p><strong>Cause:</strong> Workers modified the same file (boundary violation) or shared dependencies changed.</p>
        <p><strong>Fix:</strong></p>
        <div class="code-block-wrapper">
          <button class="copy-btn" onclick="copyCode(this)">Copy</button>
          <pre><code># Before merging, check for conflicts
git merge --no-commit --no-ff feature/backend
git diff --name-only --diff-filter=U  # List conflicted files

# If conflicts exist:
# Option 1: Resolve manually
git checkout --conflict=merge &lt;file&gt;
# Edit file to resolve
git add &lt;file&gt;
git commit

# Option 2: Sequential merge with human review
git merge feature/backend
# Review changes
git merge feature/frontend
# Resolve any conflicts interactively

# Prevention: Ensure worker scopes don't overlap
# Backend: /src/api/**, /db/**
# Frontend: /src/components/**, /src/hooks/**
# Tests: /tests/**
# No overlap = no conflicts</code></pre>
        </div>
      </div>
    </details>

    <h3><span class="bionic">Ter</span>minal <span class="bionic">Out</span>put: <span class="bionic">Suc</span>cessful <span class="bionic">Swa</span>rm <span class="bionic">Run</span></h3>

    <p>Here's what a healthy swarm execution looks like:</p>

    <div class="code-block-wrapper">
      <pre><code>$ ./run-swarm.sh

=== Swarm Orchestrator Starting ===
Task: User Authentication System
Workers: 3 (backend, frontend, test)

[00:00] Spawning Backend Worker (parallel)
        Scope: /src/api/auth/**, /db/migrations/**
        Background PID: 12345

[00:00] Spawning Frontend Worker (parallel)
        Scope: /src/components/auth/**, /src/context/**
        Background PID: 12346

[00:02] Backend Worker progress: Creating migrations...
[00:05] Frontend Worker progress: Building LoginForm...
[00:15] Backend Worker progress: Implementing endpoints...
[00:20] Frontend Worker progress: Creating AuthContext...

[00:35] Backend Worker COMPLETE
        Files: 8 modified
        Tests: 12/12 passed
        Branch: feature/auth-backend

[00:40] Frontend Worker COMPLETE
        Files: 6 modified
        Tests: 8/8 passed
        Branch: feature/auth-frontend

[00:41] Spawning Test Worker (sequential, depends on backend+frontend)
        Scope: /tests/integration/**, /tests/e2e/**

[00:55] Test Worker COMPLETE
        Files: 2 created
        Integration: 6/6 passed
        E2E: 4/4 passed

[00:56] Merging branches...
        feature/auth-backend -&gt; main: SUCCESS
        feature/auth-frontend -&gt; main: SUCCESS (no conflicts)
        feature/auth-tests -&gt; main: SUCCESS

=== Swarm Complete ===
Total time: 56 minutes
Files changed: 16
Tests passed: 30/30
Ready for human review.</code></pre>
    </div>

    <div class="milestone">
      The transformation from generalist to swarm is not about adding complexity for its own sake. It's about matching architecture to workload.
    </div>

    <hr class="section-divider">

    <div class="related-pages">
      <h3>Related Pages</h3>
      <ul>
        <li><a href="taxonomy-architectures.html">Architecture Taxonomy (CC Mirror Hub-and-Spoke)</a></li>
        <li><a href="taxonomy-orchestration.html">Orchestration Pattern Taxonomy</a></li>
        <li><a href="architecture-domain-isolation.html">Domain Isolation Strategies</a></li>
        <li><a href="transform-single-to-autonomous.html">Transform: Single to Autonomous</a></li>
      </ul>
    </div>

    <div class="footer-nav">
      <a href="transform-manual-to-filesystem.html" class="nav-prev">
        <span class="nav-direction">&larr; Previous</span>
        <span class="nav-title">Manual to Filesystem</span>
      </a>
      <a href="transform-master.html" class="nav-next">
        <span class="nav-direction">Next &rarr;</span>
        <span class="nav-title">All Transformations</span>
      </a>
    </div>

  </div>

  <script>
    function copyCode(btn) {
      const pre = btn.parentElement.querySelector('pre');
      const code = pre.querySelector('code') || pre;
      navigator.clipboard.writeText(code.textContent);
      btn.textContent = 'Copied!';
      setTimeout(() => btn.textContent = 'Copy', 2000);
    }
  </script>
  <script src="../js/copy-code.js"></script>
  <script src="../js/search.js"></script>
  <script src="../js/global-nav.js"></script>
</body>
</html>
