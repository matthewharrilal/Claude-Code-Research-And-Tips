<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta data-pagefind-meta="section" content="Synthesis">
  <meta data-pagefind-meta="category" content="Principles">
  <title>Anti-Pattern Analysis for Claude Code Workflows - Claude Code Knowledge Base</title>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="stylesheet" href="../css/sidebar.css">
  <link rel="stylesheet" href="../css/search.css">
</head>
<body>
  <!-- Search Modal -->
  <div class="search-modal" id="searchModal" aria-hidden="true">
    <div class="search-overlay" onclick="closeSearch()"></div>
    <div class="search-content">
      <div class="search-header">
        <div class="search-input-wrapper">
          <span class="search-icon-input">&#128269;</span>
          <input type="text" id="searchInput" placeholder="Search documentation..." autocomplete="off" />
          <kbd class="search-kbd">ESC</kbd>
        </div>
      </div>
      <div class="search-filters">
        <button class="filter-btn active" data-filter="all">All</button>
        <button class="filter-btn" data-filter="synthesis">Synthesis</button>
        <button class="filter-btn" data-filter="extractions">Extractions</button>
      </div>
      <div class="search-results" id="searchResults">
        <div class="search-empty"><p>Start typing to search... (Press Cmd+K anytime)</p></div>
      </div>
      <div class="search-footer">
        <span>Up/Down Navigate</span><span>Enter Select</span><span>ESC Close</span>
      </div>
    </div>
  </div>

  <button class="search-trigger" onclick="openSearch()" aria-label="Search" style="float: right; margin-bottom: 1rem;">
    <span class="search-icon">Cmd+K</span>
    <span class="search-text">Search</span>
  </button>

  <nav class="left-nav" id="leftNav">
    <div class="px-4 mb-4">
      <a href="../index.html" class="text-xs font-semibold text-accent hover:text-accent-light uppercase tracking-wider">Claude Code KB</a>
    </div>
    <div class="nav-content"></div>
  </nav>

  <div class="container">
    <!-- Breadcrumb Navigation -->
    <nav class="nav-breadcrumb">
      <a href="../index.html">Home</a>
      <span>/</span>
      <a href="synthesis-index.html">Synthesis</a>
      <span>/</span>
      <a href="principles-master.html">Principles</a>
      <span>/</span>
      <span>Anti-Patterns</span>
    </nav>

    <!-- You Are Here Context Box -->
    <div class="you-are-here" style="background: linear-gradient(135deg, #f0ebe3 0%, #fefcf3 100%); border-left: 4px solid #2a7d7d; border-radius: 8px; padding: 1.5rem; margin-bottom: 2rem;">
      <h3 style="color: #2a7d7d; margin-top: 0; font-size: 0.9em; text-transform: uppercase; letter-spacing: 0.5px;">You Are Here</h3>
      <p style="margin-bottom: 0;">This is the <strong>"what NOT to do" guide</strong> - a comprehensive catalog of failure modes organized by category. Read this when something goes wrong to diagnose the issue, or before starting a complex project to avoid known pitfalls. Companion to <a href="principles-core.html">Core Principles</a> (the WHY) - this doc shows the consequences of violating those principles.</p>
    </div>

    <h1><span class="bionic">Ant</span>i-Pattern <span class="bionic">Ana</span>lysis for <span class="bionic">Cla</span>ude <span class="bionic">Code</span></h1>

    <p class="conversational-lead">
      Identify what does <strong>not</strong> work and why, enabling practitioners to avoid common pitfalls.
    </p>

    <!-- Table of Contents -->
    <div class="toc">
      <div class="toc-title">Contents</div>
      <ul>
        <li><a href="#context-anti-patterns">Context Anti-Patterns</a></li>
        <li><a href="#orchestration-anti-patterns">Orchestration Anti-Patterns</a></li>
        <li><a href="#task-design-anti-patterns">Task Design Anti-Patterns</a></li>
        <li><a href="#prompting-anti-patterns">Prompting Anti-Patterns</a></li>
        <li><a href="#configuration-anti-patterns">Configuration Anti-Patterns</a></li>
        <li><a href="#multi-agent-anti-patterns">Multi-Agent Anti-Patterns</a></li>
        <li><a href="#verification-anti-patterns">Verification Anti-Patterns</a></li>
        <li><a href="#memory-anti-patterns">Memory &amp; State Anti-Patterns</a></li>
        <li><a href="#tool-anti-patterns">Tool Usage Anti-Patterns</a></li>
        <li><a href="#cost-anti-patterns">Cost Anti-Patterns</a></li>
        <li><a href="#security-anti-patterns">Security Anti-Patterns</a></li>
        <li><a href="#ralph-anti-patterns">Ralph Loop Anti-Patterns</a></li>
        <li><a href="#misconceptions">Misconceptions &amp; Debunked Claims</a></li>
        <li><a href="#when-not-to-use">When NOT to Use Claude Code</a></li>
        <li><a href="#detection-checklist">Anti-Pattern Detection Checklist</a></li>
        <li><a href="#recovery">Recovery Strategies</a></li>
      </ul>
    </div>

    <hr class="section-divider">

    <!-- Context Anti-Patterns -->
    <section id="context-anti-patterns">
      <h2><span class="bionic">Con</span>text <span class="bionic">Ant</span>i-Patterns</h2>

      <div class="gotcha-block">
        <h4>Long Single-Thread Conversations</h4>
        <p><strong>What happens:</strong> Context fills, response quality progressively degrades, instructions get ignored, Claude "forgets" recent work or hallucinates file contents.</p>
        <p><strong>Why it fails:</strong> Context rot accumulates. As conversations grow, earlier instructions and context get compressed or lost.</p>
        <p><strong>Warning signs:</strong></p>
        <ul>
          <li>Repetitive or contradictory responses</li>
          <li>CLAUDE.md directives being ignored</li>
          <li>Claude referencing files that don't exist</li>
          <li>Truncated code outputs (functions cut off mid-definition)</li>
          <li>Claude "forgets" work done 30 minutes ago in same session</li>
        </ul>
        <p><strong>The fix:</strong></p>
        <ul>
          <li>Use Ralph pattern: fresh context per iteration</li>
          <li>Persist state externally (files, git history, progress.txt)</li>
          <li>Start new sessions for unrelated tasks</li>
          <li>Use <code>/compact</code> proactively at 60-70% context usage</li>
        </ul>
      </div>

      <div class="gotcha-block">
        <h4>Trusting Compaction Blindly</h4>
        <p><strong>What happens:</strong> Important nuance lost during summarization. Critical instructions or edge cases get dropped.</p>
        <p><strong>Why it fails:</strong> Compaction is lossy. The model must decide what's "important" without knowing your actual priorities.</p>
        <p><strong>The fix:</strong></p>
        <ul>
          <li>Maintain external state manually (reflection files, progress logs)</li>
          <li>Use explicit instruction files (CLAUDE.md) that survive compaction</li>
          <li>Compact proactively at 60-70% rather than waiting for auto-compact at 95%</li>
        </ul>
      </div>

      <div class="gotcha-block">
        <h4>Reading Entire Codebase</h4>
        <p><strong>What happens:</strong> Context fills immediately with thousands of tokens, leaving no room for actual work.</p>
        <p><strong>Bad prompt:</strong></p>
        <div class="code-block">
          <pre><code>"Read all the files in src/ to understand the architecture"</code></pre>
        </div>
        <p><strong>Good prompt:</strong></p>
        <div class="code-block">
          <pre><code>"Read src/index.ts and src/config.ts to understand the entry point"</code></pre>
        </div>
        <p><strong>The fix:</strong> Use .claudeignore aggressively, request targeted reads, use subagents for exploration.</p>
      </div>

      <div class="gotcha-block">
        <h4>Including Build Outputs in Context</h4>
        <p><strong>What happens:</strong> node_modules/, dist/, .next/, coverage/ consume massive context budget uselessly.</p>
        <p><strong>The fix:</strong></p>
        <div class="code-block">
          <button class="copy-btn" onclick="copyCode(this)">Copy</button>
          <pre><code># .claudeignore
node_modules/
dist/
build/
.next/
.cache/
*.log
coverage/</code></pre>
        </div>
      </div>

      <!-- Checkpoint -->
      <div class="checkpoint" style="background: #f0ebe3; border-left: 4px solid #6b9b7a; border-radius: 8px; padding: 1.5rem; margin: 2rem 0;">
        <div class="checkpoint-header" style="color: #6b9b7a; font-weight: 600;">Checkpoint: Context Anti-Patterns</div>
        <p><strong>You should now understand:</strong></p>
        <ul>
          <li>The 4 major context anti-patterns and their symptoms</li>
          <li>Why compaction should be proactive (60-70%) not reactive (95%)</li>
          <li>The importance of .claudeignore for build outputs</li>
          <li>When to use subagents vs. targeted file reads</li>
        </ul>
        <p><strong>If unclear:</strong> See <a href="principles-core.html">Core Principles</a> Principle 1 (Context Is Primary Constraint) for the theory.</p>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Orchestration Anti-Patterns -->
    <section id="orchestration-anti-patterns">
      <h2><span class="bionic">Orc</span>hestration <span class="bionic">Ant</span>i-Patterns</h2>

      <div class="gotcha-block">
        <h4>Workers Spawning Workers (Recursive Explosion)</h4>
        <p><strong>What happens:</strong> A worker agent spawns subagents, which spawn more subagents, creating exponential context explosion and potential infinite loops.</p>
        <p><strong>Warning signs:</strong></p>
        <ul>
          <li>Subagent depth &gt;2 levels</li>
          <li>Context usage spiking unexpectedly</li>
          <li>Tasks taking 10x longer than expected</li>
          <li>Runaway API costs</li>
        </ul>
        <p><strong>The fix:</strong> Worker preamble pattern:</p>
        <div class="code-block">
          <button class="copy-btn" onclick="copyCode(this)">Copy</button>
          <pre><code>CONTEXT: You are a WORKER agent, not an orchestrator.

RULES:
- Complete ONLY the task described below
- Use tools directly (Read, Write, Edit, Bash, etc.)
- Do NOT spawn sub-agents
- Do NOT call TaskCreate or TaskUpdate
- Report your results with absolute file paths</code></pre>
        </div>
      </div>

      <div class="gotcha-block">
        <h4>Orchestrator Using Tools Directly</h4>
        <p><strong>What happens:</strong> Orchestrator gets distracted by implementation details. Role confusion between planning and execution.</p>
        <p><strong>The CC Mirror principle:</strong></p>
        <blockquote>
          <p>YOU DO NOT WRITE CODE. YOU DO NOT RUN COMMANDS. YOU DO NOT EXPLORE CODEBASES. You are the CONDUCTOR. Your agents play the instruments.</p>
        </blockquote>
        <p><strong>Orchestrator uses:</strong> TaskCreate, TaskList, TaskGet, TaskUpdate, AskUserQuestion, Task (to spawn workers), Read (reference files only, 1-2 max)</p>
        <p><strong>Workers use:</strong> Read, Write, Edit, Bash, Glob, Grep, WebFetch, WebSearch, LSP</p>
      </div>

      <div class="gotcha-block">
        <h4>No Completion Detection</h4>
        <p><strong>What happens:</strong> Agents run indefinitely without knowing when to stop. Infinite loops consuming API budget.</p>
        <p><strong>The fix:</strong> Completion promise pattern:</p>
        <div class="code-block">
          <button class="copy-btn" onclick="copyCode(this)">Copy</button>
          <pre><code>if grep -q "PROMISE COMPLETE HERE" output.txt; then
  break
fi</code></pre>
        </div>
        <p>Or use testable completion criteria: All PRD items have <code>passes: true</code>, tests pass, build succeeds.</p>
      </div>

      <div class="gotcha-block">
        <h4>Sequential When Parallel Is Possible</h4>
        <p><strong>What happens:</strong> Tasks that could run in parallel are executed sequentially, wasting time.</p>
        <p><strong>The fix:</strong></p>
        <ul>
          <li>Spawn multiple background subagents for independent tasks</li>
          <li>Use git worktrees for parallel feature branches</li>
          <li>Identify task dependencies; parallelize where no dependencies exist</li>
        </ul>
      </div>

      <!-- Checkpoint -->
      <div class="checkpoint" style="background: #f0ebe3; border-left: 4px solid #6b9b7a; border-radius: 8px; padding: 1.5rem; margin: 2rem 0;">
        <div class="checkpoint-header" style="color: #6b9b7a; font-weight: 600;">Checkpoint: Orchestration Anti-Patterns</div>
        <p><strong>You should now understand:</strong></p>
        <ul>
          <li>Why workers must NEVER spawn subagents (prevents recursion)</li>
          <li>Why orchestrators must NOT use implementation tools</li>
          <li>The completion promise pattern for loop termination</li>
          <li>When to parallelize vs. serialize tasks</li>
        </ul>
        <p><strong>If unclear:</strong> See <a href="architecture-composition-rules.html">Architecture Composition Rules</a> for valid orchestration patterns.</p>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Task Design Anti-Patterns -->
    <section id="task-design-anti-patterns">
      <h2><span class="bionic">Task</span> <span class="bionic">Des</span>ign <span class="bionic">Ant</span>i-Patterns</h2>

      <div class="gotcha-block">
        <h4>Tasks Too Large (Context Collapse)</h4>
        <p><strong>What happens:</strong> Scope creep, context exhaustion, incomplete work, degraded quality mid-task.</p>
        <p><strong>Bad task:</strong></p>
        <div class="code-block">
          <pre><code>"Build the entire authentication system"</code></pre>
        </div>
        <p><strong>Good task:</strong></p>
        <div class="code-block">
          <pre><code>"Implement the login endpoint with:
1. Email/password validation
2. JWT token generation
3. Rate limiting (5 attempts/minute)"</code></pre>
        </div>
        <p><strong>Sizing heuristics:</strong></p>
        <ul>
          <li>~100-500 lines of code change</li>
          <li>~1-3 files modified</li>
          <li>~30-60 minutes equivalent human time</li>
          <li>Clear, testable success criteria</li>
        </ul>
      </div>

      <div class="gotcha-block">
        <h4>Vague Acceptance Criteria</h4>
        <p><strong>What happens:</strong> Claude produces wrong outputs because it doesn't know what "done" looks like.</p>
        <p><strong>Bad criteria:</strong></p>
        <div class="code-block">
          <pre><code>"Make it work"
"Fix the bug"
"Clean up the code"</code></pre>
        </div>
        <p><strong>Good criteria:</strong></p>
        <div class="code-block">
          <button class="copy-btn" onclick="copyCode(this)">Copy</button>
          <pre><code>{
  "delete_video_shows_confirmation": {
    "description": "Delete video shows confirmation dialog before deleting",
    "acceptance": "User clicks delete, modal appears with 'Confirm' and 'Cancel', clicking 'Cancel' preserves video"
  }
}</code></pre>
        </div>
      </div>

      <div class="gotcha-block">
        <h4>Tasks Too Small (Overhead Exceeds Value)</h4>
        <p><strong>What happens:</strong> More time spent spawning agents than doing useful work.</p>
        <p><strong>Too small:</strong></p>
        <div class="code-block">
          <pre><code>"Add a comment to line 42"
"Rename variable x to count"</code></pre>
        </div>
        <p><strong>Just right:</strong></p>
        <div class="code-block">
          <pre><code>"Implement the User model with email, password hash, and created_at fields"</code></pre>
        </div>
      </div>

      <!-- Checkpoint -->
      <div class="checkpoint" style="background: #f0ebe3; border-left: 4px solid #6b9b7a; border-radius: 8px; padding: 1.5rem; margin: 2rem 0;">
        <div class="checkpoint-header" style="color: #6b9b7a; font-weight: 600;">Checkpoint: Task Design Anti-Patterns</div>
        <p><strong>You should now understand:</strong></p>
        <ul>
          <li>The ~100-500 LOC / 1-3 files / 30-60 min sizing heuristics</li>
          <li>Why acceptance criteria must be testable, not vague</li>
          <li>When task overhead exceeds value (tasks too small)</li>
          <li>How to use blockedBy for dependent tasks</li>
        </ul>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Prompting Anti-Patterns -->
    <section id="prompting-anti-patterns">
      <h2><span class="bionic">Pro</span>mpting <span class="bionic">Ant</span>i-Patterns</h2>

      <div class="gotcha-block">
        <h4>Vague Instructions</h4>
        <p><strong>What happens:</strong> Claude makes assumptions that don't match your intent.</p>
        <p><strong>Bad:</strong> "Fix the bug" | "Make it better"</p>
        <p><strong>Good:</strong> "Fix the null pointer exception on line 42 of src/auth/login.ts where user.email is accessed before validation"</p>
      </div>

      <div class="gotcha-block">
        <h4>Implicit Context Assumptions</h4>
        <p><strong>What happens:</strong> Claude uses wrong patterns because it doesn't know your conventions.</p>
        <p><strong>Bad:</strong> "Use the same pattern as before"</p>
        <p><strong>Good:</strong> "Use the repository pattern from src/data/UserRepository.ts"</p>
        <p><strong>The fix:</strong> Explicit references to existing code, comprehensive CLAUDE.md with patterns and conventions.</p>
      </div>

      <div class="gotcha-block">
        <h4>Fighting Claude's Patterns</h4>
        <p><strong>What happens:</strong> Endless iterations trying to force Claude into unfamiliar patterns.</p>
        <p><strong>The fix:</strong></p>
        <ul>
          <li>Accept Claude's idiomatic suggestions</li>
          <li>Focus on outcomes, not style</li>
          <li>If a pattern is critical, provide explicit examples</li>
          <li>Add patterns to CLAUDE.md for consistency</li>
        </ul>
      </div>

      <div class="gotcha-block">
        <h4>Monolithic Prompts</h4>
        <p><strong>What happens:</strong> Claude gets overwhelmed, forgets parts of the request, produces inconsistent output.</p>
        <p><strong>Bad:</strong> "Build user auth with login, signup, password reset, OAuth, 2FA, session management, and admin roles"</p>
        <p><strong>Good:</strong> Break into sequential, focused requests with clear handoffs between each.</p>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Configuration Anti-Patterns -->
    <section id="configuration-anti-patterns">
      <h2><span class="bionic">Con</span>figuration <span class="bionic">Ant</span>i-Patterns</h2>

      <div class="gotcha-block">
        <h4>--dangerously-skip-permissions Everywhere</h4>
        <p><strong>What happens:</strong> Claude can execute ANY command, including destructive ones.</p>
        <p><strong>Dangerous:</strong></p>
        <div class="code-block">
          <pre><code>alias claude='claude --dangerously-skip-permissions'</code></pre>
        </div>
        <p><strong>The fix:</strong> Use granular permission whitelisting:</p>
        <div class="code-block">
          <button class="copy-btn" onclick="copyCode(this)">Copy</button>
          <pre><code>{
  "permissions": {
    "commands": {
      "git status": "allow-always",
      "npm test": "allow-always",
      "npm run build": "allow-always"
    },
    "blockedPatterns": [
      "rm -rf",
      "sudo",
      "git push --force",
      "git reset --hard"
    ]
  }
}</code></pre>
        </div>
      </div>

      <div class="gotcha-block">
        <h4>No .claudeignore</h4>
        <p><strong>What happens:</strong> Secrets exposed, build outputs waste context, security risk.</p>
        <p><strong>Minimum .claudeignore:</strong></p>
        <div class="code-block">
          <button class="copy-btn" onclick="copyCode(this)">Copy</button>
          <pre><code>.env*
*.pem
*.key
credentials.json
secrets/
node_modules/
dist/
build/
.next/
coverage/
*.log</code></pre>
        </div>
      </div>

      <div class="gotcha-block">
        <h4>CLAUDE.md Too Long</h4>
        <p><strong>What happens:</strong> Instructions consume context budget, leaving less for actual work.</p>
        <p><strong>Bad:</strong> 2000+ token CLAUDE.md with verbose explanations.</p>
        <p><strong>The fix:</strong> Keep under 500 tokens. Essential information only. Use file imports for detailed references.</p>
      </div>

      <div class="gotcha-block">
        <h4>CLAUDE.md Too Generic</h4>
        <p><strong>What happens:</strong> Claude makes wrong assumptions every session. Same mistakes repeated.</p>
        <p><strong>Include in CLAUDE.md:</strong> Actual development commands, your specific patterns, known issues and workarounds, architecture decisions.</p>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Multi-Agent Anti-Patterns -->
    <section id="multi-agent-anti-patterns">
      <h2><span class="bionic">Mul</span>ti-Agent <span class="bionic">Ant</span>i-Patterns</h2>

      <div class="gotcha-block">
        <h4>Parallel Agents Without Isolation</h4>
        <p><strong>What happens:</strong> Merge conflicts, file corruption, race conditions.</p>
        <blockquote>
          <p>"Parallel agents cause merge conflicts--use serial"</p>
          <cite>-- @mattpocockuk</cite>
        </blockquote>
        <p><strong>The fix:</strong></p>
        <ul>
          <li>Branch isolation: each agent works on its own git branch</li>
          <li>Directory ownership: each agent owns specific directories</li>
          <li>Git worktrees for full isolation</li>
          <li>File locking for shared resources</li>
        </ul>
      </div>

      <div class="gotcha-block">
        <h4>Agent Communication Via Context Pollution</h4>
        <p><strong>What happens:</strong> Agents try to pass information through shared conversation, polluting context.</p>
        <p><strong>The fix:</strong></p>
        <ul>
          <li>File-based handoffs: write to handoff-agent1-to-agent2.json</li>
          <li>Git-based handoffs: commit history visible to future agents</li>
          <li>Explicit return values from subagents</li>
        </ul>
      </div>

      <div class="gotcha-block">
        <h4>Missing Worker Preamble</h4>
        <p><strong>What happens:</strong> Workers attempt orchestration, spawn subagents, derail from their task.</p>
        <p><strong>Required preamble:</strong></p>
        <div class="code-block">
          <button class="copy-btn" onclick="copyCode(this)">Copy</button>
          <pre><code>CONTEXT: You are a WORKER agent, not an orchestrator.

RULES:
- Complete ONLY the task described below
- Use tools directly (Read, Write, Edit, Bash)
- Do NOT spawn sub-agents
- Do NOT manage tasks
- Report results with absolute file paths</code></pre>
        </div>
      </div>

      <div class="gotcha-block">
        <h4>No Agent Health Monitoring</h4>
        <p><strong>What happens:</strong> Stuck agents, infinite loops, runaway costs go unnoticed.</p>
        <p><strong>The fix:</strong></p>
        <ul>
          <li>Use Claude HUD plugin for context monitoring</li>
          <li>Use rpai for tmux multi-agent management</li>
          <li>Implement heartbeat logging</li>
          <li>Set maximum iteration limits</li>
        </ul>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Verification Anti-Patterns -->
    <section id="verification-anti-patterns">
      <h2><span class="bionic">Ver</span>ification <span class="bionic">Ant</span>i-Patterns</h2>

      <div class="gotcha-block">
        <h4>No Verification At All</h4>
        <p><strong>What happens:</strong> Subtle bugs ship to production. Claude's output accepted without testing.</p>
        <p><strong>The fix:</strong></p>
        <ul>
          <li>Type checking: <code>npm run typecheck</code></li>
          <li>Unit tests: <code>npm test</code></li>
          <li>Lint: <code>npm run lint</code></li>
          <li>Manual review of diffs before commit</li>
        </ul>
      </div>

      <div class="gotcha-block">
        <h4>Tests Pass But Shouldn't</h4>
        <p><strong>What happens:</strong> Claude reports tests pass, but tests are broken, not running, or trivially passing.</p>
        <p><strong>Detection:</strong></p>
        <div class="code-block">
          <button class="copy-btn" onclick="copyCode(this)">Copy</button>
          <pre><code>npm test 2>&1 | tail -20
echo "Exit code: $?"</code></pre>
        </div>
        <p><strong>The fix:</strong> Always verify test output manually after Claude reports success. Include exit code verification in scripts.</p>
      </div>

      <div class="gotcha-block">
        <h4>Marking Complete Without Testing</h4>
        <p><strong>What happens:</strong> Features marked "done" without end-to-end verification.</p>
        <blockquote>
          <p>"Claude's tendency to mark features complete without proper testing... did much better at verifying end-to-end once explicitly prompted to use browser automation tools"</p>
          <cite>-- Anthropic Best Practices</cite>
        </blockquote>
        <p><strong>The fix:</strong></p>
        <ul>
          <li>Require explicit test results in completion report</li>
          <li>Use Playwright MCP for UI verification</li>
          <li>Include verification steps in every task definition</li>
        </ul>
      </div>

      <div class="gotcha-block">
        <h4>Single-Point Verification</h4>
        <p><strong>What happens:</strong> Only unit tests run. Integration and E2E issues missed.</p>
        <p><strong>The fix:</strong> Layered verification:</p>
        <ol>
          <li>Type check (catches interface mismatches)</li>
          <li>Unit tests (catches logic errors)</li>
          <li>Integration tests (catches component interaction bugs)</li>
          <li>E2E tests (catches user journey issues)</li>
        </ol>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Memory Anti-Patterns -->
    <section id="memory-anti-patterns">
      <h2><span class="bionic">Mem</span>ory &amp; <span class="bionic">Sta</span>te <span class="bionic">Ant</span>i-Patterns</h2>

      <div class="gotcha-block">
        <h4>State In Conversation Only</h4>
        <p><strong>What happens:</strong> Session ends, all context lost. Next session starts from scratch.</p>
        <p><strong>The fix:</strong></p>
        <ul>
          <li>Git commits as memory (each iteration commits)</li>
          <li>progress.txt as append-only learning log</li>
          <li>PRD with <code>passes: true/false</code> status</li>
          <li>Handoff files for inter-agent communication</li>
        </ul>
      </div>

      <div class="gotcha-block">
        <h4>Trusting In-Context Memory</h4>
        <p><strong>What happens:</strong> Claude "forgets" or misremembers earlier conversation content.</p>
        <p><strong>The fix:</strong></p>
        <ul>
          <li>External files as source of truth</li>
          <li>Re-read files rather than relying on memory</li>
          <li>Use explicit file references, not "as we discussed"</li>
        </ul>
      </div>

      <div class="gotcha-block">
        <h4>No Checkpointing</h4>
        <p><strong>What happens:</strong> Crash or failure loses all progress. Must restart from beginning.</p>
        <p><strong>The fix:</strong></p>
        <div class="code-block">
          <button class="copy-btn" onclick="copyCode(this)">Copy</button>
          <pre><code># Save checkpoint every N iterations
git stash create > checkpoint-ref
git diff --cached > staged.diff
cp progress.txt checkpoint/</code></pre>
        </div>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Tool Anti-Patterns -->
    <section id="tool-anti-patterns">
      <h2><span class="bionic">Tool</span> <span class="bionic">Usa</span>ge <span class="bionic">Ant</span>i-Patterns</h2>

      <div class="gotcha-block">
        <h4>Bash for File Reading</h4>
        <p><strong>What happens:</strong> <code>cat</code>, <code>head</code>, <code>tail</code>, <code>grep</code> used instead of Read/Grep tools.</p>
        <p><strong>Why it fails:</strong> Specialized tools are optimized, sandboxed, and provide better error handling.</p>
        <p><strong>Bad:</strong></p>
        <div class="code-block">
          <pre><code>cat src/app.ts
grep "function" src/*.ts</code></pre>
        </div>
        <p><strong>Good:</strong> Use Read tool for file contents, Grep tool for searches, Glob tool for file finding.</p>
      </div>

      <div class="gotcha-block">
        <h4>Spawning Subagents for Simple Lookups</h4>
        <p><strong>What happens:</strong> Overhead of subagent exceeds task value.</p>
        <p><strong>Use tools directly for:</strong> File reads, simple grep searches, file existence checks</p>
        <p><strong>Use subagents for:</strong> Multi-step investigations, tasks requiring isolated context, parallel exploration</p>
      </div>

      <div class="gotcha-block">
        <h4>Wrong Model for Task</h4>
        <p><strong>What happens:</strong> Using Opus for simple file lookups (expensive), or Haiku for architecture decisions (insufficient).</p>
        <div class="table-responsive">
          <table>
            <thead>
              <tr><th>Model</th><th>Use Case</th><th>Cost</th></tr>
            </thead>
            <tbody>
              <tr><td>Haiku</td><td>Simple lookups, file fetching, transforms</td><td>Cheapest</td></tr>
              <tr><td>Sonnet</td><td>Implementation, test generation, patterns</td><td>Medium</td></tr>
              <tr><td>Opus</td><td>Architecture, complex reasoning, ambiguous tasks</td><td>Expensive</td></tr>
            </tbody>
          </table>
        </div>
        <p><strong>Opus costs 60x more than Haiku. Match model to task.</strong></p>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Cost Anti-Patterns -->
    <section id="cost-anti-patterns">
      <h2><span class="bionic">Cost</span> <span class="bionic">Ant</span>i-Patterns</h2>

      <div class="gotcha-block">
        <h4>No Iteration Limits</h4>
        <p><strong>What happens:</strong> Runaway loops consume unlimited API budget. Bills hit hundreds of dollars.</p>
        <p><strong>The fix:</strong></p>
        <div class="code-block">
          <button class="copy-btn" onclick="copyCode(this)">Copy</button>
          <pre><code>MAX_ITERATIONS=25
timeout 3600 ./ralph.sh 50  # 1 hour max</code></pre>
        </div>
      </div>

      <div class="gotcha-block">
        <h4>Opus for Everything</h4>
        <p><strong>What happens:</strong> Massive API bills. $500+ for tasks that could cost $20.</p>
        <p><strong>The fix:</strong></p>
        <ul>
          <li>Use Haiku for exploration and simple tasks</li>
          <li>Use Sonnet for implementation</li>
          <li>Reserve Opus for complex reasoning only</li>
        </ul>
      </div>

      <div class="gotcha-block">
        <h4>No Cost Tracking</h4>
        <p><strong>What happens:</strong> Budget overruns discovered only when bill arrives.</p>
        <p><strong>The fix:</strong></p>
        <ul>
          <li>Monitor Anthropic dashboard</li>
          <li>Implement token logging</li>
          <li>Set hard budget limits</li>
          <li>Track cost per agent/task</li>
        </ul>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Security Anti-Patterns -->
    <section id="security-anti-patterns">
      <h2><span class="bionic">Sec</span>urity <span class="bionic">Ant</span>i-Patterns</h2>

      <div class="gotcha-block">
        <h4>.env Files in Context</h4>
        <p><strong>What happens:</strong> API keys, passwords, tokens leak into conversation history.</p>
        <p><strong>The fix:</strong></p>
        <ul>
          <li>Never <code>cat .env</code> in Claude Code</li>
          <li>Add to .claudeignore</li>
          <li>Use environment variables, not file reads</li>
        </ul>
      </div>

      <div class="gotcha-block">
        <h4>Whitelisting Dangerous Commands</h4>
        <p><strong>Commands to NEVER whitelist:</strong></p>
        <div class="code-block">
          <pre><code># Destructive file operations
rm -rf
find . -delete

# Git destruction
git push --force
git reset --hard
git clean -fd

# System modification
sudo *
chmod -R 777

# Remote code execution
curl | bash
wget -O- | sh</code></pre>
        </div>
      </div>

      <div class="gotcha-block">
        <h4>Path Traversal Not Blocked</h4>
        <p><strong>What happens:</strong> Claude accesses files outside project directory.</p>
        <p><strong>The fix:</strong></p>
        <div class="code-block">
          <button class="copy-btn" onclick="copyCode(this)">Copy</button>
          <pre><code>{
  "permissions": {
    "paths": {
      "deny": ["../**", "/etc/**", "~/.ssh/**", "~/.aws/**"]
    }
  }
}</code></pre>
        </div>
      </div>

      <div class="gotcha-block">
        <h4>Claude Modifying Its Own Instructions</h4>
        <p><strong>What happens:</strong> Prompt injection or accidental CLAUDE.md modification changes behavior.</p>
        <p><strong>The fix:</strong></p>
        <ul>
          <li>Make CLAUDE.md read-only: <code>chmod 444 CLAUDE.md</code></li>
          <li>Version control all configuration files</li>
          <li>Review diffs before committing</li>
        </ul>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Ralph Anti-Patterns -->
    <section id="ralph-anti-patterns">
      <h2><span class="bionic">Ral</span>ph <span class="bionic">Loop</span> <span class="bionic">Ant</span>i-Patterns</h2>

      <div class="gotcha-block">
        <h4>Completion Promise Never Found</h4>
        <p><strong>What happens:</strong> Loop runs indefinitely. Consumes massive tokens. Never terminates.</p>
        <p><strong>The fix:</strong></p>
        <ul>
          <li>Ensure completion promise is actually achievable</li>
          <li>Include timeout: <code>timeout 3600 ./ralph.sh 50</code></li>
          <li>Set maximum iterations: <code>MAX_ITERATIONS=25</code></li>
        </ul>
      </div>

      <div class="gotcha-block">
        <h4>PRD Items Too Complex</h4>
        <p><strong>What happens:</strong> Single PRD item cannot be completed in one context window.</p>
        <p><strong>The fix:</strong></p>
        <ul>
          <li>Each PRD item completable in 30-60 minutes equivalent human time</li>
          <li>~100-500 lines of code change per item</li>
          <li>Clear, testable acceptance criteria</li>
        </ul>
      </div>

      <div class="gotcha-block">
        <h4>No External Memory</h4>
        <p><strong>What happens:</strong> Each iteration loses learnings from previous iterations.</p>
        <p><strong>Required external memory:</strong></p>
        <ul>
          <li>progress.txt: Append-only learnings log</li>
          <li>prd.json: Task status tracking</li>
          <li>Git commits: Full history visible to each iteration</li>
        </ul>
      </div>

      <div class="gotcha-block">
        <h4>Stale Context Injection</h4>
        <p><strong>What happens:</strong> Injected progress.txt becomes out of sync with actual code state.</p>
        <p><strong>The fix:</strong></p>
        <ul>
          <li>Re-validate state at iteration start</li>
          <li>Run tests to verify PRD item status</li>
          <li>Compare progress.txt claims to actual git history</li>
        </ul>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Misconceptions -->
    <section id="misconceptions">
      <h2><span class="bionic">Mis</span>conceptions &amp; <span class="bionic">Deb</span>unked <span class="bionic">Cla</span>ims</h2>

      <div class="gotcha-block">
        <h4>"Just Let It Run Overnight"</h4>
        <p><strong>Reality:</strong> Without proper Ralph loop setup, Claude will stop at first uncertainty, consume massive tokens on infinite loops, and produce inconsistent results without context management.</p>
        <p><strong>Correct approach:</strong> Use file-based state (Ralph pattern) with explicit completion promises.</p>
      </div>

      <div class="gotcha-block">
        <h4>"Claude Understands Your Whole Codebase"</h4>
        <p><strong>Reality:</strong> Claude only sees what's in context window (~200K tokens, ~100-150K of code).</p>
        <p><strong>The fix:</strong> Use .claudeignore, targeted reads, summarization.</p>
      </div>

      <div class="gotcha-block">
        <h4>"Opus Is Always Better"</h4>
        <p><strong>Reality:</strong></p>
        <ul>
          <li>Opus costs 60x more than Haiku</li>
          <li>For simple tasks, Haiku/Sonnet are faster AND sufficient</li>
          <li>Opus shines only for complex reasoning</li>
        </ul>
        <p><strong>Correct approach:</strong> Match model to task complexity.</p>
      </div>

      <div class="gotcha-block">
        <h4>"MCP Servers Are Plug and Play"</h4>
        <p><strong>Reality:</strong> Many have version compatibility issues. Configuration often requires debugging. Some don't work with latest Claude Code versions.</p>
        <p><strong>Correct approach:</strong> Test MCP servers in isolation before integration.</p>
      </div>

      <div class="gotcha-block">
        <h4>"Premium Subscription Has No Limits"</h4>
        <p><strong>Reality:</strong> All tiers have usage limits that reset periodically. Heavy use ($500+/month) often better on API directly.</p>
      </div>

      <div class="gotcha-block">
        <h4>"/init Auto-Generates Good CLAUDE.md"</h4>
        <p><strong>Reality:</strong> Often produces generic content. Better to write manually with specific project knowledge.</p>
      </div>
    </section>

    <hr class="section-divider">

    <!-- When NOT to Use -->
    <section id="when-not-to-use">
      <h2><span class="bionic">Whe</span>n NOT to <span class="bionic">Use</span> Claude <span class="bionic">Code</span></h2>

      <h3>Real-Time Systems</h3>
      <ul>
        <li>Latency-critical code</li>
        <li>Low-level performance optimization</li>
        <li>Embedded systems with tight constraints</li>
      </ul>

      <h3>Security-Critical Code</h3>
      <ul>
        <li>Cryptographic implementations</li>
        <li>Authentication core logic</li>
        <li>Payment processing</li>
        <li>Healthcare/HIPAA systems</li>
      </ul>
      <p><strong>Reason:</strong> AI can introduce subtle vulnerabilities. These systems need human expert review.</p>

      <h3>Highly Novel Domains</h3>
      <ul>
        <li>Cutting-edge research implementations</li>
        <li>Domain-specific algorithms with limited training data</li>
        <li>Languages/frameworks with minimal online presence</li>
      </ul>

      <h3>Complex Stateful Debugging</h3>
      <ul>
        <li>Race conditions in distributed systems</li>
        <li>Memory corruption bugs</li>
        <li>Hardware-dependent issues</li>
      </ul>

      <h3>Red Flags That Indicate Wrong Tool</h3>
      <ol>
        <li>Repeated failures on same task (5+ attempts)</li>
        <li>Escalating costs without progress</li>
        <li>Quality degradation mid-session</li>
        <li>Context constantly full despite compaction</li>
        <li>Human review finding many bugs in Claude output</li>
      </ol>
    </section>

    <hr class="section-divider">

    <!-- Detection Checklist -->
    <section id="detection-checklist">
      <h2><span class="bionic">Ant</span>i-Pattern <span class="bionic">Det</span>ection <span class="bionic">Che</span>cklist</h2>

      <h3>Pre-Session Checklist</h3>
      <ul>
        <li>Git working directory clean or stashed?</li>
        <li>On dedicated branch (not main/master)?</li>
        <li>.claudeignore excludes sensitive files and build outputs?</li>
        <li>CLAUDE.md updated with current project context?</li>
        <li>Safe commands whitelisted?</li>
        <li>Correct model selected for task complexity?</li>
        <li>Context monitoring active (Claude HUD)?</li>
      </ul>

      <h3>During Session</h3>
      <ul>
        <li>Context usage under 70%?</li>
        <li>Claude following CLAUDE.md conventions?</li>
        <li>Outputs verified with tests/typechecks?</li>
        <li>No infinite loop patterns detected?</li>
        <li>Changes reviewable via <code>git diff</code>?</li>
        <li>Subagent depth &lt; 3 levels?</li>
        <li>Task completion achievable in current context?</li>
      </ul>

      <h3>Post-Session Checklist</h3>
      <ul>
        <li>All changes reviewed before commit?</li>
        <li>Tests passing?</li>
        <li>Type checking passing?</li>
        <li>No security issues introduced?</li>
        <li>No credentials in code/context?</li>
        <li>Session costs within budget?</li>
        <li>Learnings captured for future sessions?</li>
      </ul>

      <h3>Red Flag Detection</h3>
      <ul>
        <li>Same file edited 5+ times without progress? (Verification loop)</li>
        <li>Multiple grep/glob calls with no results? (Exploration loop)</li>
        <li>Context &gt;90% without task completion? (Context collapse imminent)</li>
        <li>Token consumption rate 3x normal? (Runaway agent)</li>
        <li>Circular edit patterns? (Logic error)</li>
      </ul>
    </section>

    <hr class="section-divider">

    <!-- Recovery -->
    <section id="recovery">
      <h2><span class="bionic">Rec</span>overy <span class="bionic">Str</span>ategies</h2>

      <h3>From Context Overflow</h3>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code># Compact immediately
/compact

# If severely degraded
/reset

# Start focused session
claude "Focus only on src/auth/ - implement OAuth flow"</code></pre>
      </div>

      <h3>From File Corruption</h3>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code># Discard changes to specific file
git checkout -- path/to/file.ts

# Recovery from stash
git stash pop

# Hard reset (CAREFUL)
git reset --hard HEAD</code></pre>
      </div>

      <h3>From Infinite Loops</h3>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code># Graceful interrupt
Ctrl+C

# Harder interrupt
Ctrl+\

# Force kill
pkill -9 -f claude

# Break Ralph loop
echo "PROMISE COMPLETE HERE" >> progress.txt</code></pre>
      </div>

      <h3>From Cost Runaway</h3>
      <ol>
        <li>Kill all Claude processes: <code>pkill -f claude</code></li>
        <li>Check Anthropic dashboard for usage</li>
        <li>Set hard budget limits in console</li>
        <li>Review what caused high usage</li>
      </ol>

      <h3>From Authentication Issues</h3>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code># Re-authenticate
claude auth logout
claude auth login

# Clear credentials
rm -rf ~/.claude/credentials

# Use API key instead
export ANTHROPIC_API_KEY="sk-ant-..."</code></pre>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Summary Table -->
    <section>
      <h2><span class="bionic">Sum</span>mary: <span class="bionic">Cor</span>e <span class="bionic">Ant</span>i-Pattern <span class="bionic">Cat</span>egories</h2>

      <div class="table-responsive">
        <table>
          <thead>
            <tr><th>Category</th><th>Root Cause</th><th>Prevention</th></tr>
          </thead>
          <tbody>
            <tr><td><strong>Context</strong></td><td>Growing conversations</td><td>Fresh context per iteration (Ralph)</td></tr>
            <tr><td><strong>Orchestration</strong></td><td>Role confusion</td><td>Strict orchestrator/worker separation</td></tr>
            <tr><td><strong>Task Design</strong></td><td>Wrong sizing</td><td>30-60 min atomic tasks</td></tr>
            <tr><td><strong>Prompting</strong></td><td>Ambiguity</td><td>Explicit, testable criteria</td></tr>
            <tr><td><strong>Configuration</strong></td><td>Missing safeguards</td><td>Proper .claudeignore, permissions</td></tr>
            <tr><td><strong>Multi-Agent</strong></td><td>No isolation</td><td>Branch/directory ownership</td></tr>
            <tr><td><strong>Verification</strong></td><td>Blind trust</td><td>Layered testing requirements</td></tr>
            <tr><td><strong>Memory</strong></td><td>In-context only</td><td>External file-based state</td></tr>
            <tr><td><strong>Tools</strong></td><td>Wrong tool for job</td><td>Match tool to task</td></tr>
            <tr><td><strong>Cost</strong></td><td>No limits</td><td>Iteration caps, model matching</td></tr>
            <tr><td><strong>Security</strong></td><td>Weak permissions</td><td>Blocklists, read-only configs</td></tr>
          </tbody>
        </table>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Related Pages -->
    <div class="related-pages">
      <h3>Related Principles Documents</h3>
      <ul>
        <li><a href="principles-core.html">Core Principles</a> - The 8 foundational principles these anti-patterns violate</li>
        <li><a href="principles-derivation-guide.html">Derivation Guide</a> - How to create patterns that avoid these issues</li>
        <li><a href="principles-learning-loops.html">Learning Loops</a> - How to learn from failures and compound improvements</li>
      </ul>
    </div>

    <!-- Footer Navigation -->
    <nav class="footer-nav">
      <a href="principles-learning-loops.html" class="nav-prev">
        <span class="nav-direction">Previous</span>
        <span class="nav-title">Learning Loops</span>
      </a>
      <span></span>
    </nav>

    <!-- Tags -->
    <div style="margin-top: 2rem;">
      <span class="tag">#anti-patterns</span>
      <span class="tag">#failures</span>
      <span class="tag">#gotchas</span>
      <span class="tag">#warnings</span>
      <span class="tag">#context-rot</span>
      <span class="tag">#orchestration</span>
      <span class="tag">#task-design</span>
      <span class="tag">#prompting</span>
      <span class="tag">#configuration</span>
      <span class="tag">#multi-agent</span>
      <span class="tag">#verification</span>
      <span class="tag">#memory</span>
      <span class="tag">#cost</span>
      <span class="tag">#security</span>
      <span class="tag">#recovery</span>
    </div>
  </div>

  <script src="../js/copy-code.js"></script>
  <script src="../js/search.js"></script>
  <script src="../js/global-nav.js"></script>
</body>
</html>
