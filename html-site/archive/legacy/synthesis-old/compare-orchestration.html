<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta data-pagefind-meta="section" content="Synthesis">
  <meta data-pagefind-meta="category" content="Comparisons">
  <title>Orchestration Approaches Compared - Claude Code Knowledge Base</title>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="stylesheet" href="../css/sidebar.css">
  <link rel="stylesheet" href="../css/search.css">
</head>
<body>
  <!-- Search Modal -->
  <div class="search-modal" id="searchModal" aria-hidden="true">
    <div class="search-overlay" onclick="closeSearch()"></div>
    <div class="search-content">
      <div class="search-header">
        <div class="search-input-wrapper">
          <span class="search-icon-input">&#128269;</span>
          <input type="text" id="searchInput" placeholder="Search documentation..." autocomplete="off" />
          <kbd class="search-kbd">ESC</kbd>
        </div>
      </div>
      <div class="search-filters">
        <button class="filter-btn active" data-filter="all">All</button>
        <button class="filter-btn" data-filter="synthesis">Synthesis</button>
        <button class="filter-btn" data-filter="extractions">Extractions</button>
        <button class="filter-btn" data-filter="journeys">Journeys</button>
      </div>
      <div class="search-results" id="searchResults">
        <div class="search-empty"><p>Start typing to search... (Press Cmd+K anytime)</p></div>
      </div>
      <div class="search-footer">
        <span>Up/Down Navigate</span><span>Enter Select</span><span>ESC Close</span>
      </div>
    </div>
  </div>

  <button class="search-trigger" onclick="openSearch()" aria-label="Search" style="float: right; margin-bottom: 1rem;">
    <span class="search-icon">Cmd+K</span>
    <span class="search-text">Search</span>
  </button>

  <div class="wide-container">
    <!-- Breadcrumb Navigation -->
    <nav class="nav-breadcrumb">
      <a href="../index.html">Home</a>
      <span>/</span>
      <a href="synthesis-index.html">Synthesis</a>
      <span>/</span>
      <a href="compare-master.html">Comparisons</a>
      <span>/</span>
      <span>Orchestration</span>
    </nav>

    <!-- You Are Here Context Box -->
    <div class="you-are-here" style="background: linear-gradient(135deg, #f0ebe3 0%, #fefcf3 100%); border-left: 4px solid #2a7d7d; border-radius: 8px; padding: 1.5rem; margin-bottom: 2rem;">
      <h3 style="color: #2a7d7d; margin-top: 0; font-size: 0.9em; text-transform: uppercase; letter-spacing: 0.5px;">You Are Here</h3>
      <p style="margin-bottom: 0;"><strong><span class="b">Orch</span>estration <span class="b">App</span>roaches <span class="b">Com</span>pared</strong> - A side-by-side comparison of four major orchestration strategies (Basic Ralph, PRD-Ralph, CC Mirror, Gas Town) for autonomous AI-assisted development. Use this when deciding HOW to run your agent automation.</p>
    </div>

    <h1><span class="b">Orch</span>estration <span class="b">App</span>roaches <span class="b">Com</span>pared</h1>

    <!-- Table of Contents -->
    <div class="toc">
      <div class="toc-title">Contents</div>
      <ul>
        <li><a href="#same-goal">The Same Goal</a></li>
        <li><a href="#basic-ralph">Approach 1: Basic Ralph</a></li>
        <li><a href="#prd-ralph">Approach 2: PRD-Driven Ralph</a></li>
        <li><a href="#cc-mirror">Approach 3: CC Mirror Hub-and-Spoke</a></li>
        <li><a href="#gas-town">Approach 4: Gas Town Factory</a></li>
        <li><a href="#decision-matrix">Decision Matrix</a></li>
        <li><a href="#feature-comparison">Feature Comparison</a></li>
        <li><a href="#scaling-path">Scaling Path</a></li>
        <li><a href="#selection-guide">Selection Guide</a></li>
        <li><a href="#hybrid-strategies">Hybrid Strategies</a></li>
        <li><a href="#troubleshooting">Troubleshooting</a></li>
      </ul>
    </div>

    <hr class="section-divider">

    <!-- The Same Goal -->
    <section id="same-goal">
      <h2><span class="b">The</span> Same <span class="b">Go</span>al</h2>

      <p><strong>Ship a complete feature autonomously</strong> - from specification to working, tested code - with minimal human intervention.</p>

      <p>Each approach below represents a different philosophy for achieving this goal, with distinct tradeoffs in setup complexity, parallelism, and appropriate scale.</p>
    </section>

    <hr class="section-divider">

    <!-- Approach 1: Basic Ralph -->
    <section id="basic-ralph">
      <h2><span class="b">App</span>roach 1: <span class="b">Bas</span>ic Ralph</h2>

      <h3>How it works</h3>

      <p>A simple bash loop that runs Claude Code repeatedly with fresh context until a completion condition is met. Each iteration:</p>
      <ol>
        <li>Reads the current state (prd.json, progress.txt)</li>
        <li>Works on the next task in the list</li>
        <li>Commits changes</li>
        <li>Checks for completion signal</li>
        <li>Loops or exits</li>
      </ol>

      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code>for (( i=1; i<=$MAX_ITERATIONS; i++ )); do
  claude "Review prd.json... If complete, output PROMISE COMPLETE HERE"
  if grep -q "PROMISE COMPLETE HERE" output.txt; then break; fi
done</code></pre>
      </div>

      <p><strong>Key Files:</strong></p>
      <ul>
        <li><code>ralph.sh</code> - The loop script</li>
        <li><code>prompt.md</code> - Instructions for each iteration</li>
        <li><code>prd.json</code> - Task list with user stories</li>
        <li><code>progress.txt</code> - Accumulated learnings</li>
      </ul>

      <h3>Pros</h3>
      <ul>
        <li><strong>Simple to set up</strong> - Just a bash script and a few files</li>
        <li><strong>Low overhead</strong> - No complex infrastructure or dependencies</li>
        <li><strong>Easy to understand</strong> - Anyone can read the code and know what it does</li>
        <li><strong>Fresh context per iteration</strong> - Avoids "context rot" from accumulated confusion</li>
        <li><strong>Git history as memory</strong> - Each iteration commits, creating implicit documentation</li>
        <li><strong>Verifiable</strong> - Tests must pass each iteration, catching regressions early</li>
      </ul>

      <h3>Cons</h3>
      <ul>
        <li><strong>Sequential only</strong> - One task at a time, no parallelism</li>
        <li><strong>Single agent</strong> - No specialization or role separation</li>
        <li><strong>Context amnesia</strong> - Each iteration starts fresh (mitigated by progress.txt)</li>
        <li><strong>No dependency management</strong> - Tasks must be linearly ordered</li>
        <li><strong>Human-designed task breakdown</strong> - Quality depends on PRD quality</li>
      </ul>

      <h3>Best for</h3>
      <ul>
        <li>Solo developers working on single features</li>
        <li>Overnight "ship it while I sleep" workflows</li>
        <li>Well-scoped features with clear completion criteria</li>
        <li>Getting started with autonomous development (Stage 1-3)</li>
      </ul>

      <h3>Setup Time</h3>
      <p>15-30 minutes</p>
    </section>

    <hr class="section-divider">

    <!-- Approach 2: PRD-Driven Ralph -->
    <section id="prd-ralph">
      <h2><span class="b">App</span>roach 2: <span class="b">PRD</span>-Driven Ralph</h2>

      <h3>How it works</h3>

      <p>Extension of basic Ralph that adds structured task management via a JSON-based Product Requirements Document:</p>

      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code>{
  "name": "Authentication System",
  "stories": [
    {
      "id": "story-1",
      "title": "User can register",
      "acceptanceCriteria": [
        "Email validation works",
        "Password hashed with bcrypt",
        "Confirmation email sent"
      ],
      "passes": false,
      "priority": 1
    }
  ]
}</code></pre>
      </div>

      <p>Each iteration:</p>
      <ol>
        <li>Parse prd.json for next incomplete story (by priority)</li>
        <li>Implement to meet acceptance criteria</li>
        <li>Mark story as passed when criteria verified</li>
        <li>Continue until all stories pass</li>
      </ol>

      <p><strong>Enhanced with quality gates</strong> (Dr. Ralph variant):</p>
      <ul>
        <li>80%+ confidence threshold before advancing</li>
        <li>Multi-phase verification between stages</li>
      </ul>

      <h3>Pros</h3>
      <ul>
        <li><strong>Structured tasks</strong> - Clear boundaries between work items</li>
        <li><strong>Acceptance criteria</strong> - Explicit success conditions, not just "it works"</li>
        <li><strong>Priority ordering</strong> - Most important work happens first</li>
        <li><strong>Measurable progress</strong> - Track story completion percentage</li>
        <li><strong>Self-documenting</strong> - PRD becomes project history</li>
        <li><strong>Quality gates</strong> - Optional confidence thresholds prevent low-quality work</li>
        <li><strong>Compounding learning</strong> - progress.txt captures patterns for future iterations</li>
      </ul>

      <h3>Cons</h3>
      <ul>
        <li><strong>Upfront planning required</strong> - Someone must write the PRD first</li>
        <li><strong>PRD quality is critical</strong> - Garbage in, garbage out</li>
        <li><strong>Still sequential</strong> - Parallelism not improved over basic Ralph</li>
        <li><strong>Single agent</strong> - Still no role specialization</li>
        <li><strong>Rigid structure</strong> - Hard to adapt to emergent requirements</li>
        <li><strong>Manual task sizing</strong> - Must ensure each story fits in one context window</li>
      </ul>

      <h3>Best for</h3>
      <ul>
        <li>Well-defined features with clear requirements</li>
        <li>Teams that already write good specs</li>
        <li>Regulated environments needing documentation</li>
        <li>Features with natural linear dependencies</li>
        <li>Medium-scale projects (Stage 3-5)</li>
      </ul>

      <h3>Setup Time</h3>
      <p>1-2 hours (including PRD creation)</p>
    </section>

    <hr class="section-divider">

    <!-- Approach 3: CC Mirror -->
    <section id="cc-mirror">
      <h2><span class="b">App</span>roach 3: <span class="b">CC</span> Mirror Hub-and-Spoke</h2>

      <h3>How it works</h3>

      <p>Central orchestrator that delegates to specialized worker agents through Claude Code's native Task API. The orchestrator <strong>never writes code</strong> - it coordinates.</p>

      <div class="ascii-diagram">
            +------------------+
            |   Orchestrator   |
            |   (Conductor)    |
            +--------+---------+
                     |
     +---------------+---------------+
     |               |               |
     v               v               v
+---------+    +---------+    +---------+
|  Coder  |    | Tester  |    | Reviewer|
|  (Opus) |    | (Sonnet)|    | (Haiku) |
+---------+    +---------+    +---------+</div>

      <h3>Orchestrator Philosophy</h3>

      <div class="callout callout-warning">
        <div class="callout-title">The Iron Rule</div>
        <p><strong>YOU DO NOT WRITE CODE. YOU DO NOT RUN COMMANDS.</strong></p>
        <p><strong>YOU DO NOT EXPLORE CODEBASES.</strong></p>
        <p>You are the CONDUCTOR. Your agents play the instruments.</p>
      </div>

      <h3>Tool Ownership</h3>
      <div class="table-responsive">
        <table>
          <thead>
            <tr><th>Role</th><th>Allowed Tools</th></tr>
          </thead>
          <tbody>
            <tr><td><strong>Orchestrator</strong></td><td>Read (1-2 files), Task*, AskUserQuestion</td></tr>
            <tr><td><strong>Workers</strong></td><td>Read, Write, Edit, Bash, Glob, Grep, WebFetch, LSP</td></tr>
          </tbody>
        </table>
      </div>

      <h3>Pros</h3>
      <ul>
        <li><strong>True parallelism</strong> - Multiple workers execute simultaneously</li>
        <li><strong>Specialization</strong> - Right model for each task type</li>
        <li><strong>Cost optimization</strong> - Expensive models only where needed</li>
        <li><strong>Dependency tracking</strong> - Built-in blocked/blocking relationships</li>
        <li><strong>Native integration</strong> - Uses Claude Code's Task API directly</li>
        <li><strong>Domain reference loading</strong> - Specialized context per task type</li>
        <li><strong>Clear separation</strong> - Orchestrator thinks, workers do</li>
      </ul>

      <h3>Cons</h3>
      <ul>
        <li><strong>More complex setup</strong> - Requires understanding task decomposition</li>
        <li><strong>Coordination overhead</strong> - Orchestrator context grows with task graph</li>
        <li><strong>Needs good decomposition</strong> - Poorly split tasks cause confusion</li>
        <li><strong>Learning curve</strong> - Different mental model from solo coding</li>
        <li><strong>Worker isolation</strong> - Workers don't see each other's work directly</li>
        <li><strong>Merge complexity</strong> - Parallel work may need conflict resolution</li>
      </ul>

      <h3>Best for</h3>
      <ul>
        <li>Multi-domain features (frontend + backend + tests)</li>
        <li>Teams wanting cost-optimized model usage</li>
        <li>Interactive development with human oversight</li>
        <li>Medium to large projects (Stage 4-6)</li>
        <li>Features requiring different specializations</li>
      </ul>

      <h3>Setup Time</h3>
      <p>1-2 hours</p>
    </section>

    <hr class="section-divider">

    <!-- Approach 4: Gas Town -->
    <section id="gas-town">
      <h2><span class="b">App</span>roach 4: <span class="b">Gas</span> Town Factory</h2>

      <h3>How it works</h3>

      <p>Not just agents, but an <strong>agent factory</strong> - a self-managing town of specialized workers that coordinate through inboxes and handoffs.</p>

      <div class="ascii-diagram">
Gas Town (~/.gt)
+-- HQ (town-level management)
+-- Rigs (project repos)
|   +-- Witness (per-rig observer)
+-- Workers
|   +-- Mayor (town coordination)
|   +-- Deacon (monitoring/handshakes)
|   +-- Dogs (quality gates)
|   +-- Refinery (task decomposition)
|   +-- Polecat (named persistent workers)
|   +-- Crew (ephemeral workers)
+-- Overseer (YOU - human with inbox)</div>

      <h3>Role Definitions</h3>
      <div class="table-responsive">
        <table>
          <thead>
            <tr><th>Role</th><th>Purpose</th></tr>
          </thead>
          <tbody>
            <tr><td><strong>Mayor</strong></td><td>Town-wide coordination, resource allocation</td></tr>
            <tr><td><strong>Deacon</strong></td><td>Monitoring agent health, handshakes between agents</td></tr>
            <tr><td><strong>Dogs</strong></td><td>Quality gates, watchdogs for bad behavior</td></tr>
            <tr><td><strong>Refinery</strong></td><td>Task decomposition into worker-sized chunks</td></tr>
            <tr><td><strong>Polecat</strong></td><td>Named persistent workers with specialization</td></tr>
            <tr><td><strong>Crew</strong></td><td>Ephemeral workers for one-off tasks</td></tr>
            <tr><td><strong>Witness</strong></td><td>Per-project observer, watches for problems</td></tr>
            <tr><td><strong>Overseer</strong></td><td>Human with inbox (you)</td></tr>
          </tbody>
        </table>
      </div>

      <blockquote>
        <p>"You just make up features, design them, file the implementation plans, and sling work around to your polecats and crew."</p>
        <cite>-- Steve Yegge</cite>
      </blockquote>

      <h3>Pros</h3>
      <ul>
        <li><strong>Maximum parallelism</strong> - 10+ agents working simultaneously</li>
        <li><strong>Deep specialization</strong> - Each role optimized for its function</li>
        <li><strong>Self-improving</strong> - Factory learns and adapts over time</li>
        <li><strong>Full team simulation</strong> - Approximates human dev team dynamics</li>
        <li><strong>Automatic decomposition</strong> - Refinery breaks down work</li>
        <li><strong>Quality built-in</strong> - Dogs enforce standards at every step</li>
        <li><strong>Resilient</strong> - System continues if individual agents fail</li>
        <li><strong>Persistent workers</strong> - Polecats maintain context across sessions</li>
      </ul>

      <h3>Cons</h3>
      <ul>
        <li><strong>Complex setup</strong> - Significant infrastructure to configure</li>
        <li><strong>High overhead</strong> - Many agents = many tokens = high cost ($50-200/day)</li>
        <li><strong>Needs scale to justify</strong> - Overkill for small features</li>
        <li><strong>Requires experience</strong> - Must be comfortable with agent chaos</li>
        <li><strong>Tmux proficiency required</strong> - Primary UI is terminal multiplexing</li>
        <li><strong>Debugging difficulty</strong> - Hard to trace problems across many agents</li>
        <li><strong>Budget implications</strong> - Not for hobby projects</li>
      </ul>

      <h3>Best for</h3>
      <ul>
        <li>Large projects with many parallel workstreams</li>
        <li>Teams shipping multiple features simultaneously</li>
        <li>Production environments with high throughput requirements</li>
        <li>Stage 7+ developers (10+ agent experience)</li>
        <li>Organizations with significant AI budget</li>
        <li>Projects where speed-to-market justifies cost</li>
      </ul>

      <h3>Setup Time</h3>
      <p>4-8 hours (plus learning curve)</p>
    </section>

    <hr class="section-divider">

    <!-- Checkpoint -->
    <div class="checkpoint" style="background: #f0ebe3; border-left: 4px solid #6b9b7a; border-radius: 8px; padding: 1.5rem; margin: 2rem 0;">
      <div class="checkpoint-header" style="color: #6b9b7a; font-weight: 600;">Checkpoint: Orchestration Approaches</div>
      <p><strong>You should now understand:</strong></p>
      <ul>
        <li>How Basic Ralph uses fresh context per iteration</li>
        <li>How PRD-Ralph adds structured task management</li>
        <li>How CC Mirror enables parallel workers with hub-and-spoke</li>
        <li>How Gas Town creates a full agent factory with specialized roles</li>
      </ul>
      <p><strong>If unclear:</strong> Re-read the "How it works" section for the approach you are considering.</p>
    </div>

    <hr class="section-divider">

    <!-- Decision Matrix -->
    <section id="decision-matrix">
      <h2><span class="b">Dec</span>ision <span class="b">Mat</span>rix</h2>

      <div class="table-responsive">
        <table class="comparison-table">
          <thead>
            <tr>
              <th>Factor</th>
              <th>Basic Ralph</th>
              <th>PRD-Ralph</th>
              <th>CC Mirror</th>
              <th>Gas Town</th>
            </tr>
          </thead>
          <tbody>
            <tr><td><strong>Setup Complexity</strong></td><td>Easy</td><td>Medium</td><td>Medium</td><td>Hard</td></tr>
            <tr><td><strong>Parallelism</strong></td><td>None</td><td>None</td><td>High</td><td>Maximum</td></tr>
            <tr><td><strong>Agent Count</strong></td><td>1</td><td>1</td><td>3-8</td><td>10-50+</td></tr>
            <tr><td><strong>Infrastructure</strong></td><td>Low</td><td>Low</td><td>Medium</td><td>High</td></tr>
            <tr><td><strong>Upfront Planning</strong></td><td>Low</td><td>High</td><td>Medium</td><td>Medium</td></tr>
            <tr><td><strong>Cost per Day</strong></td><td>$5-20</td><td>$5-20</td><td>$20-80</td><td>$50-200</td></tr>
            <tr><td><strong>Learning Curve</strong></td><td>Low</td><td>Low</td><td>Medium</td><td>High</td></tr>
            <tr><td><strong>Debugging Ease</strong></td><td>Easy</td><td>Easy</td><td>Medium</td><td>Hard</td></tr>
            <tr><td><strong>Best Project Scale</strong></td><td>Small</td><td>Medium</td><td>Medium</td><td>Large</td></tr>
            <tr><td><strong>Human Oversight</strong></td><td>Low</td><td>Low</td><td>Medium</td><td>Low</td></tr>
            <tr><td><strong>Flexibility</strong></td><td>High</td><td>Low</td><td>Medium</td><td>High</td></tr>
            <tr><td><strong>Quality Gates</strong></td><td>Manual</td><td>Criteria</td><td>Workers</td><td>Dogs</td></tr>
          </tbody>
        </table>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Feature Comparison -->
    <section id="feature-comparison">
      <h2><span class="b">Fea</span>ture <span class="b">Com</span>parison</h2>

      <h3>Context Management</h3>
      <div class="table-responsive">
        <table>
          <thead>
            <tr><th>Approach</th><th>Strategy</th></tr>
          </thead>
          <tbody>
            <tr><td><strong>Basic Ralph</strong></td><td>Fresh context each iteration, git history as memory</td></tr>
            <tr><td><strong>PRD-Ralph</strong></td><td>Fresh context + structured prd.json + progress.txt</td></tr>
            <tr><td><strong>CC Mirror</strong></td><td>Orchestrator accumulates context, workers get task-specific</td></tr>
            <tr><td><strong>Gas Town</strong></td><td>Persistent workers (Polecats) maintain context, Crew ephemeral</td></tr>
          </tbody>
        </table>
      </div>

      <h3>Error Handling</h3>
      <div class="table-responsive">
        <table>
          <thead>
            <tr><th>Approach</th><th>Strategy</th></tr>
          </thead>
          <tbody>
            <tr><td><strong>Basic Ralph</strong></td><td>Tests must pass, loop continues until success or max iterations</td></tr>
            <tr><td><strong>PRD-Ralph</strong></td><td>Same + acceptance criteria validation</td></tr>
            <tr><td><strong>CC Mirror</strong></td><td>Task dependencies, requeue on failure</td></tr>
            <tr><td><strong>Gas Town</strong></td><td>Dogs catch quality issues, Witness monitors, Deacon coordinates recovery</td></tr>
          </tbody>
        </table>
      </div>

      <h3>Task Decomposition</h3>
      <div class="table-responsive">
        <table>
          <thead>
            <tr><th>Approach</th><th>Responsibility</th></tr>
          </thead>
          <tbody>
            <tr><td><strong>Basic Ralph</strong></td><td>Human creates small tasks</td></tr>
            <tr><td><strong>PRD-Ralph</strong></td><td>Human writes detailed PRD with stories</td></tr>
            <tr><td><strong>CC Mirror</strong></td><td>Orchestrator decomposes, routes to workers</td></tr>
            <tr><td><strong>Gas Town</strong></td><td>Refinery automatically decomposes</td></tr>
          </tbody>
        </table>
      </div>

      <h3>Communication</h3>
      <div class="table-responsive">
        <table>
          <thead>
            <tr><th>Approach</th><th>Mechanism</th></tr>
          </thead>
          <tbody>
            <tr><td><strong>Basic Ralph</strong></td><td>File-based (progress.txt, git commits)</td></tr>
            <tr><td><strong>PRD-Ralph</strong></td><td>Same + structured prd.json</td></tr>
            <tr><td><strong>CC Mirror</strong></td><td>Task API (TaskCreate, TaskUpdate, dependencies)</td></tr>
            <tr><td><strong>Gas Town</strong></td><td>MCP Agent Mail (inbox-based), file handoffs</td></tr>
          </tbody>
        </table>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Scaling Path -->
    <section id="scaling-path">
      <h2><span class="b">Scal</span>ing <span class="b">Pa</span>th</h2>

      <div class="ascii-diagram">
+-------------------------------------------------------------------+
|                     SCALING PROGRESSION                            |
+-------------------------------------------------------------------+
|                                                                    |
|  SIMPLE --------------------------------------------------> COMPLEX|
|                                                                    |
|  Stage 1-3        Stage 4-5        Stage 6         Stage 7+       |
|  +---------+     +---------+      +---------+      +--------+     |
|  | Ralph   |---->|  PRD    |----->|CC Mirror|----->|  Gas   |     |
|  | (Basic) |     | Ralph   |      |Hub-Spoke|      |  Town  |     |
|  +---------+     +---------+      +---------+      +--------+     |
|                                                                    |
|  1 agent         1 agent          3-8 agents       10+ agents     |
|  $5/day          $10/day          $50/day          $150/day       |
|                                                                    |
+-------------------------------------------------------------------+</div>
    </section>

    <hr class="section-divider">

    <!-- Selection Guide -->
    <section id="selection-guide">
      <h2><span class="b">Sel</span>ection <span class="b">Gui</span>de</h2>

      <h3>Start with Basic Ralph when:</h3>
      <ul>
        <li>You're new to autonomous development</li>
        <li>The feature is well-scoped and fits in a day</li>
        <li>You want "set it and forget it" overnight shipping</li>
        <li>Budget is a concern</li>
        <li>You value simplicity over parallelism</li>
      </ul>

      <h3>Upgrade to PRD-Ralph when:</h3>
      <ul>
        <li>You have clear, detailed requirements</li>
        <li>Quality gates matter (regulated environment)</li>
        <li>You want measurable progress tracking</li>
        <li>Tasks have natural linear dependencies</li>
        <li>You're comfortable writing structured specs</li>
      </ul>

      <h3>Move to CC Mirror when:</h3>
      <ul>
        <li>You need parallelism across domains</li>
        <li>Cost optimization matters (right model for each task)</li>
        <li>Features span frontend + backend + tests</li>
        <li>You want native Claude Code orchestration</li>
        <li>Interactive development with oversight</li>
      </ul>

      <h3>Go Gas Town when:</h3>
      <ul>
        <li>You're at Stage 7+ (10+ agent experience)</li>
        <li>Project scale justifies the overhead</li>
        <li>Speed-to-market is critical</li>
        <li>Budget is not a constraint</li>
        <li>You're comfortable with emergence and chaos</li>
        <li>You need a self-improving agent factory</li>
      </ul>
    </section>

    <hr class="section-divider">

    <!-- Hybrid Strategies -->
    <section id="hybrid-strategies">
      <h2><span class="b">Hyb</span>rid <span class="b">Strat</span>egies</h2>

      <p>These approaches aren't mutually exclusive. Common combinations:</p>

      <h3>1. Ralph + Git Worktrees</h3>
      <p>Run multiple Ralph loops in parallel via worktrees:</p>
      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code>for feature in auth payments notifications; do
  git worktree add ../wt-$feature $feature-branch
  (cd ../wt-$feature && ./ralph.sh 20) &
done
wait</code></pre>
      </div>
      <p><strong>Result:</strong> Parallel Ralph without CC Mirror complexity</p>

      <h3>2. CC Mirror by Day, Ralph by Night</h3>
      <ul>
        <li>Daytime: Interactive CC Mirror with human oversight</li>
        <li>Overnight: Ralph loops for verified, autonomous work</li>
      </ul>
      <p><strong>Result:</strong> Best of both interaction models</p>

      <h3>3. Gas Town with PRD Discipline</h3>
      <p>Use Gas Town's Refinery but feed it well-structured PRDs:</p>
      <ul>
        <li>Human writes PRD</li>
        <li>Refinery decomposes into worker tasks</li>
        <li>Polecats execute with acceptance criteria</li>
      </ul>
      <p><strong>Result:</strong> Factory-scale with structured requirements</p>
    </section>

    <hr class="section-divider">

    <!-- Cost-Benefit Summary -->
    <section id="cost-benefit">
      <h2><span class="b">Cost</span>-Benefit <span class="b">Sum</span>mary</h2>

      <div class="table-responsive">
        <table>
          <thead>
            <tr>
              <th>Investment</th>
              <th>Basic Ralph</th>
              <th>PRD-Ralph</th>
              <th>CC Mirror</th>
              <th>Gas Town</th>
            </tr>
          </thead>
          <tbody>
            <tr><td><strong>Setup Time</strong></td><td>30 min</td><td>2 hrs</td><td>2 hrs</td><td>8 hrs</td></tr>
            <tr><td><strong>Learning</strong></td><td>1 day</td><td>1 day</td><td>3 days</td><td>1-2 weeks</td></tr>
            <tr><td><strong>Daily Cost</strong></td><td>$5-20</td><td>$10-30</td><td>$30-80</td><td>$50-200</td></tr>
            <tr><td><strong>ROI Scale</strong></td><td>Small</td><td>Medium</td><td>Medium</td><td>Large</td></tr>
            <tr><td><strong>Break-even</strong></td><td>Immediate</td><td>Week 1</td><td>Week 2</td><td>Month 1</td></tr>
          </tbody>
        </table>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Troubleshooting -->
    <section id="troubleshooting">
      <h2><span class="b">Trou</span>bleshooting</h2>

      <details class="troubleshoot">
        <summary>Ralph Loop Never Completes</summary>
        <div>
          <p><strong>Symptom:</strong> Loop runs to MAX_ITERATIONS without outputting "PROMISE COMPLETE HERE".</p>
          <p><strong>Cause:</strong> Completion criteria not achievable, or agent doesn't recognize when to signal completion.</p>
          <p><strong>Fix:</strong> Check your prompt.md includes clear completion instructions. Verify acceptance criteria are realistic. Review progress.txt to see where the agent is getting stuck.</p>
          <div class="code-block">
            <button class="copy-btn" onclick="copyCode(this)">Copy</button>
            <pre><code># Check if promise pattern exists in recent output
grep -l "PROMISE COMPLETE" output.txt

# Review what the agent has been doing
tail -50 scripts/ralph/progress.txt</code></pre>
          </div>
        </div>
      </details>

      <details class="troubleshoot">
        <summary>PRD Tasks Not Being Marked Complete</summary>
        <div>
          <p><strong>Symptom:</strong> Agent works on tasks but prd.json <code>passes</code> values stay <code>false</code>.</p>
          <p><strong>Cause:</strong> Agent not updating prd.json, or acceptance criteria unclear.</p>
          <p><strong>Fix:</strong> Ensure your prompt explicitly instructs the agent to update prd.json when criteria are met. Make acceptance criteria binary (yes/no testable).</p>
          <div class="code-block">
            <button class="copy-btn" onclick="copyCode(this)">Copy</button>
            <pre><code># Check PRD status
cat scripts/ralph/prd.json | jq '.userStories[] | {id, title, passes}'</code></pre>
          </div>
        </div>
      </details>

      <details class="troubleshoot">
        <summary>CC Mirror Workers Not Starting</summary>
        <div>
          <p><strong>Symptom:</strong> Orchestrator creates tasks but workers never execute.</p>
          <p><strong>Cause:</strong> Missing <code>run_in_background=True</code> flag, or workers not properly configured.</p>
          <p><strong>Fix:</strong> Verify Task calls include background execution. Check worker preambles are set up correctly.</p>
          <div class="code-block">
            <button class="copy-btn" onclick="copyCode(this)">Copy</button>
            <pre><code># Verify CC Mirror is running
npx cc-mirror status</code></pre>
          </div>
        </div>
      </details>

      <details class="troubleshoot">
        <summary>Gas Town Agents Not Communicating</summary>
        <div>
          <p><strong>Symptom:</strong> Agents running but not picking up work from inboxes.</p>
          <p><strong>Cause:</strong> MCP Agent Mail not configured, or inbox paths incorrect.</p>
          <p><strong>Fix:</strong> Verify MCP setup in each agent's config. Check inbox file paths match across agents.</p>
          <div class="code-block">
            <button class="copy-btn" onclick="copyCode(this)">Copy</button>
            <pre><code># Check for stale handoffs
find ~/.gt -name "inbox-*.json" -mmin +30

# Verify agent processes are running
pgrep -f "gt-" | head -5</code></pre>
          </div>
        </div>
      </details>

      <details class="troubleshoot">
        <summary>Overnight Run Produces No Results</summary>
        <div>
          <p><strong>Symptom:</strong> Started Ralph loop before bed, wake up to no commits.</p>
          <p><strong>Cause:</strong> Early failure that stopped the loop, or credentials/auth expired.</p>
          <p><strong>Fix:</strong> Add error handling to your loop script. Check for auth token expiration on long runs.</p>
          <div class="code-block">
            <button class="copy-btn" onclick="copyCode(this)">Copy</button>
            <pre><code># Check if loop script is still running
ps aux | grep ralph

# Check recent git activity
git log --oneline --since="8 hours ago"

# Review any error output
cat /tmp/ralph-error.log</code></pre>
          </div>
        </div>
      </details>
    </section>

    <hr class="section-divider">

    <!-- Final Recommendations -->
    <section id="final-recommendations">
      <h2><span class="b">Fin</span>al <span class="b">Rec</span>ommendations</h2>

      <ol>
        <li><strong>Start simple (Basic Ralph)</strong> - Prove autonomous development works for your workflow</li>
        <li><strong>Add structure when needed (PRD-Ralph)</strong> - When you want quality gates and tracking</li>
        <li><strong>Scale with parallelism (CC Mirror)</strong> - When single-agent becomes a bottleneck</li>
        <li><strong>Go full factory (Gas Town)</strong> - Only when scale demands it and budget permits</li>
      </ol>

      <div class="callout callout-insight">
        <div class="callout-title">Key Insight</div>
        <p>The best orchestration approach is the simplest one that meets your needs. Complexity has costs - in setup, debugging, and cognitive overhead. Scale up only when the simpler approach demonstrably fails.</p>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Quick Reference Commands -->
    <section id="quick-reference">
      <h2><span class="b">Qui</span>ck Reference <span class="b">Com</span>mands</h2>

      <div class="code-block">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        <pre><code># Basic Ralph
./ralph.sh 25

# PRD-Ralph (same command, different prd.json structure)
./ralph.sh 25  # With structured prd.json

# CC Mirror
npx cc-mirror quick --provider mirror --name mclaude

# Gas Town
go install github.com/steveyegge/gastown/cmd/gt@latest
gt init  # Initialize town</code></pre>
      </div>
    </section>

    <hr class="section-divider">

    <!-- Related Pages -->
    <div class="related-pages">
      <h3>Related Pages</h3>
      <ul>
        <li><a href="compare-architecture.html">Agent Architectures Compared</a> - Single vs Subagents vs Swarm vs Hierarchical</li>
        <li><a href="compare-memory.html">Memory Approaches Compared</a> - progress.txt, Git, AGENTS.md, Claude-Mem</li>
        <li><a href="compare-ralph-variants-complete.html">Ralph Variants Complete</a> - Deep dive on all Ralph patterns</li>
      </ul>
    </div>

    <!-- Footer Navigation -->
    <nav class="footer-nav">
      <a href="compare-architecture.html" class="nav-prev">
        <span class="nav-direction">Previous</span>
        <span class="nav-title">Architecture Compared</span>
      </a>
      <a href="compare-memory.html" class="nav-next">
        <span class="nav-direction">Next</span>
        <span class="nav-title">Memory Compared</span>
      </a>
    </nav>

  </div>

  <nav class="left-nav" id="leftNav">
    <div class="px-4 mb-4">
      <a href="../index.html" class="text-xs font-semibold text-accent hover:text-accent-light uppercase tracking-wider">Claude Code KB</a>
    </div>
    <div class="nav-content"></div>
  </nav>

  <script src="../js/search.js"></script>
  <script src="../js/sidebar.js"></script>
  <script src="../js/global-nav.js"></script>
  <script>
    function copyCode(button) {
      const codeBlock = button.parentElement.querySelector('code');
      navigator.clipboard.writeText(codeBlock.textContent);
      button.textContent = 'Copied!';
      button.classList.add('copied');
      setTimeout(() => {
        button.textContent = 'Copy';
        button.classList.remove('copied');
      }, 2000);
    }
  </script>
</body>
</html>
