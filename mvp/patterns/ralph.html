<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ralph Wiggum Loop | Claude Code Patterns</title>
  <link rel="stylesheet" href="../css/style.css">
</head>
<body>
<main>

  <!-- 1. Header + Metadata -->
  <header class="pattern-header">
    <h1>Ralph Wiggum Loop</h1>
    <div class="pattern-meta">
      <span class="meta-item">Type: Automation</span>
      <span class="meta-item">Problem: Repetitive manual prompting</span>
      <span class="meta-item">Complexity: Level 2-3</span>
      <span class="meta-item">Creator: Geoffrey Huntley (named by Matt Pocock)</span>
    </div>
  </header>

  <!-- 2. Why This Matters -->
  <section class="why-matters">
    <h2>Why This Matters</h2>
    <p>LLMs degrade with accumulated context ("context rot"). Quality drops as tokens pile up. Ralph solves this by spawning a fresh Claude instance every iteration, with memory living in external files.</p>
    <blockquote>
      "Think of the AI agent as an <strong>eager but somewhat dim junior developer (Ralph)</strong> who never sleeps, happily works on one tiny task at a time, commits often, and tells you when it's truly finished."
      <cite>-- Matt Pocock</cite>
    </blockquote>
    <p>The result: "ship while you sleep" workflows. Wake up to completed features.</p>
  </section>

  <!-- 3. Architecture -->
  <section id="architecture">
    <h2>Architecture</h2>
    <pre class="ascii-diagram">
┌─────────────────────────────────┐
│  Pick task from prd.json        │
│         ↓                       │
│  Complete ONE task              │
│         ↓                       │
│  Verify (tests, typecheck)      │
│         ↓                       │
│  Commit + update prd.json       │
│         ↓                       │
│  All done? → Exit               │
│  Not done? → Fresh instance     │
└─────────────────────────────────┘
    </pre>
    <p>Each iteration spawns a NEW Claude instance with zero memory of previous runs. Continuity comes from external artifacts: git history, prd.json for task state, and progress.txt for learnings. This Kanban-style loop focuses on WHAT to achieve, not HOW to sequence phases.</p>
  </section>

  <!-- 4. How It Works -->
  <section id="how-it-works">
    <h2>How It Works</h2>
    <ol class="how-steps">
      <li>Read prd.json to find highest-priority incomplete task</li>
      <li>Read progress.txt for codebase patterns from previous iterations</li>
      <li>Implement that ONE task (must fit in single context window)</li>
      <li>Run typecheck and tests to verify</li>
      <li>Commit with format: <code>feat: [ID] - [Title]</code></li>
      <li>Update prd.json: set <code>passes: true</code></li>
      <li>Append learnings to progress.txt</li>
      <li>If all tasks pass, output <code>&lt;promise&gt;COMPLETE&lt;/promise&gt;</code></li>
    </ol>

    <h3>Data Flow</h3>
    <pre class="ascii-diagram">
prompt.md ──→ Claude ──→ Code Changes ──→ Tests
     ↑                         ↓
prd.json ←───────────── Update status
     ↑                         ↓
progress.txt ←────────── Append learnings
    </pre>

    <h3>Where State Lives</h3>
    <table class="state-table">
      <tr><th>File</th><th>Purpose</th><th>Access Mode</th></tr>
      <tr><td>prd.json</td><td>Task board with user stories</td><td>Read + Update</td></tr>
      <tr><td>progress.txt</td><td>Learnings across iterations</td><td>Read + APPEND only</td></tr>
      <tr><td>Filesystem</td><td>Actual code changes</td><td>Read + Write</td></tr>
      <tr><td>Git history</td><td>Code change log</td><td>Commit each iteration</td></tr>
    </table>
  </section>

  <!-- 5. Key Decisions -->
  <section id="key-decisions">
    <h2>Key Decisions</h2>
    <div class="decision">
      <strong>Chose:</strong> Fresh context per iteration<br>
      <strong>Rejected:</strong> Accumulated context<br>
      <strong>Why:</strong> LLMs degrade with token accumulation. Fresh starts maintain quality.
    </div>
    <div class="decision">
      <strong>Chose:</strong> External memory (files)<br>
      <strong>Rejected:</strong> In-context memory<br>
      <strong>Why:</strong> Files persist across sessions. Context windows get wiped.
    </div>
    <div class="decision">
      <strong>Chose:</strong> One task per iteration<br>
      <strong>Rejected:</strong> Multi-task batching<br>
      <strong>Why:</strong> Tasks must fit in context window. Verification after each task catches errors early.
    </div>
    <div class="decision">
      <strong>Chose:</strong> Explicit completion signal<br>
      <strong>Rejected:</strong> Implicit task detection<br>
      <strong>Why:</strong> <code>&lt;promise&gt;COMPLETE&lt;/promise&gt;</code> is unambiguous and greppable.
    </div>
  </section>

  <!-- 6. Entry Points -->
  <section id="entry-points">
    <h2>Entry Points</h2>
    <ol class="entry-files">
      <li><strong>ralph.sh</strong> - The loop script. Start here to understand execution flow.</li>
      <li><strong>prompt.md</strong> - Agent instructions. Defines what Claude does each iteration.</li>
      <li><strong>prd.json</strong> - Task board. Add your user stories here.</li>
      <li><strong>progress.txt</strong> - External memory. Check for codebase patterns.</li>
    </ol>
  </section>

  <!-- 7. Copy-Paste Templates -->
  <section id="copy-paste">
    <h2>Copy-Paste Templates</h2>

    <h3>ralph.sh - The Loop Engine</h3>
    <div class="code-block">
      <button class="copy-btn" onclick="copyCode(this)">Copy</button>
      <pre><code>#!/bin/bash
set -e

MAX_ITERATIONS=${1:-10}
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

echo "Starting Ralph"

for i in $(seq 1 $MAX_ITERATIONS); do
  echo "=== Iteration $i ==="

  OUTPUT=$(cat "$SCRIPT_DIR/prompt.md" \
    | claude --dangerously-skip-permissions 2>&1 \
    | tee /dev/stderr) || true

  if echo "$OUTPUT" | grep -q "&lt;promise&gt;COMPLETE&lt;/promise&gt;"; then
    echo "Done!"
    exit 0
  fi

  sleep 2
done

echo "Max iterations reached"
exit 1</code></pre>
    </div>

    <h3>prd.json - Task Board</h3>
    <div class="code-block">
      <button class="copy-btn" onclick="copyCode(this)">Copy</button>
      <pre><code>{
  "project": "Your Project",
  "branchName": "ralph/feature-name",
  "userStories": [
    {
      "id": "US-001",
      "title": "Add login form",
      "acceptanceCriteria": [
        "Email/password fields render",
        "Validates email format",
        "npm run typecheck passes",
        "npm run test passes"
      ],
      "priority": 1,
      "passes": false
    },
    {
      "id": "US-002",
      "title": "Add auth server action",
      "acceptanceCriteria": [
        "Checks credentials against database",
        "Returns session token on success",
        "npm run typecheck passes"
      ],
      "priority": 2,
      "passes": false
    }
  ]
}</code></pre>
    </div>

    <h3>prompt.md - Agent Instructions</h3>
    <div class="code-block">
      <button class="copy-btn" onclick="copyCode(this)">Copy</button>
      <pre><code># Ralph Agent Instructions

## Your Task
1. Read `prd.json`
2. Read `progress.txt` (check Codebase Patterns first)
3. Pick highest priority story where `passes: false`
4. Implement that ONE story
5. Run typecheck and tests
6. Commit: `feat: [ID] - [Title]`
7. Update prd.json: `passes: true`
8. APPEND learnings to progress.txt

## Stop Condition
If ALL stories pass, reply exactly:
&lt;promise&gt;COMPLETE&lt;/promise&gt;</code></pre>
    </div>
  </section>

  <!-- 8. What's Unusual -->
  <section id="whats-unusual">
    <h2>What's Unusual</h2>
    <div class="unusual">
      <strong>Standard:</strong> Maintain conversation context<br>
      <strong>This Pattern:</strong> Wipe context every iteration<br>
      <strong>Why:</strong> Fresh starts prevent context rot. External files provide continuity.
    </div>
    <div class="unusual">
      <strong>Standard:</strong> Human orchestrates task sequence<br>
      <strong>This Pattern:</strong> Agent picks next task from board<br>
      <strong>Why:</strong> Kanban-style is more flexible than phased plans. Easy to add/reorder tasks.
    </div>
    <div class="unusual">
      <strong>Standard:</strong> Agent remembers previous work<br>
      <strong>This Pattern:</strong> Agent re-reads state from files<br>
      <strong>Why:</strong> Files are the source of truth. No hallucinated memory of past iterations.
    </div>
    <blockquote>
      "What's amazing is I can ask it to look at previous runs to learn what worked or didn't work. So every time I run Ralph, it gets better and better."
      <cite>-- Ryan Carson</cite>
    </blockquote>
  </section>

  <!-- 9. See Also -->
  <section id="see-also">
    <h2>See Also</h2>
    <ul class="related-patterns">
      <li><strong>Gas Town</strong> - Steve Yegge's agent factory (Mayor, Deacon, Dogs, Refinery). More complex orchestration.</li>
      <li><strong>CC Mirror</strong> - Multi-agent coordination via Task tools. Combine with Ralph for parallel execution.</li>
      <li><strong>Fresh Context Principle</strong> - The core idea Ralph builds on. New session > extended session.</li>
      <li><strong>HOTL Ralph</strong> - Human-on-the-loop variant. Single iteration with review between runs.</li>
    </ul>
    <p><strong>Sources:</strong> Geoffrey Huntley (ghuntley.com/ralph), Matt Pocock (@mattpocockuk), Ryan Carson (@ryancarson)</p>
  </section>

</main>

<script src="../js/navigation.js"></script>
<script src="../js/copy-code.js"></script>
<script>
function copyCode(btn) {
  const code = btn.nextElementSibling.querySelector('code');
  navigator.clipboard.writeText(code.textContent.replace(/&lt;/g, '<').replace(/&gt;/g, '>'));
  btn.textContent = 'Copied!';
  setTimeout(() => btn.textContent = 'Copy', 2000);
}
</script>
</body>
</html>
