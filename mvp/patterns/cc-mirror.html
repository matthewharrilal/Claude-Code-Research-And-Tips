<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CC Mirror Pattern</title>
  <link rel="stylesheet" href="../css/style.css">
</head>
<body>
<main>
  <!-- 1. Header + Metadata -->
  <header class="pattern-header">
    <h1>CC Mirror</h1>
    <div class="pattern-meta">
      <span class="meta-item">Type: Multi-Agent Hub-and-Spoke</span>
      <span class="meta-item">Problem: Hidden orchestration enablement</span>
      <span class="meta-item">Complexity: Level 4-5</span>
      <span class="meta-item">Source: @nummanali (Community)</span>
    </div>
  </header>

  <!-- 2. Why This Matters -->
  <section class="why-matters">
    <h2>Why This Matters</h2>
    <p>Anthropic built a complete multi-agent orchestration system into Claude Code but <strong>disabled it</strong>. CC Mirror unlocks it. You get parallel workers, task dependencies, and persistent task queues without building infrastructure. Setup takes 3 commands. This covers 80% of orchestration needs with zero effort.</p>
    <p style="margin-top:1rem; font-style:italic;">"There's no point building your own." - @nummanali</p>
  </section>

  <!-- 3. Architecture -->
  <section id="architecture">
    <h2>Architecture</h2>
    <pre class="ascii-diagram">        +------------------+
        |   ORCHESTRATOR   |
        |   (Conductor)    |
        +--------+---------+
                 |
     Task() with run_in_background=True
                 |
    +------------+------------+
    |            |            |
    v            v            v
+--------+  +--------+  +--------+
|Worker 1|  |Worker 2|  |Worker 3|
| (Code) |  | (Test) |  | (Docs) |
+--------+  +--------+  +--------+
    |            |            |
    +------------+------------+
             Shared Filesystem</pre>
    <p>Hub-and-spoke model. The orchestrator creates tasks and spawns workers. Workers execute independently. Coordination happens through task dependencies (blocks/blockedBy) and the shared filesystem. The orchestrator never writes code - it only delegates.</p>
  </section>

  <!-- 4. How It Works -->
  <section id="how-it-works">
    <h2>How It Works</h2>
    <ol class="how-steps">
      <li><strong>Install variant:</strong> <code>npx cc-mirror quick --provider mirror --name mclaude</code></li>
      <li><strong>Launch:</strong> <code>mclaude</code> - runs isolated Claude Code with orchestration enabled</li>
      <li><strong>Load skill:</strong> Tell it "Load the orchestration skill and initiate"</li>
      <li><strong>Create tasks:</strong> Orchestrator uses TaskCreate with subject, description, acceptance criteria</li>
      <li><strong>Spawn workers:</strong> Task() with run_in_background=True dispatches workers</li>
      <li><strong>Dependencies:</strong> Use blockedBy/blocks to enforce ordering</li>
    </ol>
    <h3>Data Flow</h3>
    <pre class="ascii-diagram">User Request -> Orchestrator -> TaskCreate (dependency graph)
                    |
                    +-> Task() spawn Worker A (claims task)
                    +-> Task() spawn Worker B (claims task)
                    |
Workers complete -> Orchestrator reads results -> Synthesizes</pre>
  </section>

  <!-- 5. Key Decisions -->
  <section id="key-decisions">
    <h2>Key Decisions</h2>
    <div class="decision-grid">
      <div class="decision-card">
        <h4>When to use CC Mirror vs Task()?</h4>
        <p>CC Mirror when: parallel execution, dependency ordering, task persistence, clear decomposition. Standard Task() when: simple one-shot delegation, no cross-session tracking needed.</p>
      </div>
      <div class="decision-card">
        <h4>Model selection per worker?</h4>
        <p><strong>Haiku:</strong> Simple lookups (5-10 parallel). <strong>Sonnet:</strong> Implementation, tests (2-5 parallel). <strong>Opus:</strong> Architecture decisions (1 sequential).</p>
      </div>
      <div class="decision-card">
        <h4>How to prevent file conflicts?</h4>
        <p>Include explicit file ownership in task descriptions. Use git worktrees for true isolation. Sequence dependent tasks with blockedBy.</p>
      </div>
    </div>
  </section>

  <!-- 6. Entry Points -->
  <section id="entry-points">
    <h2>Entry Points</h2>
    <ol class="entry-files">
      <li>npx cc-mirror quick --provider mirror --name mclaude</li>
      <li>mclaude (launch the variant)</li>
      <li>~/.cc-mirror/&lt;variant&gt;/config/tasks/ (task storage)</li>
      <li>npx cc-mirror tasks list (view task queue)</li>
      <li>npx cc-mirror doctor (health check)</li>
    </ol>
  </section>

  <!-- 7. Copy-Paste Templates -->
  <section id="copy-paste">
    <h2>Copy-Paste Templates</h2>

    <h3>Quick Start (3 Commands)</h3>
    <div class="code-block">
      <button class="copy-btn" onclick="copyCode(this)">Copy</button>
      <pre><code>npx cc-mirror quick --provider mirror --name mclaude
mclaude
# Then say: "Load the orchestration skill and initiate"</code></pre>
    </div>

    <h3>Worker Preamble Template</h3>
    <div class="code-block">
      <button class="copy-btn" onclick="copyCode(this)">Copy</button>
      <pre><code>CONTEXT: You are a WORKER agent, not an orchestrator.

RULES:
- Complete ONLY the task described below
- Use tools directly (Read, Write, Edit, Bash, etc.)
- Do NOT spawn sub-agents
- Do NOT call TaskCreate or TaskUpdate
- Report your results with absolute file paths

TASK:
[Your specific task here]</code></pre>
    </div>

    <h3>Task Management Commands</h3>
    <div class="code-block">
      <button class="copy-btn" onclick="copyCode(this)">Copy</button>
      <pre><code>npx cc-mirror tasks list              # View all tasks
npx cc-mirror tasks show &lt;id&gt;         # Task details
npx cc-mirror tasks graph             # Dependency visualization
npx cc-mirror tasks clean --resolved  # Clean completed tasks</code></pre>
    </div>
  </section>

  <!-- 8. What's Unusual -->
  <section id="whats-unusual">
    <h2>What's Unusual</h2>
    <ul class="unusual-list">
      <li><strong>Hidden API:</strong> TaskCreate, TaskList, TaskUpdate, TaskGet are built into Claude Code but disabled. CC Mirror patches the minified JS to enable them.</li>
      <li><strong>The Iron Law:</strong> Orchestrator NEVER writes code. It only delegates. Violating this causes context pollution and verification bypass.</li>
      <li><strong>Auto-compact required:</strong> Enable auto-compact beta feature to prevent context collapse during orchestration.</li>
      <li><strong>Beta/unstable:</strong> Claude Code updates may break CC Mirror. Relies on editing minified JS.</li>
    </ul>
  </section>

  <!-- 9. See Also -->
  <section id="see-also">
    <h2>See Also</h2>
    <div class="see-also">
      <a href="ralph-wiggum.html">Ralph Wiggum Loop (sequential iteration alternative)</a>
      <a href="gas-town.html">Gas Town (factory-scale orchestration)</a>
      <a href="https://github.com/numman-ali/cc-mirror">CC Mirror GitHub Repository</a>
    </div>
  </section>
</main>

<script src="../js/navigation.js"></script>
<script src="../js/copy-code.js"></script>
<script>
function copyCode(btn) {
  const code = btn.nextElementSibling.textContent;
  navigator.clipboard.writeText(code).then(() => {
    btn.textContent = 'Copied!';
    setTimeout(() => btn.textContent = 'Copy', 2000);
  });
}
</script>
</body>
</html>
