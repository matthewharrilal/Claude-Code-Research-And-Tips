<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>The Staff Engineer Mental Model for AI Agent Architecture</title>

  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Instrument+Serif:ital@0;1&family=Inter:wght@400;600&family=JetBrains+Mono&display=swap" rel="stylesheet">

  <style>
    /* ============================================
       TOKENS FROM vocabulary/tokens.css
       ============================================ */
    :root {
      /* Soul constraints */
      --border-radius: 0;
      --box-shadow: none;

      /* Primary colors (IMMUTABLE) */
      --color-primary: #E83025;
      --color-background: #FEF9F5;
      --color-text: #1A1A1A;
      --color-text-secondary: #666666;
      --color-border: #E0D5C5;
      --color-border-subtle: #F0EBE3;

      /* Accent colors */
      --accent-blue: #4A90D9;
      --accent-green: #4A9D6B;
      --accent-coral: #C97065;
      --accent-amber: #D97706;

      /* Typography trinity (IMMUTABLE) */
      --font-display: 'Instrument Serif', Georgia, serif;
      --font-body: 'Inter', system-ui, sans-serif;
      --font-mono: 'JetBrains Mono', 'SF Mono', monospace;

      /* Type scale */
      --text-xs: 0.75rem;       /* 12px */
      --text-sm: 0.875rem;      /* 14px */
      --text-base: 1rem;        /* 16px */
      --text-lg: 1.125rem;      /* 18px */
      --text-h3: 1.5rem;        /* 24px */
      --text-h2: 2rem;          /* 32px */
      --text-h1: 2.5rem;        /* 40px */

      /* Spacing scale (4px base) */
      --space-2: 8px;
      --space-3: 12px;
      --space-4: 16px;
      --space-5: 20px;
      --space-6: 24px;
      --space-8: 32px;
      --space-10: 40px;
      --space-12: 48px;
      --space-16: 64px;
      --space-20: 80px;

      /* Border weights */
      --border-structural: 4px;
      --border-accent: 3px;
      --border-micro: 1px;

      /* Metamorphic zones (temperature gradient) */
      --zone-diagenetic: #FEF9F5;    /* Low heat - warm cream */
      --zone-low-grade: #FAF5ED;      /* Medium heat - warmer */
      --zone-medium-grade: #F0EBE3;   /* High heat - warmest */
    }

    /* ============================================
       BASE STYLES
       ============================================ */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: var(--font-body);
      font-size: var(--text-base);
      line-height: 1.7;
      color: var(--color-text);
      background: var(--zone-diagenetic);
    }

    /* Container (940px minimum at 1440px = 65%) */
    .page-container {
      max-width: 1000px;
      margin: 0 auto;
      padding: var(--space-16) var(--space-8);
    }

    /* ============================================
       TYPOGRAPHY HIERARCHY
       ============================================ */
    h1, h2, h3 {
      font-family: var(--font-display);
      line-height: 1.3;
      margin-bottom: var(--space-4);
    }

    h1 {
      font-size: var(--text-h1);
      margin-bottom: var(--space-8);
    }

    h2 {
      font-size: var(--text-h2);
      margin-top: var(--space-16);
      margin-bottom: var(--space-6);
    }

    h3 {
      font-size: var(--text-h3);
      font-style: italic;
      margin-top: var(--space-12);
      margin-bottom: var(--space-4);
    }

    p {
      margin-bottom: var(--space-6);
    }

    strong {
      font-weight: 600;
    }

    /* ============================================
       METAMORPHIC ZONES (3 grades)
       Background warmth = temperature gradient
       ============================================ */

    /* Diagenetic Zone (never trust - unstable, barely altered) */
    .zone-diagenetic {
      background: var(--zone-diagenetic);
      padding: var(--space-20) var(--space-8); /* 80px - sparse (low stability) */
      border-left: var(--border-micro) solid var(--color-border-subtle);
    }

    /* Low-Grade Metamorphic (verify always - chlorite zone, some stability) */
    .zone-low-grade {
      background: var(--zone-low-grade);
      padding: var(--space-16) var(--space-8); /* 64px - moderate (building stability) */
      border-left: var(--border-accent) solid var(--color-border);
    }

    /* Medium-Grade Metamorphic (trust with monitoring - biotite/garnet, stable) */
    .zone-medium-grade {
      background: var(--zone-medium-grade);
      padding: var(--space-12) var(--space-8); /* 48px - dense (high stability) */
      border-left: var(--border-structural) solid var(--color-text-secondary);
    }

    /* Compression ratio: 80px / 48px = 1.67:1 (within 40% floor = 2.5:1 maximum) */

    /* ============================================
       ISOGRAD BOUNDARIES (sharp threshold lines)
       border-radius: 0 = angular boundaries
       ============================================ */
    .isograd {
      border-top: var(--border-accent) solid var(--color-border);
      margin: var(--space-12) 0;
      padding-top: var(--space-6);
    }

    /* Stronger isograd for major transitions (Wave 3→4, Wave 4→5) */
    .isograd--major {
      border-top: var(--border-structural) solid var(--color-text);
      margin: var(--space-16) 0;
    }

    /* ============================================
       PARENT ROCK IDENTITY (core self sections)
       Serif typography = original identity persists
       ============================================ */
    .parent-identity {
      font-family: var(--font-display);
      font-size: var(--text-lg);
      font-style: italic;
      color: var(--color-text-secondary);
      padding: var(--space-6);
      border-left: var(--border-structural) solid var(--accent-amber);
      background: rgba(217, 119, 6, 0.05);
      margin: var(--space-8) 0;
    }

    /* ============================================
       TRANSFORMATION MARKERS (contact metamorphism)
       4px left border = localized insight/lesson
       ============================================ */
    .transformation-marker {
      border-left: var(--border-structural) solid var(--color-primary);
      padding: var(--space-6) var(--space-5);
      margin: var(--space-8) 0;
      background: rgba(232, 48, 37, 0.05);
    }

    .transformation-marker__label {
      font-family: var(--font-mono);
      font-size: var(--text-xs);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--color-primary);
      margin-bottom: var(--space-3);
    }

    /* ============================================
       MINERAL ASSEMBLAGE (capability sets)
       Lists with semantic bullets
       ============================================ */
    .mineral-assemblage {
      margin: var(--space-6) 0;
      padding-left: var(--space-6);
    }

    .mineral-assemblage li {
      margin-bottom: var(--space-3);
      line-height: 1.6;
    }

    .mineral-assemblage li::marker {
      color: var(--color-border);
    }

    /* ============================================
       DUAL-STATE ENCODING (parent AND transformed)
       Split-column for "this AND that" logic
       ============================================ */
    .dual-state {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--space-6);
      margin: var(--space-8) 0;
      padding: var(--space-6);
      border: var(--border-micro) solid var(--color-border);
    }

    .dual-state__parent,
    .dual-state__transformed {
      padding: var(--space-5);
    }

    .dual-state__parent {
      border-left: var(--border-accent) solid var(--color-border);
      background: var(--zone-diagenetic);
    }

    .dual-state__transformed {
      border-left: var(--border-accent) solid var(--color-text-secondary);
      background: var(--zone-low-grade);
    }

    .dual-state__label {
      font-family: var(--font-mono);
      font-size: var(--text-xs);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      margin-bottom: var(--space-3);
      color: var(--color-text-secondary);
    }

    /* ============================================
       RESPONSIVE (768px breakpoint)
       ============================================ */
    @media (max-width: 768px) {
      .page-container {
        padding: var(--space-12) var(--space-6);
      }

      h1 {
        font-size: 2rem;
      }

      h2 {
        font-size: 1.625rem;
      }

      .dual-state {
        grid-template-columns: 1fr;
        gap: var(--space-4);
      }

      .zone-diagenetic,
      .zone-low-grade,
      .zone-medium-grade {
        padding-left: var(--space-6);
        padding-right: var(--space-6);
      }
    }
  </style>
</head>
<body>
  <div class="page-container">

    <!-- HEADER: Regional metamorphism (page-level context) -->
    <header style="border-bottom: var(--border-accent) solid var(--color-border); padding-bottom: var(--space-8); margin-bottom: var(--space-16);">
      <h1>The Staff Engineer Mental Model for AI Agent Architecture</h1>
      <p style="font-size: var(--text-lg); color: var(--color-text-secondary); line-height: 1.6;">
        Frontier thinking for practitioners navigating the paradigm shift from coder to orchestrator. This is where cutting-edge development is heading.
      </p>
    </header>

    <!-- PARENT IDENTITY: Original coder identity (preserved through transformation) -->
    <div class="parent-identity">
      What does it mean to be a software engineer when you're not writing software? What expertise remains valuable when code generation becomes commoditized? This transition feels uncomfortable because it is.
    </div>

    <!-- SECTION 1: The Paradigm Shift (DIAGENETIC ZONE - never trust without verification) -->
    <section class="zone-diagenetic">
      <h2>The Paradigm Shift</h2>

      <p>Software development is undergoing its most challenging transition ever. The traditional developer's role — writing code line-by-line, debugging syntax errors, managing state mutations — is transforming into something fundamentally different. You become a high-level orchestrator, a strategic guide who coordinates AI teams rather than writing every function.</p>

      <div class="dual-state">
        <div class="dual-state__parent">
          <div class="dual-state__label">What Changes</div>
          <p>You don't write code anymore. Your fingers spend less time on the keyboard, more time reviewing pull requests from agents. You orchestrate, validate, verify. The muscle memory of coding becomes secondary to a different kind of thinking.</p>
        </div>
        <div class="dual-state__transformed">
          <div class="dual-state__label">What Persists</div>
          <p>Architecture matters more than ever. System design is still your job. Quality standards remain your responsibility. You still need to understand what the code does, perhaps more deeply than before, because you're accountable for output you didn't personally write.</p>
        </div>
      </div>

      <p>The challenge isn't technical. Engineers can learn new tools, new frameworks, new languages. The challenge is identity. What does it mean to be a software engineer when you're not writing software? What expertise remains valuable when code generation becomes commoditized?</p>

      <p>This transition feels uncomfortable because it is. You're letting go of craft while remaining fully accountable for quality. You're trusting systems that make mistakes while maintaining zero-defect standards. You're moving fast while building production-grade systems. Every paradox creates tension.</p>
    </section>

    <!-- ISOGRAD: Trust gradient begins -->
    <div class="isograd--major"></div>

    <!-- SECTION 2: The Trust Gradient (LOW-GRADE ZONE - verify always, building stability) -->
    <section class="zone-low-grade">
      <h2>The Trust Gradient</h2>

      <p>Trust is the number one thing keeping the industry from rocketing forward. You can't trust anything — you have to validate and verify. This isn't pessimism; it's realism grounded in production statistics.</p>

      <p>The numbers don't lie. Multi-agent systems fail at rates between 41% and 86.7%. Error amplification in independent agent architectures runs at 17.2x compared to centralized orchestration's 4.4x. Even optimistic assumptions — 95% success per step — yield only 36% success for a 20-step workflow. Production aims for 99.9%+ reliability. Agents are nowhere near that.</p>

      <p>But here's the paradox: you must build trust scaffolding around fundamentally untrustworthy components. You need guardrails that assume failure while enabling speed. You need monitoring that catches problems early while not slowing development to a crawl.</p>

      <div class="transformation-marker">
        <div class="transformation-marker__label">Metamorphic Grade → Trust Tier</div>
        <ul class="mineral-assemblage">
          <li><strong>Diagenetic (barely altered):</strong> Never trust — File operations, database mutations, deployments. Require human approval, always.</li>
          <li><strong>Low-grade (chlorite zone):</strong> Verify always — Code changes, API calls, git operations. Check output, run tests, review diff.</li>
          <li><strong>Medium-grade (biotite zone):</strong> Trust with monitoring — Read operations, analysis tasks, planning. Let agents work, but watch logs, set timeouts, check after.</li>
        </ul>
      </div>

      <p>This gradient isn't about lack of confidence in AI capabilities. It's about production reality. A $47,000 lesson from a research tool that slipped into a recursive loop teaches you to implement hard caps. Eleven days of unmonitored execution teaches you that automation without bounds becomes automation without value.</p>
    </section>

    <!-- ISOGRAD: Wave progression begins -->
    <div class="isograd"></div>

    <!-- SECTION 3: The Wave Progression (LOW-GRADE ZONE - understanding builds) -->
    <section class="zone-low-grade">
      <h2>The Wave Progression</h2>

      <p>Understanding where AI-assisted development is heading requires understanding where it's been. Each modality wave brings roughly 5x productivity gains over its predecessor:</p>

      <ul class="mineral-assemblage">
        <li><strong>Wave 1: Traditional Coding</strong> — Writing every line manually, debugging by print statement, managing every detail. The baseline. Productivity: 1x.</li>
        <li><strong>Wave 2: Code Completions</strong> — GitHub Copilot suggests the next line. You still drive, but with assistance. Productivity: 5x over manual.</li>
        <li><strong>Wave 3: Chat-Based Coding</strong> — Claude or GPT helping you solve problems through conversation. Ask a question, get code back. Productivity: 25x over manual.</li>
        <li><strong>Wave 4: Coding Agents</strong> — Autonomous systems that take tasks and complete them without supervision. Single agents working through requirements. Productivity: 125x over manual.</li>
        <li><strong>Wave 5: Agent Clusters</strong> — Multiple specialized agents coordinating on complex work. Hub-and-spoke architectures, orchestrators delegating to workers. Productivity: 625x over manual.</li>
        <li><strong>Wave 6: Agent Fleets</strong> — Full agent factories with hierarchies, persistent workers, automatic decomposition. Self-improving systems managing themselves. Productivity: 3,125x over manual.</li>
      </ul>

      <p>Most of the industry operates between Wave 3 and early Wave 4. A few practitioners have reached Wave 5. Almost nobody has reached Wave 6, except experimenters willing to spend $50-200/day on agent infrastructure.</p>

      <p>The gap between waves isn't linear. Moving from Wave 3 to Wave 4 isn't learning a new tool — it's adopting a new mental model. You stop being an active coder and become a task decomposer. Moving from Wave 4 to Wave 5 requires thinking about coordination, about which agents should handle which work, about dependency graphs and parallel execution.</p>
    </section>

    <!-- ISOGRAD: Production reality threshold -->
    <div class="isograd--major"></div>

    <!-- SECTION 4: Production Reality (MEDIUM-GRADE ZONE - stable, trust with monitoring) -->
    <section class="zone-medium-grade">
      <h2>Production Reality</h2>

      <p>Theory meets practice in production, and practice teaches humility. AI project failure rates run above 80% — more than double the failure rate of typical IT projects. These aren't hobbyist experiments; these are funded initiatives with engineering teams and business objectives.</p>

      <p>The math of multi-step workflows is unforgiving. Twenty steps at 95% success per step yields 36% overall success. Twenty steps at 90% per step — generous for complex agent operations — yields 12% success. Production needs 99.9%. The gap is enormous.</p>

      <div class="transformation-marker">
        <div class="transformation-marker__label">Contact Metamorphism: $47k Lesson</div>
        <p>Context degradation is the primary failure mode, more common than API errors, more insidious than hallucinations. Agents start strong, middle sections accumulate confusion, late-stage outputs become incoherent. The orchestrator's context fills with worker reports. Working memory gets polluted with irrelevant details. Each step compounds the noise.</p>
      </div>

      <p>Tool calling fails at rates between 3% and 15%, depending on the model and the complexity of available tools. Multiply across dozens of calls per agent, dozens of agents per workflow, and you get frequent breakdowns. The system becomes brittle.</p>

      <p>Error amplification punishes poor architecture. Independent agents — each making decisions without coordination — amplify errors by a factor of 17.2x. Centralized orchestration reduces that to 4.4x, still significant but manageable. The difference between architectural approaches isn't aesthetic; it's the difference between systems that fail constantly and systems that fail occasionally.</p>
    </section>

    <!-- ISOGRAD: Infrastructure transition -->
    <div class="isograd"></div>

    <!-- SECTION 5: Infrastructure Over Wrappers (MEDIUM-GRADE ZONE - stable practice) -->
    <section class="zone-medium-grade">
      <h2>Infrastructure Over Wrappers</h2>

      <p>Almost everyone starts with LangChain or similar frameworks. Almost everyone eventually strips them out. This pattern repeats so consistently across practitioners that it deserves examination.</p>

      <p>Frameworks promise to simplify agent development. They abstract the hard parts — API calls, context management, tool integration — into higher-level primitives. In demos, this looks elegant. In production, it becomes a liability.</p>

      <p>The problem isn't the frameworks themselves. The problem is the mismatch between what frameworks optimize for (getting started quickly) and what production needs (control, observability, debuggability). Frameworks hide complexity, which helps beginners but hinders experts. When you need to understand why an agent is making bad tool calls, the abstraction becomes an obstacle.</p>

      <p>Production is FastAPI and direct API calls. Simple, transparent, controllable. You write the orchestration logic yourself. You manage context explicitly. You log everything that matters. It's more code, but it's code you understand, code you can debug, code you can trust.</p>

      <p>Infrastructure thinking means treating agent systems like distributed systems. You implement health checks. You build observability into the core, not bolted on afterward. You design for failure, because failure is the normal case. You version your prompts like you version your code. You A/B test changes to orchestration logic.</p>
    </section>

    <!-- ISOGRAD: Separation principle -->
    <div class="isograd--major"></div>

    <!-- SECTION 6: The Orchestrator Separation (MEDIUM-GRADE ZONE - Iron Law enforcement) -->
    <section class="zone-medium-grade">
      <h2>The Orchestrator Separation</h2>

      <p><strong>The Iron Law:</strong> Orchestrators coordinate. Workers execute. Never mix these responsibilities.</p>

      <p>This separation isn't organizational preference — it's architectural necessity. Mixing the roles creates systems that fail in predictable, costly ways.</p>

      <p>An orchestrator that writes code becomes confused about its job. Is it managing the overall workflow or solving the current implementation problem? Context fills with both strategic coordination and tactical details. The agent loses the overview while gaining expertise in individual tasks — exactly backward.</p>

      <p>A worker that tries to coordinate loses focus. Instead of solving the assigned problem deeply, it worries about dependencies, about what other workers are doing, about the overall plan. Coordination overhead pollutes task execution.</p>

      <div class="transformation-marker">
        <div class="transformation-marker__label">Mineral Assemblage: Architecture Impact</div>
        <p>Error amplification demonstrates the cost. Independent agents without orchestration amplify errors by <strong>17.2x</strong>. That factor comes from agents making conflicting decisions, duplicating work, missing dependencies, operating on stale assumptions. Centralized orchestration cuts amplification to <strong>4.4x</strong> because coordination prevents the worst failure modes.</p>
      </div>

      <p>The separation enables specialization. Orchestrators can be smaller, cheaper models (Haiku or Sonnet) optimized for planning and decomposition. Workers can be matched to task difficulty — Opus for complex architecture, Sonnet for standard code, Haiku for simple lookups. This optimization saves costs while improving quality.</p>

      <p>Violating the Iron Law is the second-fastest way to fail at multi-agent systems. (The fastest is running without cost caps.) Respecting it doesn't guarantee success, but violation guarantees failure.</p>
    </section>

    <!-- ISOGRAD: Economic considerations -->
    <div class="isograd"></div>

    <!-- SECTION 7: The Economics of Scale (LOW-GRADE ZONE - verify cost models) -->
    <section class="zone-low-grade">
      <h2>The Economics of Scale</h2>

      <p>Each agent costs roughly $10-12 per hour in tokens. Each agent provides roughly 1x developer productivity. Five agents running in parallel provide 5x productivity at $50-60/hour. The math is simple, but the implications are profound.</p>

      <p>Traditional software economics optimize for developer salaries. Pay $150k/year, get ~2000 productive hours, cost is $75/hour. Hiring decisions balance compensation against productivity. Scaling means hiring more people, which means recruiting, onboarding, management overhead.</p>

      <p>Agent economics invert this. Variable cost instead of fixed. Instant scaling instead of months of hiring. No management overhead, just orchestration complexity. You can run 5 agents for an hour to ship a feature, then scale to zero. Try that with human developers.</p>

      <p>But the cost model creates new pressures. $50/hour burns $400/day if agents run constantly. $400/day is $10,000/month, $120,000/year — approaching developer salary territory but without the reliability. Runaway processes become budget disasters.</p>

      <p>The frontier practitioners budget $50k+/year per developer in LLM spend. That's on top of salaries, not instead of them. The model is leverage: developers orchestrate agents who do the grunt work, developers focus on architecture and quality, agents handle implementation details.</p>
    </section>

    <!-- ISOGRAD: Memory problem -->
    <div class="isograd"></div>

    <!-- SECTION 8: The Memory Problem (LOW-GRADE ZONE - structured state required) -->
    <section class="zone-low-grade">
      <h2>The Memory Problem</h2>

      <p>Agents wake up with no memory of yesterday. This "50 First Dates" problem kills productivity more than any other single factor.</p>

      <p>Markdown files don't work. Agents try, they generate elaborate six-phase plans, they write TODO lists, they create progress documents. Then the next session starts, and they can't find the right file, or they misinterpret what was written, or they create a new plan that contradicts the old one.</p>

      <p>The problem is fundamental: markdown is text for humans, not structured data for agents. It's not queryable. It requires interpretation. Different agents parse it differently. Updates conflict. State becomes ambiguous.</p>

      <p>Structured memory systems solve this. SQLite databases where agents log their state. Git-backed issue trackers with dependency graphs. Beads-style distributed task systems with explicit status tracking. The key is structure — data you can query, update atomically, reason about programmatically.</p>

      <p>Learning must compound. Each session should build on previous sessions, not start from scratch. The agent that debugged authentication yesterday should remember those lessons today. The orchestrator that decomposed a similar task last week should apply that pattern this week.</p>
    </section>

    <!-- ISOGRAD: Frontier questions (open territory) -->
    <div class="isograd--major"></div>

    <!-- SECTION 9: The Frontier Questions (DIAGENETIC ZONE - exploratory, verify everything) -->
    <section class="zone-diagenetic">
      <h2>The Frontier Questions</h2>

      <p>What staff engineers think about now:</p>

      <ul class="mineral-assemblage">
        <li><strong>How do you manage 20-30 agents at once?</strong> Not conceptually, but operationally. How do you monitor them? How do you know when they're stuck? How do you prevent them from interfering with each other? The answer emerging: factory-scale monitoring, Kubernetes-like orchestration, automatic health checks and restarts.</li>

        <li><strong>How do agents remember across sessions?</strong> Markdown fails. Task systems work but require design. The answer emerging: structured external state, queryable task graphs, dependency tracking as first-class concept.</li>

        <li><strong>How do you prevent runaway costs?</strong> Hard caps help but create new problems when useful work hits the limit. The answer emerging: graduated caps with notifications, anomaly detection on burn rate, circuit breakers on recursive patterns.</li>

        <li><strong>How do you handle coordination failures?</strong> Centralized orchestration helps but creates bottlenecks. The answer emerging: hierarchical orchestration, sub-orchestrators for domains, event-driven coordination with compensation logic.</li>

        <li><strong>When do you stop automating and stay interactive?</strong> Not everything should be autonomous. Exploratory work benefits from human insight. Security-critical decisions need human judgment. The answer emerging: classification frameworks that route tasks to appropriate automation levels.</li>
      </ul>

      <p>These questions don't have settled answers. They represent active research areas where practitioners are experimenting, failing, learning, sharing. The frontier is messy. The best practices are still emerging. The mental models are still forming.</p>

      <p>But patterns are appearing. Infrastructure over frameworks. Orchestrator/worker separation. Structured memory systems. Monitoring and caps as core requirements. Graduated trust based on risk. These patterns hold across multiple practitioners, multiple projects, multiple failures.</p>

      <p>The staff engineer mental model isn't about having answers. It's about asking the right questions, recognizing the patterns, understanding the tradeoffs, building systems that survive contact with reality.</p>
    </section>

    <!-- FOOTER: Metamorphic completion marker -->
    <footer style="margin-top: var(--space-20); padding-top: var(--space-8); border-top: var(--border-accent) solid var(--color-border);">
      <p style="font-size: var(--text-sm); color: var(--color-text-secondary); font-style: italic;">
        Built with the KortAI design system using metaphor-driven composition. Metamorphic Transition Zones: parent identity persists, transformed capabilities emerge.
      </p>
    </footer>

  </div>
</body>
</html>
